<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="http://localhost:4000/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="http://localhost:4000/assets/style.css"/>
<link rel="stylesheet" href="http://localhost:4000/assets/js/lity.min.css"/>



<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="极目楚天舒" />
<meta 
    property="og:title"
    content="
        
            cve-2017-7308 AF_PACKET环形缓冲区整数溢出漏洞分析
        
    " 
/>

<meta property="og:url" content="http://localhost:4000//linux_kernel/2024/09/24/cve-2017-7308-AF_PACKET-%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        cve-2017-7308 AF_PACKET环形缓冲区整数溢出漏洞分析
    
</title>
</head>
<body class="index">
    
        <div class="page-container">
            <aside class="main-sidebar">
                <!-- 包含 TOC -->
                <sidebar class="sidebar">
<ul class="toc-list"><li><a href="#一环境搭建">一、环境搭建</a></li><li><a href="#二af_packet套接字原理">二、AF_PACKET套接字原理</a></li><li><a href="#三漏洞发现过程">三、漏洞发现过程</a></li><li><a href="#四漏洞原理">四、漏洞原理</a><ul><li><a href="#数据结构关系">数据结构关系</a></li><li><a href="#污点传播路径">污点传播路径</a></li></ul></li><li><a href="#五可利用性分析">五、可利用性分析</a><ul><li><a href="#可达性分析">可达性分析</a></li><li><a href="#漏洞具备的能力">漏洞具备的能力</a></li></ul></li><li><a href="#六堆风水">六、堆风水</a></li><li><a href="#七利用流程">七、利用流程</a></li><li><a href="#八漏洞修补">八、漏洞修补</a></li><li><a href="#九c语言整数计算剖析">九、C语言整数计算剖析</a><ul><li><a href="#变量类型转换">变量类型转换</a></li><li><a href="#整数计算过程">整数计算过程</a></li></ul></li><li><a href="#十漏洞挖掘点">十、漏洞挖掘点</a></li></ul></sidebar>
            </aside>
            <!-- 主内容区域 -->
            <main class="main-content">
                <header class="header">
    <section class="logo">
        <a href="http://localhost:4000/" class="logo__link">
            
                <h1>极目楚天舒</h1>
            
        </a>
    </section>
    
    <button id="menuToggle">
        <div></div>
        <div></div>
        <div></div>
    </button>
    <nav class="menu">
        
<ul class="list primary">

    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/linux_kernel.html">
                
                    <img src="http://localhost:4000/assets/img/icons/tux.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Linux内核漏洞</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/linux_userspace.html">
                
                    <img src="http://localhost:4000/assets/img/icons/userspace.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Linux用户态漏洞</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/hardware.html">
                
                    <img src="http://localhost:4000/assets/img/icons/chip.svg"/>
                
                
                    <p style="color: var(--c-themeHueRed)">硬件安全研究</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/meltdown_spectre.html">
                
                    <img src="http://localhost:4000/assets/img/icons/meltdown_spectre.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">CPU 侧信道</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/riscv.html">
                
                    <img src="http://localhost:4000/assets/img/icons/riscv.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">RISC-V</p>
                
                </a>

            
            </div>
            
        </li>   
    
</ul>
    </nav>
</header>
                
                <article class="post">

    <div class="post__title">
       cve-2017-7308 AF_PACKET环形缓冲区整数溢出漏洞分析
    </div>
    <div class="post__meta"> 
        <div class="post__meta__category">
            
                <p class="post__meta__category__title" style="background: var(--c-themeHueBlue)">Linux内核漏洞</p>
            
        </div>
        <p class="post__meta__divider">·</p>
        <div class="post__meta__date">
            2024-09-24
        </div>
        
    </div>

    
    <div class="post__content">
        <p>在packet_set_ring()函数中，通过精心构造的 tp_block_size 和 tp_block_nr 参数，触发一个32位整数乘法计算的溢出，从而绕过内核的安全检查，分配一个远小于预期尺寸的缓冲区，造成“大请求，小分配”的不一致，实现内核堆内存的越界读写，并最终完成本地权限提升。</p>

<h2 id="一环境搭建">一、环境搭建</h2>

<p>实验环境：Ubuntu16.04 内核版本Linux4.8.0双机调试环境</p>

<p>我们需要手工升级Ubuntu16.04的内核到4.8版本以满足漏洞调试的条件。</p>

<p>安装内核编译环境：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>build-essential ncurses-dev xz-utils libssl-dev bc libelf-dev flex bison
</code></pre></div></div>

<p>下载解压Linux4.8源码，进入源码目录，从/boot目录拷贝本机编译配置文件到源码目录下，重新命名为.config文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/linux-4.8<span class="nv">$ </span><span class="nb">cp</span> /boot/config-<span class="si">$(</span><span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span> .config
</code></pre></div></div>

<p>对.config文件进行如下配置以使能AF_PACKET套接字功能和user命名空间：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CONFIG_USER_NS</span><span class="o">=</span>y
<span class="nv">CONFIG_PACKET</span><span class="o">=</span>y
</code></pre></div></div>

<p>编译并安装内核：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/linux-4.8<span class="nv">$ </span>make menuconfig
/linux-4.8<span class="nv">$ </span>make <span class="nt">-j8</span>
/linux-4.8<span class="nv">$ </span><span class="nb">sudo </span>make modules_install
/linux-4.8<span class="nv">$ </span><span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<p>配置/etc/default/grub文件：</p>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/1.png" alt="截屏2024-08-29 19.16.10.png" /></p>

<p>更新grub启动选项，重启虚拟机：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/linux-4.8<span class="nv">$ </span><span class="nb">sudo </span>update-grub
/linux-4.8<span class="nv">$ </span><span class="nb">sudo </span>reboot
</code></pre></div></div>

<h2 id="二af_packet套接字原理">二、AF_PACKET套接字原理</h2>

<p>AF_PACKET套接字向用户态提供了直接向网卡驱动发送/接收数据包的接口，该套接字工作在OSI模型的第二层，与驱动层交换原始数据包，所以需要进程在当前用户命名空间中拥有CAP_NET_RAW权限。</p>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/2.png" alt="截屏2024-08-30 22.05.01.png" /></p>

<p>进程创建AF_PACKET套接字会在内核态创建struct packet_sock对象。进程通过setsockopt系统调用，在内核态创建并配置rx_ring、tx_ring。接收/发送环形队列通过mmap系统调用映射到进程地址空间，可以直接读写mmap内存区域实现原始数据包的收发。</p>

<p>创建AF_PACKET套接字之后，protocol参数指定的链路层协议流量都会镜像一份发送给AF_PACKET套接字，所以可以实现对特定类型流量的监控。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">packet_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_PACKET</span><span class="p">,</span> <span class="kt">int</span> <span class="n">socket_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/cve-2017-7308.jpg" alt="cve-2017-7308.jpg" /></p>

<h2 id="三漏洞发现过程">三、漏洞发现过程</h2>

<p>Project Zero团队使用syzkaller对AF_PACKET类型套接字进行fuzz时测出了内核崩溃。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"enable_syscalls"</span><span class="o">:</span> <span class="p">[</span>
  <span class="s">"socket$packet"</span><span class="p">,</span> <span class="s">"socketpair$packet"</span><span class="p">,</span> <span class="s">"accept$packet"</span><span class="p">,</span> <span class="s">"accept4$packet"</span><span class="p">,</span> 
  <span class="s">"bind$packet"</span><span class="p">,</span> <span class="s">"connect$packet"</span><span class="p">,</span> <span class="s">"sendto$packet"</span><span class="p">,</span> <span class="s">"recvfrom$packet"</span><span class="p">,</span> 
  <span class="s">"getsockname$packet"</span><span class="p">,</span> <span class="s">"getpeername$packet"</span><span class="p">,</span> <span class="s">"listen"</span><span class="p">,</span> <span class="s">"setsockopt"</span><span class="p">,</span> 
  <span class="s">"getsockopt"</span><span class="p">,</span> <span class="s">"syz_emit_ethernet"</span>
 <span class="p">],</span>
</code></pre></div></div>

<p>syzkaller捕捉到了引发内核崩溃的测试用例：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mmap</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="mh">0x7f0000000000</span><span class="o">/</span><span class="mh">0xc8f000</span><span class="p">)</span><span class="o">=</span><span class="n">nil</span><span class="p">,</span> <span class="p">(</span><span class="mh">0xc8f000</span><span class="p">),</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x32</span><span class="p">,</span> <span class="mh">0xffffffffffffffff</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">)</span>
<span class="n">r0</span> <span class="o">=</span> <span class="n">socket</span><span class="err">$</span><span class="n">packet</span><span class="p">(</span><span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x300</span><span class="p">)</span>
<span class="n">setsockopt</span><span class="err">$</span><span class="n">packet_int</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="mh">0x107</span><span class="p">,</span> <span class="mh">0xa</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="mh">0x7f000061f000</span><span class="p">)</span><span class="o">=</span><span class="mh">0x2</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">)</span>
<span class="n">setsockopt</span><span class="err">$</span><span class="n">packet_rx_ring</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="mh">0x107</span><span class="p">,</span> <span class="mh">0x5</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="mh">0x7f0000c8b000</span><span class="p">)</span><span class="o">=</span><span class="err">@</span><span class="n">req3</span><span class="o">=</span><span class="p">{</span><span class="mh">0x10000</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x10000</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">,</span> <span class="mh">0x4</span><span class="p">,</span> <span class="mh">0xfffffffffffffffe</span><span class="p">,</span> <span class="mh">0x5</span><span class="p">},</span> <span class="mh">0x1c</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="四漏洞原理">四、漏洞原理</h2>

<p>该漏洞是无符号整数溢出漏洞。整数溢出在CPU的世界里是允许存在的，但是如果在代码逻辑上存在问题例如不合适的变量类型转换，整数溢出就会变成代码漏洞。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* linux-4.8\net\packet\af_packet.c:packet_set_ring */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">po</span><span class="o">-&gt;</span><span class="n">tp_version</span> <span class="o">&gt;=</span> <span class="n">TPACKET_V3</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">tp_block_size</span> <span class="o">-</span> 
						<span class="n">BLK_PLUS_PRIV</span><span class="p">(</span><span class="n">req_u</span><span class="o">-&gt;</span><span class="n">req3</span><span class="p">.</span><span class="n">tp_sizeof_priv</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="cp">#define BLK_PLUS_PRIV(sz_of_priv) \
	(BLK_HDR_LEN + ALIGN((sz_of_priv), V3_ALIGNMENT))
</span></code></pre></div></div>

<p>packet_set_ring函数对配置环形缓冲区的参数进行校验，其中：</p>

<table>
  <thead>
    <tr>
      <th>变量</th>
      <th>类型</th>
      <th>用途</th>
      <th>来源</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>req→tp_block_size</td>
      <td>unsigned int</td>
      <td>设置环形缓冲区每个块的长度</td>
      <td>攻击者通过setsockopt传入</td>
    </tr>
    <tr>
      <td>req_u-&gt;req3.tp_sizeof_priv</td>
      <td>unsigned int</td>
      <td>设置环形缓冲区每个块中私有区域的长度</td>
      <td>攻击者通过setsockopt传入</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/3.jpg" alt="cve-2017-7308-第 2 页.jpg" /></p>

<p>环形缓冲区由多个块组成，每个块都是由块描述符、私有区域、数据包存放区域组成。上述判断的逻辑是 块的长度-(块描述符+私有区域长度)是否大于0，目的是确保能够容纳数据包。</p>

<p>若通过setsockopt传递如下数据：</p>

<p>A = req-&gt;tp_block_size = 4096 = 0x1000</p>

<p>B = req_u-&gt;req3.tp_sizeof_priv = (1 « 31) + 4096 = 0x80001000</p>

<p>BLK_PLUS_PRIV(B) = (1 « 31) + 4096 + 48 = 0x80001030</p>

<p>A - BLK_PLUS_PRIV(req_u-&gt;req3.tp_sizeof_priv= 0x1000 - 0x80001030 = 0x7fffffd0</p>

<p>(int)0x7fffffd0 &gt; 0</p>

<p>在无符号整数减法运算时，若被减数小于减数，通过借位使得运算结果为一个很大的数，同时CF标志位设为1，强制类型转化int后可能变成一个大的正整数。</p>

<h3 id="数据结构关系">数据结构关系</h3>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/4.jpg" alt="cve-2017-7308-数据结构关系.jpg" /></p>

<h3 id="污点传播路径">污点传播路径</h3>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/5.jpg" alt="cve-2017-7308-污点传播路径.jpg" /></p>

<ol>
  <li>init_prb_bdqc函数中p1指针指向的是struct tpacket_kbdq_core对象，其中p1→blk_sizeof_priv是unsigned short类型，截断了req3.tp_sizeof_priv的低2字节，攻击者可以完全控制p1→blk_sizeof_priv的值。</li>
  <li>p1→blk_sizeof_priv在prb_open_block函数中用于计算数据包的起始写入位置，攻击者可以控制p1→blk_sizeof_priv使数据包写入位置在块的末尾，造成越界写。</li>
</ol>

<h2 id="五可利用性分析">五、可利用性分析</h2>

<h3 id="可达性分析">可达性分析</h3>

<p>Q：使用哪些系统调用可以到达漏洞位置？</p>

<p>A：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_PACKET</span><span class="p">,</span> <span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ALL</span><span class="p">));</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">SOL_PACKET</span><span class="p">,</span> <span class="n">PACKET_VERSION</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">SOL_PACKET</span><span class="p">,</span> <span class="n">PACKET_RX_RING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">req</span><span class="p">));</span>
</code></pre></div></div>

<p>Q：是否需要权限？</p>

<p>A：攻击者需要在当前user namespace中拥有CAP_NET_RAW权限才能调用上述系统调用。</p>

<p>Q：能否绕过权限的限制？</p>

<p>A：使用unshare系统调用创建并进入一个新的user namespace，在新的user namespace中创建一个新的net namespace即可拥有CAP_NET_RAW权限。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">unshare</span><span class="p">(</span><span class="n">CLONE_NEWUSER</span><span class="p">);</span>  <span class="c1">//创建并进入新的user namespace</span>
<span class="n">unshare</span><span class="p">(</span><span class="n">CLONE_NEWNET</span><span class="p">);</span>   <span class="c1">//在新的user namespace中创建新的net namespace</span>
<span class="n">write_file</span><span class="p">(</span><span class="s">"/proc/self/setgroups"</span><span class="p">,</span> <span class="s">"deny"</span><span class="p">);</span>
<span class="n">write_file</span><span class="p">(</span><span class="s">"/proc/self/uid_map"</span><span class="p">,</span> <span class="s">"0 1000 1</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">real_uid</span><span class="p">);</span><span class="c1">//映射uid到父user namespace</span>
<span class="n">write_file</span><span class="p">(</span><span class="s">"/proc/self/gid_map"</span><span class="p">,</span> <span class="s">"0 1000 1</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">real_gid</span><span class="p">);</span><span class="c1">//映射gid到父user namespace</span>
</code></pre></div></div>

<h3 id="漏洞具备的能力">漏洞具备的能力</h3>

<ol>
  <li>漏洞对象类型：环形缓冲区的数据块，存放字符类型的堆块，头部是struct tpacket_block_desc和私有数据区域。</li>
  <li>漏洞对象的大小：块的大小由用户态参数req→tp_block_size控制。</li>
  <li>漏洞对象位置：buddy system分配的连续的物理内存页面。</li>
  <li>溢出字节数：取决于数据包长度，攻击者可控。</li>
  <li>溢出内容：攻击者通过构造数据包控制溢出内容，攻击者可控。</li>
  <li>可以多次触发</li>
</ol>

<h2 id="六堆风水">六、堆风水</h2>

<p>victim 对象：struct packet_sock，位于kmalloc-2048缓存中。当kmalloc-2048缓存消耗殆尽，slub分配器向buddy system请求0x8000大小的连续页面产生新的kmalloc-2048缓存。</p>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/ak04.png" alt="ak04.png" /></p>

<p>思路：</p>

<ol>
  <li>创建512个packet_sock对象，耗尽kmalloc-2048缓存；</li>
  <li>req→tp_block_size=0x8000，申请1024个长度为0x8000的块，消耗系统零散的0x8000页面；</li>
  <li>创建一个新的packet_sock对象，申请2个长度为0x8000的块与新的packet_sock关联，第二个块是将要溢出的漏洞对象；</li>
  <li>分配大量packet_sock对象，这些对象将填满步骤3中新的packet_sock对象所在的kmalloc-2048缓存，剩下的通过buddy system申请新的0x8000页面来存放，位置在漏洞对象之后。</li>
</ol>

<h2 id="七利用流程">七、利用流程</h2>

<p>要覆盖的内容：</p>

<ol>
  <li>packet_sock::xmit函数指针，通过该packet_sock对外发送数据包时，会调用该函数指针；</li>
  <li>packet_sock::rx_ring::prb_bdqc::retire_blk_timer::function和data，若发生了超时并且当前使用的块还未填满，则调用定时器函数把当前块交付给进程读取，目的是防止进程等待时间太久。调用方式为retire_blk_timer→function(data)。</li>
</ol>

<p>利用过程：</p>

<ol>
  <li>通过dmesg从开机的内核日志中提取内核代码段地址以绕过KASLR（ubuntu16.04存在这样的问题）；</li>
  <li>按照堆风水构造布局；</li>
  <li>关闭SMAP&amp;SMEP
    <ol>
      <li>在block后面分配packet_sock对象；</li>
      <li>设置packet_sock的定时器；</li>
      <li>溢出block覆盖packet_sock::rx_ring::prb_bdqc::retire_blk_timer::function和data，使得function指向内核函数native_write_cr4的地址，data内容为0x407f0；</li>
      <li>等待超时执行定时器函数，关闭SMEP和SMAP。</li>
    </ol>
  </li>
  <li>获取root权限：
    <ol>
      <li>在block后面分配packet_sock对象；</li>
      <li>溢出block覆盖packet_sock::xmit函数指针指向用户态布置的commit_creds(prepare_kernel_cred(0))函数调用；</li>
      <li>使用当前packet_sock发送数据包，执行xmit回调函数，触发提权操作。</li>
    </ol>
  </li>
</ol>

<h2 id="八漏洞修补">八、漏洞修补</h2>

<p>做如下对比还不够，因为BLK_PLUS_PRIV包含加法操作也会造成unsigned int类型溢出。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span><span class="n">po</span><span class="o">-&gt;</span><span class="n">tp_version</span> <span class="o">&gt;=</span> <span class="n">TPACKET_V3</span> <span class="o">&amp;&amp;</span>
	 <span class="n">req</span><span class="o">-&gt;</span><span class="n">tp_block_size</span> <span class="o">&lt;=</span> <span class="n">BLK_PLUS_PRIV</span><span class="p">(</span><span class="n">req_u</span><span class="o">-&gt;</span><span class="n">req3</span><span class="p">.</span><span class="n">tp_sizeof_priv</span><span class="p">))</span>
                         <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
                         
<span class="cp">#define BLK_PLUS_PRIV(sz_of_priv) \
         (BLK_HDR_LEN + ALIGN((sz_of_priv), V3_ALIGNMENT))
</span></code></pre></div></div>

<p>最终方法是把tp_sizeof_priv扩展为unsigned long类型。</p>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/6.png" alt="截屏2024-09-02 11.33.47.png" /></p>

<h2 id="九c语言整数计算剖析">九、C语言整数计算剖析</h2>

<h3 id="变量类型转换">变量类型转换</h3>

<p>自动类型转换：</p>

<ol>
  <li>赋值运算中，右值的类型转化成左值的类型并保存在左值中，该过程可能会导致精度降低、数据截断的问题</li>
  <li>多种类型数据混合运算中，所有数据将转换成精度最大的的数据类型，然后进行计算，例如char和int进行计算时，全部转化成int类型进行计算；若字节数不同，则转换成长度较长的数据类型若字节数相同，一个有符号一个无符号，则转换成无符号数据类型</li>
</ol>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/usual_arithmetic_conversion.png" alt="usual_arithmetic_conversion.png" /></p>

<p>强制类型转换：</p>

<p>主要涉及到运算优先级的问题，要判断强制类型转换作用在哪个表达式，其余的部分遵循自动类型转换规则。</p>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/7.png" alt="截屏2024-08-31 10.07.20.png" /></p>

<h3 id="整数计算过程">整数计算过程</h3>

<ol>
  <li>CPU内部处理的整数数值都是补码，编译器会将十进制整数转换成对应的补码，正整数的补码是原码，负整数的补码是符号位不变其余位取反再加1。</li>
  <li>编译器认为源代码中的十六进制数已经是补码形式了，不再进行补码处理。</li>
  <li>
    <p>signed和unsigned类型的区别是，汇编层面处理逻辑会有所不同具体表现在”判断-跳转“、符号位扩展等逻辑上，这部分是编译器根据代码上下文逻辑生成的。落实到CPU处理层面不区分正负，按照二进制运算法则计算，根据计算结果更新EFLAGS寄存器的CF、AF、PF、ZF、SF、OF标志位，汇编层面的jmp族指令根据ZF、CF、SF标志位的值组合逻辑进行跳转。</p>

    <p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/9.png" alt="b31a2232a0fdb51fa9f75f8402bc8e78.png" /></p>

    <ul>
      <li>CF：进位标志CF（Carry Flag），如果运算结果的最高位产生了一个进位或借位，其值为1，否则为0。</li>
      <li>PF：奇偶标志PF（Parity Flag），运算结果中“1”的个数的奇偶性，偶数个1，PF=1，反之为0。</li>
      <li>AF：辅助进位标志AF（Auxiliary Carry Flag），这个不太好理解，比如：EAX值为OxNNNNNNNN（红色地方有进位，AF就是1，不管使用的是：EAX、AX、AL）。</li>
      <li>ZF：零标志ZF（Zero Flag），它记录相关指令执行后，结果是否为0；若结果为0，ZF=1，反之ZF=0</li>
      <li>SF：符号标志SF（Sign Flag），正负标志位，它记录相关指令执行后，结果是否为负，如果结果为负，SF=1，反之SF=0。（说明一下：符号位是程序员确定的，如果是无符号数，就考虑SF位，如果是无符号数，就不考虑SF位，想让SF=1，就：MOV EAX,0×1然后SUB EAX,0x2）</li>
      <li>OF：溢出标志OF（Overflow Flag）：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。（MOV AL,0x7F, ADD AL,0×1）CF与OF的区别：
 进位标志CF表示无符号数运算结果是否超出范围；
 溢出标志OF表示有符号数运算结果是否超出范围。</li>
    </ul>
  </li>
  <li>强制类型转换由编译器根据代码上下文逻辑生成对应的汇编代码，涉及到数据类型长度的表现在寄存器长度的变换，涉及到signed和unsigned变换的表现在“判断-跳转”和符号位扩展逻辑上。</li>
</ol>

<p><img src="/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/10.png" alt="截屏2024-09-01 08.32.52.png" /></p>

<p><a href="https://docs.pingcode.com/ask/304517.html">两个无符号数做减法时，CF条件码如何置位</a></p>

<p>伙伴系统、slab系统、分配掩码：</p>

<p><a href="https://www.kernel.org/doc/gorman/html/understand/understand009.html">Physical Page Allocation</a></p>

<h2 id="十漏洞挖掘点">十、漏洞挖掘点</h2>

    </div>
</article>

                
                <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© qts588 2025</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="http://localhost:4000/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

                <script src="http://localhost:4000/assets/js/jquery.slim.min.js"></script>
<script src="http://localhost:4000/assets/js/lity.min.js"></script>
<script src="http://localhost:4000/assets/js/tools.js"></script>
<script src="http://localhost:4000/assets/js/pic.js"></script>
<script src="http://localhost:4000/assets/js/toc-highlight.js"></script>
            </main>
        </div>
    
</body>
</html>