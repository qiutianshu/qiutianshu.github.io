<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="http://localhost:4000/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="http://localhost:4000/assets/style.css"/>
<link rel="stylesheet" href="http://localhost:4000/assets/js/lity.min.css"/>



<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="极目楚天舒" />
<meta 
    property="og:title"
    content="
        
            CVE-2021-43267 tipc驱动任意代码执行
        
    " 
/>

<meta property="og:url" content="http://localhost:4000//linux_kernel/2023/12/21/CVE-2021-43267-tipc%E9%A9%B1%E5%8A%A8%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        CVE-2021-43267 tipc驱动任意代码执行
    
</title>
</head>
<body class="index">
    
        <div class="page-container">
            <aside class="main-sidebar">
                <!-- 包含 TOC -->
                <sidebar class="sidebar">
<ul class="toc-list"><li><a href="#〇漏洞信息">〇、漏洞信息</a></li><li><a href="#一漏洞发现过程">一、漏洞发现过程</a></li><li><a href="#二tipc协议简介">二、TIPC协议简介</a><ul><li><a href="#1-运行方式">1. 运行方式</a></li><li><a href="#2-地址方案">2. 地址方案</a></li><li><a href="#3-命令行交互工具">3. 命令行交互工具</a></li><li><a href="#4-数据包格式">4. 数据包格式</a></li></ul></li><li><a href="#三漏洞分析利用思路">三、漏洞分析&amp;利用思路</a><ul><li><a href="#1-漏洞分析">1. 漏洞分析</a></li><li><a href="#2-反推输入点">2. 反推输入点</a></li><li><a href="#3-分析过滤条件">3. 分析过滤条件</a></li><li><a href="#4-利用思路">4. 利用思路</a></li><li><a href="#5-漏洞信息提炼">5. 漏洞信息提炼</a></li></ul></li><li><a href="#四如何到达漏洞位置">四、如何到达漏洞位置</a><ul><li><a href="#1-使能tipc节点">1. 使能tipc节点</a></li><li><a href="#2-伪造握手过程">2. 伪造握手过程</a></li></ul></li><li><a href="#五漏洞利用步骤">五、漏洞利用步骤</a><ul><li><a href="#1-msg_msg越界读取tty_struct结构绕过kaslr">1. msg_msg越界读取tty_struct结构绕过KASLR</a></li><li><a href="#2-泄漏堆地址">2. 泄漏堆地址</a></li><li><a href="#3-喷射fake_operations结构">3. 喷射fake_operations结构</a></li><li><a href="#4-篡改tty_struct-tty_operation指针">4. 篡改tty_struct-&gt;tty_operation指针</a></li><li><a href="#5-任意地址写">5. 任意地址写</a></li><li><a href="#6-触发modprobe_path">6. 触发modprobe_path</a></li></ul></li><li><a href="#六提权木马原理">六、提权木马原理</a><ul><li><a href="#1-elf文件结构">1. ELF文件结构</a></li><li><a href="#2-sh的设计">2. sh的设计</a></li><li><a href="#3-hax程序的设计">3. hax程序的设计</a></li></ul></li><li><a href="#七堆喷注意事项">七、堆喷注意事项</a><ul><li><a href="#1-检查堆分配机制">1. 检查堆分配机制</a></li><li><a href="#2-slub-freelist-random">2. SLUB freelist random</a></li></ul></li><li><a href="#八知识总结">八、知识总结</a></li><li><a href="#九参考文章">九、参考文章</a></li></ul></sidebar>
            </aside>
            <!-- 主内容区域 -->
            <main class="main-content">
                <header class="header">
    <section class="logo">
        <a href="http://localhost:4000/" class="logo__link">
            
                <h1>极目楚天舒</h1>
            
        </a>
    </section>
    
    <button id="menuToggle">
        <div></div>
        <div></div>
        <div></div>
    </button>
    <nav class="menu">
        
<ul class="list primary">

    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/linux_kernel.html">
                
                    <img src="http://localhost:4000/assets/img/icons/tux.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Linux kernel</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/linux_userspace.html">
                
                    <img src="http://localhost:4000/assets/img/icons/userspace.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Linux userspace</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/hardware.html">
                
                    <img src="http://localhost:4000/assets/img/icons/chip.svg"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Hardware</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/meltdown_spectre.html">
                
                    <img src="http://localhost:4000/assets/img/icons/meltdown_spectre.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Side Channel</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/riscv.html">
                
                    <img src="http://localhost:4000/assets/img/icons/riscv.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Riscv</p>
                
                </a>

            
            </div>
            
        </li>   
    
</ul>
    </nav>
</header>
                
                <article class="post">

    <div class="post__title">
       CVE-2021-43267 tipc驱动任意代码执行
    </div>
    <div class="post__meta"> 
        <div class="post__meta__category">
            
                <p class="post__meta__category__title" style="background: var(--c-themeHueBlue)">Linux内核漏洞</p>
            
        </div>
        <p class="post__meta__divider">·</p>
        <div class="post__meta__date">
            2023-12-21
        </div>
        
    </div>

    
    <div class="post__content">
        <p>CVE-2021-43267 是一个潜伏于 Linux 内核 TIPC（透明进程间通信）协议簇中的高危漏洞。该漏洞源于其对恶意构建的 MSG_CRYPTO 消息类型处理不当，存在堆缓冲区溢出漏洞。由于 TIPC 模块通常以高权限运行，本地攻击者无需特殊权限即可利用此漏洞，实现内核权限提升或导致系统拒绝服务，危害性极大。</p>

<h2 id="〇漏洞信息">〇、漏洞信息</h2>

<ul>
  <li>安全防护：
开启了KASLR、SMEP、SMAP
CONFIG_STATIC_USERMODEHELPER=n
CONFIG_SLAB_FREELIST_RANDOM=y
CONFIG_SLAB_FREELIST_HARDENED=y</li>
  <li>堆分配器：SLUB分配器</li>
  <li>漏洞能力
溢出对象为kamlloc分配的堆块（通用堆块）
堆块大小[24,66000]字节（可以使用msg_msg进行堆喷布局）
溢出长度为任意大小（msg_msg+tty_struct越界读、msg_msg任意地址读写）</li>
</ul>

<h2 id="一漏洞发现过程">一、漏洞发现过程</h2>

<p>2021年11月4日，SentinelLabs的研究人员使用CodeQL搜索Linux内核代码中的kmalloc函数调用[1]，CodeQL语句如下：</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled.png" alt="Untitled" /></p>

<p>上述语句的作用是搜索所有kmalloc调用，如果传递给kmalloc的实参类型的大小为2字节，也就是short或者unsigned short，那么就返回搜索结果。
在返回的60多个结果中如下代码片段引起了研究人员的注意：</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%201.png" alt="Untitled" /></p>

<p>这段代码用于处理接收到的数据包。
在(1)处根据hdr中提取的size信息分配了一个堆块。
在(2)(3)处根据data中的size信息，将数据复制到堆块中。
这里存在两个潜在的问题：
在(3)的位置复制数据没有对长度进行检验。
(1)和(2)处的size来源不同，数据包头部的size字段可能与数据部分的size字段不一致。
猜测这是一个堆溢出漏洞。</p>

<h2 id="二tipc协议简介">二、TIPC协议简介</h2>

<p>TIPC（Transparent Inter-Process Communication）协议是一种高性能的进程间通信（IPC）协议，主要用于集群环境中的通信。它为实现低延迟、高可靠性的通信提供了基础设施。TIPC起初由Erlang Blomsrut和Jon Maloy为爱立信开发，后成为开源项目，并集成在Linux内核中。
TIPC的优势包括位置透明性、无需配置的自主路由、高性能与低延迟、多种通信模式以及可靠性与容错。它适用于电信、工业自动化、分布式计算、云计算、物联网（IoT）、嵌入式系统和实时操作系统等领域。
Linux内核版本：5.14-15
实验平台：Ubuntu20.04.1</p>

<h3 id="1-运行方式">1. 运行方式</h3>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%202.png" alt="Untitled" /></p>

<p>TIPC协议横跨传输层、网络层和链路层[2]，向上提供进程间的通信。
TIPC使用以下的传输协议作为载体：</p>

<ul>
  <li>以太网协议（链路层）</li>
  <li>InfiniBand（链路层）</li>
  <li>UDP协议（传输层）</li>
</ul>

<p>TIPC可以配置为在Ethernet或UDP协议之上运行。但是低权限的用户是无法创建Ethernet帧，因此使用UDP更容易实现本地漏洞利用。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%203.png" alt="Untitled" /></p>

<p>在TIPC协议中，节点之间通过创建套接字进行通信。通信双方可以直接使用TIPC独特的地址类型（如服务地址或端口身份）进行通信，而不必关心底层网络的细节。
虽然TIPC是在这些协议之上运行的，但有独立的地址方案，节点可以选择自己的地址。TIPC协议以对用户透明的方式工作。所有的消息构造和分析都是在kernel中进行的。每个TIPC消息都有相同的通用header格式和消息特定的header。</p>

<h3 id="2-地址方案">2. 地址方案</h3>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%204.png" alt="Untitled" /></p>

<ul>
  <li>Zone：系统管理员可以创建一个独特标识的Zone来很方便的将很多个node划分为一组</li>
  <li>Cluster：Zone的再划分，Cluster的标识必须为范围[1,4095]的数字</li>
  <li>Node：一个Cluster包含多个node，node的标识也必须为范围[1,4095]的数字，node可以通过TIPC网络进行通信</li>
  <li>Link：node之间的通信通道被称为link，就是图中的箭头，link可以正确有序的在node之间传输数据单元</li>
  <li>Message：TIPC中用于交换数据的基本单元，图中箭头所载的信息</li>
</ul>

<h3 id="3-命令行交互工具">3. 命令行交互工具</h3>

<p>在Ubuntu中需要用户手动加载tipc驱动：sudo modprobe tipc
配置底层传输介质为UDP并绑定本地ip：sudo tipc bearer enable media udp name <your name=""> localip <ip></ip></your></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%205.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%206.png" alt="Untitled" /></p>

<p>在两台Ubuntu虚拟机上分别作如上配置，可以看到相互都发现了对方的node，并且已经建立了连接。</p>

<h3 id="4-数据包格式">4. 数据包格式</h3>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%207.png" alt="Untitled" /></p>

<p>可以看到数据包头部大小为40字节，消息的大小为44字节。
节点的寻址方面，最底层是以太网层和UDP层，TIPC协议层采用<Zone.Cluster.Node>编址，将32位ip地址划分为:</Zone.Cluster.Node></p>

<ul>
  <li>Zone[0,7]</li>
  <li>Cluster[8,19]</li>
  <li>Node[20,31]</li>
</ul>

<p>User字段和Message Type字段决定了当前数据包的类型，决定了数据包走哪一条处理路径。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%208.png" alt="Untitled" /></p>

<p>Linux内核将TIPC数据包头部定义为15个32位大端数组，我们需要关注以下字段：</p>

<ul>
  <li>User字段，用于识别消息类型，与Mtype字段一起使用</li>
  <li>Hsize字段，消息头部大小</li>
  <li>Message Size字段，消息的总长度，包括消息头部</li>
  <li>Mtype字段，与User字段一起使用</li>
</ul>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%209.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2010.png" alt="Untitled" /></p>

<h2 id="三漏洞分析利用思路">三、漏洞分析&amp;利用思路</h2>

<h3 id="1-漏洞分析">1. 漏洞分析</h3>

<p>2020年9月引入了一个新的用户消息类型—— MSG_CRYPTO，该消息类型允许节点发送加密的密钥消息头对应的User字段为MSG_CRYPTO。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2011.png" alt="Untitled" /></p>

<p>tipc_aead_key结构包含一个32字节长度的字符数组，8字节的keylen字段表示key[]的长度，以及一个变长数组key[]用于保存密钥。
数据结构保存在TIPC消息的数据字段。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2012.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2013.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2014.png" alt="Untitled" /></p>

<p>msg_data_sz根据TIPC头部计算出TIPC载荷的长度，根据这个长度，后面kmalloc分配堆块。
data指向载荷，skey-&gt;keylen从TIPC载荷中读取key的长度。
攻击者可以控制tipc_aead_key-&gt;keylen使之大于TIPC头部计算的长度，在memcpy中造成堆溢出。
在memcpy之后才对长度进行检验，此时已经晚了。</p>

<h3 id="2-反推输入点">2. 反推输入点</h3>

<p>内核从tipc_udp_recv接收来自用户的数据包，在tipc_rcv中调用tipc_msg_validate对数据包头部的Hsize和Msize进行检验，
在tipc_link_rcv中根据User字段把数据包路由到不同的函数进行处理。
若满足User=MSG_CRYPTO(14)且Message type=KEY_DISTR_MSG(0)，数据包被路由至tipc_crypto_key_rcv</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2015.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2016.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2017.png" alt="Untitled" /></p>

<h3 id="3-分析过滤条件">3. 分析过滤条件</h3>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2018.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2019.png" alt="Untitled" /></p>

<p>在对数据包进行检验的时候，仅检查了Hsize和Message size。所以攻击者可以在保证Hsize和Message size关系正确的情况下构造任意大小的keylen字段。满足skb-&gt;len &gt;= msz意味着tipc数据包的实际长度可以大于Message size。</p>

<h3 id="4-利用思路">4. 利用思路</h3>

<p>MSG_CRYPTO消息的堆块内存分配的size来自tipc_msg-&gt;msz - tipc_msg-&gt;hsz，MSG_CRYPTO消息的拷贝的size来自tipc_aead_key-&gt;keylen。所以通过控制tipc_msg-&gt;msz即可控制目标堆块的分配大小，控制tipc_aead_key-&gt;keylen即可控制堆块的溢出长度。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2020.png" alt="Untitled" /></p>

<p>由于tipc数据包的实际长度可以大于Message size，可以在数据包超出Message size的部分附加额外的数据用于堆溢出，在memcpy过程中这部分数据可以用来覆盖相邻堆块上的数据结构，实现越界写。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2021.png" alt="Untitled" /></p>

<h3 id="5-漏洞信息提炼">5. 漏洞信息提炼</h3>

<p>综合上述分析可以提炼出如下漏洞信息：</p>

<ul>
  <li>安全防护：
开启了KASLR、SMEP、SMAP
CONFIG_STATIC_USERMODEHELPER=n
CONFIG_SLAB_FREELIST_RANDOM=y
CONFIG_SLAB_FREELIST_HARDENED=y</li>
  <li>堆分配器：SLUB分配器</li>
  <li>漏洞能力
溢出对象为kamlloc分配的堆块（通用堆块）
堆块大小[24,66000]字节（可以使用msg_msg进行堆喷布局）
溢出长度为任意大小（msg_msg+tty_struct越界读、msg_msg任意地址读写）</li>
</ul>

<h2 id="四如何到达漏洞位置">四、如何到达漏洞位置</h2>

<p>TIPC是网络协议，我们既可以从远程打，也可以从本地进行提权，为了便于演示漏洞利用过程，选择从本地进行提权。</p>

<ul>
  <li>首先需要使能本地TIPC节点</li>
</ul>

<p>根据TIPC官方文档[4]，可以使用发行版操作系统自带的tipc命令进行配置.但是考虑到目标系统的多样性，最好使用内核提供的接口对tipc进行配置。</p>

<ul>
  <li>然后需要初始化协议状态机</li>
</ul>

<p>数据包要能够到达漏洞位置，必须经过一系列握手步骤。如果是正常的网络环境，两台主机都分别使能本地tipc节点，在自动发现协议的作用下会自动握手并建立连接。但在本地环境攻击者需要向内核发送特定的数据包伪造握手过程，使得tipc协议状态机满足收发数据的条件。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2022.png" alt="Untitled" /></p>

<h3 id="1-使能tipc节点">1. 使能tipc节点</h3>

<h3 id="2-伪造握手过程">2. 伪造握手过程</h3>

<h2 id="五漏洞利用步骤">五、漏洞利用步骤</h2>

<h3 id="1-msg_msg越界读取tty_struct结构绕过kaslr">1. msg_msg越界读取tty_struct结构绕过KASLR</h3>

<p>使用经典的msg_msg+tty_struct方法来泄漏内核代码段地址和堆地址[6]。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2023.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2024.png" alt="Untitled" /></p>

<p>通过堆喷射在tipc_aead_key的周围布置大量的msg_msg消息和tty_struct结构。堆溢出使得msg_msg的m_ts字段被覆盖成攻击者选定的任意大小。再使用msgrcv()对消息进行读取，造成越界读，泄漏相邻tty_struct结构的tty_operations结构指针。</p>

<p>需要注意覆写msg_msg-&gt;m_ts的同时也会覆盖msg_msg-&gt;m_list，直接调用msgrcv会将匹配的消息从链表中unlink，如果不正确构造msg_msg-&gt;m_list就会导致访问崩溃。解决办法是在调用msgrcv时传递MSG_COPY flag，这样内核就只复制msg_msg的内容而避免进行unlink。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2025.png" alt="Untitled" /></p>

<p>当我们执行open(“/dev/ptmx”,flag)打开一个伪终端设备 ptmx时，内核函数alloc_tty_struct调用kzalloc分配tty_struct结构。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2026.png" alt="Untitled" /></p>

<p>sizeof(struct tty_struct)=0x2e0，分配到的堆块大小为kmalloc-1k。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2027.png" alt="Untitled" /></p>

<p>tty_struct-&gt;ops指向的tty_operations结构是一个函数指针集合。
alloc_tty_struct()分配tty_struct的内存空间之后会将tty_struct-&gt;ops指向内核全局变量ptm_unix98_ops或pty_unix98_ops。
因此我们可以通过越界读取tty_struct-&gt;ops指针来泄露内核全局变量地址。
在调试阶段我们可以开root从/proc/kallsyms中读取两个全局变量的地址，根据16进制后三位可以判断出泄漏的地址属于二者之中的哪一个。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2028.png" alt="Untitled" /></p>

<p>先在堆上喷满msg_msg结构，释放msg_msg0，分配tipc_aead_key堆块占据msg_msg0的位置。从msg_msg2开始释放下标为偶数的堆块。打开大量ptmx分配tty_struct结构占据刚刚释放的堆块。
再利用tipc_aead_key的溢出来修改msg_msg1-&gt;m_ts，最后调用msgrcv越界读取tty_struct来泄露内核全局变量的指针。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2029.png" alt="Untitled" /></p>

<p>为了和tty_struct分配到同一个slub里面，申请的msg_msg消息大小为0x3d0，加上0x30的msg_msg消息头总长度为0x400。
触发越界写的tipc数据包如图所示：</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2030.png" alt="Untitled" /></p>

<p>为了使分配给tipc_aead_key的堆块大小为0x400，Message size在0x400的基础上加上头部固定的24字节。
在memcpy过程中，tipc_aead_key头部36字节固定用于存放keylen和alg_name数组，剩下的部分长度为0x400-32-4。
设置keylen=0x400-36+smashlen正好越界写smashlen个字节，写的内容就是smashdata部分。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2031.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2032.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2033.png" alt="Untitled" /></p>

<p>触发漏洞，tipc_aead_key邻近的msg_msg被覆盖。</p>

<h3 id="2-泄漏堆地址">2. 泄漏堆地址</h3>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2034.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2035.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2036.png" alt="Untitled" /></p>

<p>在初始化之时tty_struct.ldisc_sem.read_wait.next被设置为指向read_wait自身。next在tty_struct结构中的偏移为0x38，因此next-0x38即可得到tty_struct的地址，也即是泄漏的堆的地址。</p>

<h3 id="3-喷射fake_operations结构">3. 喷射fake_operations结构</h3>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2037.png" alt="Untitled" /></p>

<p>向堆上喷射攻击者构造的tty_operations结构，里面填充任意地址写gadget。这里仍然采用喷射大小为0x400的msg_msg堆块的方式，这样可以确保fake_operations分配在kmalloc-1k的slub上面。
泄漏的tty_struct地址 + 偏移量 即可得到fake_operations的地址，该地址后面用于替换正常的tty_struct-&gt;ops。偏移量可以通过多次尝试得到。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2038.png" alt="Untitled" /></p>

<h3 id="4-篡改tty_struct-tty_operation指针">4. 篡改tty_struct-&gt;tty_operation指针</h3>

<p>篡改tty_struct-&gt;tty_operation指针使之指向攻击者构造的fake_operations结构。
fake_operations填充能够实现任意地址写功能的gadget，
当调用ioctl时，内核调用gadget将字符串“/tmp/hax”覆盖内核全局变量modprobe_path。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2039.png" alt="Untitled" /></p>

<p>依次分配msg_msg消息堆块和tty_struct结构，使两个堆块紧邻；
调用msgrcv释放msg_msg堆块；
触发堆溢出，把fake_operations地址写入tty_struct-&gt;ops指针。
由于Slub分配器对空闲对象的分配实行后进先出，所以tipc_aead_key能够立即分配到刚刚释放的msg_msg堆块。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2040.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2041.png" alt="Untitled" /></p>

<h3 id="5-任意地址写">5. 任意地址写</h3>

<p>第二次触发越界写，相邻tty_struct-&gt;ops被覆盖成fake_operations地址。
fake_operations填充gadget地址。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2042.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2043.png" alt="Untitled" /></p>

<p>此时tty_struct-&gt;ops-&gt;.compact_ioctl指向任意地址写gadget：</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2044.png" alt="Untitled" /></p>

<p>调用ioctl最终将执行任意地址写gadget，此时rdx保存ioctl第三个参数modprobe_path的地址，rsi保存字符串“/tmp/hax”，实现将“/tmp/hax”写入modprobe_path地址。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2045.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2046.png" alt="Untitled" /></p>

<h3 id="6-触发modprobe_path">6. 触发modprobe_path</h3>

<p>漏洞利用初始化阶段向/tmp目录下写入一个任意格式的文件并赋予执行权限。
由于该文件不是ELF格式的文件，当试图运行该文件时，内核无法识别文件类型，内核起一个内核线程以root身份调用/sbin/modprobe加载一个能够解释该文件的内核模块。
“/sbin/modprobe”字符串保存在内核全局变量modprobe_path中。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2047.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2048.png" alt="Untitled" /></p>

<p>由于前面modprobe_path已经被覆盖成了“/tmp/hax”，所以此时内核以root的身份执行/tmp/hax。</p>

<h2 id="六提权木马原理">六、提权木马原理</h2>

<p>攻击者每次获取root权限都要执行一次exp，这会使系统非常不稳定从而使系统管理员产生警觉。我们可以在exp第一次获取root权限时就在系统里留下永久性root后门。
call usermodprobe_helper执行的/tmp/hax属于内核线程，他的ruid=0，euid=0。所以hax线程释放出的sh文件属于root。hax再设置sh的SUID位，则普通权限的用户运行sh时euid=0，就是一个root shell。
由于SUID程序的euid在fork的时候不能继承，因此永久后门先用setuid(0)将自己的ruid设为0，再execve出root shell。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2049.png" alt="Untitled" /></p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2050.png" alt="Untitled" /></p>

<p>在具体实现方面，将各个阶段的载荷层层嵌套，最终硬编码到EXP里面。EXP和hax分别将各自下一阶段的载荷通过open、write释放出来。这要求hax和后门程序的大小不能太大，否则不方便编码到漏洞利用代码里面。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2051.png" alt="Untitled" /></p>

<p>攻击者获取一个低权限shell后执行驻留后门便可以得到一个root shell。为使程序尽可能紧凑采取如下方法：</p>

<ol>
  <li>用nasm汇编语言编写，用ld去符号静态链接；</li>
  <li>避免单独的.data段，将静态数据用nop占位并放置在.text段末尾，这样可以避免因单独的.data段而填充的垃圾字节；</li>
  <li>用二进制编辑器删除非加载段；</li>
  <li>将代码段末尾的nop字节手工修改为字符串；</li>
  <li>用二进制编辑器修改程序入口地址、可加载段大小等信息，以及代码中的地址引用。</li>
</ol>

<h3 id="1-elf文件结构">1. ELF文件结构</h3>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2052.png" alt="Untitled" /></p>

<h3 id="2-sh的设计">2. sh的设计</h3>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2053.png" alt="Untitled" /></p>

<p>编译链接这段代码得到的可执行文件大小为4.4KB，至此完成了第1步和第2步。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2054.png" alt="Untitled" /></p>

<p>第3步用二进制编辑器删除elf文件中的非加载段。
通过readelf观察到文件偏移0x1030往后的都是非加载段，都可以删掉。非加载段这部分包括了.shstrtab和section header。
剩下有用部分是elf header、program header和.text段，这三个部分被划入到2个LOAD段作为实际运行时内存镜像。LOAD1段包含了elf header和program header，大小为sizeof(Elf64_Ehdr) + 2 * sizeof(Elf64_Phdr) = 0xb0，其中Elf64_Ehdr标记了程序入口点，每个Elf64_Phdr标记了一个LOAD段的加载信息。LOAD2段是.text段从文件偏移0x1000开始，大小为0x30。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2055.png" alt="Untitled" /></p>

<p>为了便于程序运行的加载，在程序链接时各个可加载段都是按照4KB对齐，所以每个LOAD段有大量填充字节，需要删掉这些填充字节，从0xb0开始到0x1000全部删掉，这样.text段就被提前到了0xb0的位置。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2056.png" alt="Untitled" /></p>

<p>再观察发现2个program header其实可以合并成一个，也就是将elf header、program header、.text段合并成一个LOAD段，这样就可以只用一个program header进一步压缩体积。
删掉Elf64_Phdr2，text段并入LOAD1，要修改Elf64_Phdr1的p_filesz和p_memsz字段。Elf64_Phdr1.p_filesz = 0xb0 - sizeof(Elf64_Phdr2) + sizeof(.text) = 0xB0-0x38+0x30 = 0xA8。由于.text段末尾的2个nop字节要扩展成“/bin/sh”字符串，所以最终Elf64_Phdr1.p_filesz = 0xA8 - 2 + sizeof(BinSh) = 0xAD。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2057.png" alt="Untitled" /></p>

<p>将.text段末尾两个nop指令修改为字符串“/bin/sh”后得到如上格式的文件：</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2058.png" alt="Untitled" /></p>

<p>第四步修改代码段中BinSh字符串的引用地址、Elf64_Ehdr结构。
BinSh的内存地址为0x40006A。修改e_entry为代码段起始地址0x400078。由于section header被删掉，所以相关的e_shoff、e_shnum、 e_shentsize、 e_shstrndx字段全部置为0。e_phnum为program header数量，置为1。
至此原本4.4KB的后门现在只剩下174字节。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2059.png" alt="Untitled" /></p>

<h3 id="3-hax程序的设计">3. hax程序的设计</h3>

<p>hax程序会释放永久后门sh，并且设置sh的权限为0755，设置sh的S位，nasm汇编如下：
编译后按照制作sh的方法同样也将hax裁剪压缩，并且将sh的字节码附加到.text段的末尾。
运行hax后可以看到sh文件被释放，并且设置了S位。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2060.png" alt="Untitled" /></p>

<p>再将hax文件的字节码提取出来贴到exp里面就可以通过exp来释放了。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2061.png" alt="Untitled" /></p>

<p>hax的字节码：</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2062.png" alt="Untitled" /></p>

<h2 id="七堆喷注意事项">七、堆喷注意事项</h2>

<h3 id="1-检查堆分配机制">1. 检查堆分配机制</h3>

<p>在进行堆喷射之前，要弄清楚内核用的是什么堆分配器，以及是否开启了堆防护措施。
Linux内核有三种内存分配机制，分别是slob、slab和slub，桌面端和服务端现在多使用slub分配器，这三种机制习惯上都称为slab。</p>

<p>slub机制下堆块分配向高地址增长</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2063.png" alt="Untitled" /></p>

<p>slab机制下堆块分配向低地址增长</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2064.png" alt="Untitled" /></p>

<p>堆分配机制的不同，直接影响堆喷射过程中的堆块布置。
查看本机内核编译配置文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /boot/config-<span class="si">$(</span><span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span>
</code></pre></div></div>

<p>可以看到本机使用的是slub分配器，且开启了freelist random和freelist hardened两种保护措施，现在的Linux发行版普遍开启了这两种堆保护机制。
本例子为调试方便关闭了这两个保护。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2065.png" alt="Untitled" /></p>

<p>在CTF竞赛中通常没有提供编译配置文件，那么我们也可以进到虚拟机里面查看/proc/slabinfo文件。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2066.png" alt="Untitled" /></p>

<p>看到limit和batchcount字段都是0，说明当前使用的是slub分配器。因为在slub分配中这两个字段没有对应的实现。
如果limit和batchcount不为0，说明当前使用的是slab分配器，这两个字段在slab中实现。</p>

<h3 id="2-slub-freelist-random">2. SLUB freelist random</h3>

<p>开启freelist random保护，可以看到堆块的分配并没有按顺序向高地址增长，每次分配到的地址都是随机的。
但是堆块的释放和分配还是按照“后进先出”（LIFO）的顺序不变，这一点很重要。</p>

<p><img src="/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2067.png" alt="Untitled" /></p>

<h2 id="八知识总结">八、知识总结</h2>

<p>Q：本例漏洞分析思路是什么？
A：1.从漏洞位置出发，反向查找找到用户的输入点；2.在漏洞点之前寻找过滤点，判断是否对漏洞利用条件进行了限制或者是过滤。在本例子中就是找到tipc_msg_validate函数并查看是否对Hsize、Msize和keylen进行关联或者限制，很显然漏过了对keylen的检验；3.构造路径满足状态机的需要，使能够到达漏洞点。</p>

<p>Q：本例开发exploit的思路是什么？
A：1.分析系统存在哪些保护，不然就会出现忙活大半天，发现路被封死了的情况;2.仔细找出漏洞的属性，比如对于堆溢出漏洞，我们要搞清楚堆块分配在哪个缓存上、溢出的堆块大小是否可控、能够溢出多少字节；3.在前面两步分析的基础上，结合我们自己的经验选择合适的漏洞利用方法。</p>

<p>Q：为什么要弄清楚堆块分配机制？
A：内核可能采用slub分配器或者slab分配器，这两者的分配机制是不同的。结合源代码和试验结果看，在关闭freelist random的条件下，slub按照低地址向高地址分配对象，slab按照高地址向低地址分配对象。对于空闲对象的管理，两者使用的都是后进先出(LIFO)分配方式。所以对于不同的分配机制，需要调整堆喷的策略。</p>

<p>Q：如何确定tipc建立连接的过程？
A：使用wireshark对正常的握手过程进行抓包，分析出两个节点建立连接的过程。对一个陌生的协议使用wireshark分析是必要的。</p>

<h2 id="九参考文章">九、参考文章</h2>

<p>[1] <a href="https://www.sentinelone.com/labs/tipc-remote-linux-kernel-heap-overflow-allows-arbitrary-code-execution/">CVE-2021-43267: Remote Linux Kernel Heap Overflow TIPC Module Allows Arbitrary Code Execution</a></p>

<p>[2] <a href="https://blog.csdn.net/silent123go/article/details/78812981">Linux Netlink基本使用</a></p>

<p>[3] <a href="https://syst3mfailure.io/wall-of-perdition/">[corCTF 2021]Wall Of Perdition: Utilizing msg_msg Objects For Arbitrary Read And Arbitrary   Write In The Linux Kernel</a></p>

    </div>
</article>

                
                <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© qts588 2025</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="http://localhost:4000/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

                <script src="http://localhost:4000/assets/js/jquery.slim.min.js"></script>
<script src="http://localhost:4000/assets/js/lity.min.js"></script>
<script src="http://localhost:4000/assets/js/tools.js"></script>
<script src="http://localhost:4000/assets/js/pic.js"></script>
<script src="http://localhost:4000/assets/js/toc-highlight.js"></script>
            </main>
        </div>
    
</body>
</html>