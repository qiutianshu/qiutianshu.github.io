---
layout: post
title:  "蓝牙sco条件竞争漏洞挖掘与分析"
date:   2025-01-18 13:27:38 +0800
category: linux_kernel
---

2023年使用syzkaller对Linux内核进行fuzz的过程中，发现了蓝牙协议栈sco子协议的条件竞争漏洞，2024年11月8日，在审计Linux内核网络协议栈中锁的使用的过程中，通过相似性分析的方法，再次发现了一个sco的条件竞争漏洞。

## 一、环境搭建

发行版本Ubuntu24.04，内核版本Linux 6.11.5，打开KASAN、DEBUG_INFO、BT选项编译

![截屏2024-11-22 10.01.31.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/1.png)

需要注意的是，vmware fusion 13.6往后的版本不支持蓝牙，所以我把版本降低到vmware fusion 13.5.2，该版本是唯一免费的个人使用版本。

USB兼容性设置为2.0，共享主机蓝牙，这样Ubuntu里面可以识别到主机蓝牙。

![截屏2024-11-11 11.12.04.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/2.png)

对于Linux 5.17开始的内核会出现hciconfig hci0 up命令失败的情况，原因是Linux蓝牙驱动和虚拟机连接的主机蓝牙芯片不匹配。

![WechatIMG427.jpg](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/WechatIMG427.jpg)

根本原因在于hci_cc_func函数中新加入了对数据包长度的校验。

若事件是HCI_OP_DELETE_STORED_LINK_KEY，那么通过查表得cc→min_len = 3，而skb→len = 2

此处校验就过不去。

![截屏2024-11-11 11.18.07.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/3.png)

解决的方法是，在函数hci_cmd_complete_evt函数中判断

如果是HCI_OP_DELETE_STORED_LINK_KEY操作，那么直接返回*status=0，并在前面做必要的处理，这样就绕过了hci_cc_func函数。

![截屏2024-11-11 11.19.49.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/4.png)

## 二、发现过程

### 1. 条件假设

我在net目录中查找对内核套接字struct sock对象的未上锁访问时发现了这个bug。

我认为struct sock是在多个线程之间共享的。访问struct sock对象，特别是读写sk->sk_state，应提前调用lock_sock进行上锁，并在最后一次访问struct sock对象后调用release_sock进行解锁以防止线程之间的竞争。

现实依据是，我观察了多个网络协议的实现均是用这种方式保护struct sock的并发访问，例如tipc、can、蓝牙hci协议、packet、虚拟机套接字vmw_vsock等协议的实现。

CVE-2023-32606、CVE-2021-3609、CVE-2021-26708、CVE-2016-8655都是在读写struct sock对象的时候没有进行加锁保护导致的条件竞争。

其原理简单粗暴，以tipc协议的连接操作为例，使用lock_sock从一开始就把struct sock对象的操作保护起来，防止多线程并发访问的不同步导致状态机紊乱。

![截屏2024-11-22 10.15.03.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/5.png)

### 2. 漏洞原理

条件竞争漏洞发生在sco_sock_connect函数中，该函数被lock_sock分割为3个临界区。

一开始判断全局对象sk的状态这部分逻辑没有进行上锁保护，这一点很可疑。

![截屏2024-11-22 10.43.48.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/6.png)

![截屏2024-11-22 10.46.22.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/7.png)

如果同时来了两个connect调用，都通过了sk对象状态检查，开始竞争第一个临界区的锁，线程1首先创建一个sco_conn对象，并且sco_pi(sk)→conn指向sco_conn。

线程2创建第二个sco_conn对象，再次设置sco_pi(sk)→conn指向sco_conn，如此一来线程1创建的sco_conn就被悬空，再无指针可以引用它。

![截屏2024-11-22 11.04.27.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/8.png)

对象关系：

![socket-timer-第 5 页.jpg](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/9.jpg)

悬空过程调用链条：sco_sock_connect -> sco_connect -> sco_chan_add -> __sco_chan_add

UAF触发过程：

![截屏2024-11-22 11.33.54.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/10.png)

![截屏2024-11-22 12.47.26.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/11.png)

### 3. 攻击效果

受影响版本：linux-6.3.0 ～ linux-6.11.5

攻击效果：控制流劫持、本地权限提升

## 三、漏洞历史

该漏洞最早出现在2022年5月13日之前，中间被短暂地修补，因第一次修补后性能问题进行了第二次修补，漏洞被重新引入。

随后进行的第三次和第四次修补遏制了条件竞争发生之后的UAF，其中第三次修补的是另一个条件竞争漏洞与这次发现的关系不大，第四次修补遏制了UAF但是却没有解决条件竞争引发的sco_conn对象悬空问题。

第五次修补解决了悬空sco_conn对象的释放，解决了内存泄漏的问题。

### 2024年11月15日

这是最新的一次提交，在struct sco_conn对象内部嵌入了内核对象计数器kref用于跟踪sco_conn对象的生命周期，及时释放掉不再被引用的对象。

[https://github.com/torvalds/linux/commit/e6720779ae612a14ac4ba7fe4fd5b27d900d932c](https://github.com/torvalds/linux/commit/e6720779ae612a14ac4ba7fe4fd5b27d900d932c)

![截屏2024-11-22 13.16.10.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/12.png)

嵌入kerf对象：

![截屏2024-11-23 10.13.16.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/13.png)

悬空sco_conn被释放的逻辑：

![截屏2024-11-23 10.05.05.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/14.png)

![截屏2024-11-23 10.17.00.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/15.png)

### 2024年10月23日

该提交解决了在sco_sock_connect发生条件竞争的情况下，阻止后续UAF的产生。

[https://github.com/torvalds/linux/commit/1bf4470a3939c678fb822073e9ea77a0560bc6bb](https://github.com/torvalds/linux/commit/1bf4470a3939c678fb822073e9ea77a0560bc6bb)

![截屏2024-11-22 13.19.32.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/16.png)

方法是在异步线程中，访问sock对象之前检查sock对象是否还在sco_sk_list链表中，因为在close的时候sock对象会被从sco_sk_list移除。

但它并没有解决悬空sco_conn对象的问题，这又会产生内存泄漏的问题，因为没有任何指针可以引用到sco_conn对象。

### 2024年5月4日

该提交解决了一个sco_sock_timeout函数中的UAF漏洞，并申请了漏洞编号CVE-2024-27398。

[https://github.com/torvalds/linux/commit/483bc08181827fc475643272ffb69c533007e546](https://github.com/torvalds/linux/commit/483bc08181827fc475643272ffb69c533007e546)

![截屏2024-11-22 13.15.37.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/17.png)

该漏洞产生于close系统调用和定时器函数sco_sock_timeout之间的竞争，并不是本次发现的sco_sock_connect之间的条件竞争。

### 2023年4月11日

该提交目的是为了修补一个潜在的死锁：

[https://github.com/torvalds/linux/commit/9a8ec9e8ebb5a7c0cfbce2d6b4a6b67b2b78e8f3](https://github.com/torvalds/linux/commit/9a8ec9e8ebb5a7c0cfbce2d6b4a6b67b2b78e8f3)

2022年5月份的修补使用lock_sock()全程保护sco_sock_connect在某些情况下会造成死锁，新的提交对sco_sock_connect分成3段分别加锁，企图通过尽可能缩小lock_sock()的作用范围来避免死锁。

本次发现的漏洞也产生于这个提交。

但这又使得sock对象状态机的判断逻辑脱离了lock_sock()的保护，重新引入了条件竞争漏洞，被修补好的漏洞又出现了。

### 2022年5月13日

该漏洞早在2022年5月13日已经得到了修补：

[https://github.com/torvalds/linux/commit/7aa1e7d15f8a5b65f67bacb100d8fc033b21efa2](https://github.com/torvalds/linux/commit/7aa1e7d15f8a5b65f67bacb100d8fc033b21efa2)

当时有研究人员使用syzkaller打出了这个内核崩溃，同样也是两个并发的connect之后产生了一个悬空的sco_conn对象，close掉文件句柄之后在定时器函数sco_sock_timeout中触发了UAF。

![截屏2024-11-22 10.48.47.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/18.png)

该修补使用lock_sock()完整的保护了sco_sock_connect函数中整个连接过程，将sock对象状态机的判断和修改完整的置于锁保护之中，消除了sco_sock_connect函数的并发访问，从根源上避免了sco_conn悬空对象的产生。但由此产生了一些性能的问题，进而有了2023年4月份的修补。

我使用syzkaller在2023年1月份也打出了这个漏洞，当时和王宇轩等人进行过分析，开发出了漏洞利用代码。

## 四、时间线

2024年11月8日，发现漏洞；

2024年11月13日，写出PoC；

2024年11月14日，向security@kernel.org 和 linux-distros@vs.openwall.org 发送漏洞报告；

2024年11月15日，补丁被打上，提交编号为[e672077](https://github.com/torvalds/linux/commit/e6720779ae612a14ac4ba7fe4fd5b27d900d932c)；

## 五、漏洞验证

[https://github.com/qiutianshu/sco-race-condition](https://github.com/qiutianshu/sco-race-condition)

![截屏2024-11-23 10.34.30.png](/assets/posts/2025-01-18-蓝牙sco驱动条件竞争漏洞挖掘/19.png)