---
layout: post
title:  "cve-2017-7308 AF_PACKET环形缓冲区整数溢出漏洞分析"
date:   2024-09-24 13:27:38 +0800
category: linux_kernel
---
在packet_set_ring()函数中，通过精心构造的 tp_block_size 和 tp_block_nr 参数，触发一个32位整数乘法计算的溢出，从而绕过内核的安全检查，分配一个远小于预期尺寸的缓冲区，造成“大请求，小分配”的不一致，实现内核堆内存的越界读写，并最终完成本地权限提升。

## 一、环境搭建

实验环境：Ubuntu16.04 内核版本Linux4.8.0双机调试环境

我们需要手工升级Ubuntu16.04的内核到4.8版本以满足漏洞调试的条件。

安装内核编译环境：

```bash
sudo apt install build-essential ncurses-dev xz-utils libssl-dev bc libelf-dev flex bison
```

下载解压Linux4.8源码，进入源码目录，从/boot目录拷贝本机编译配置文件到源码目录下，重新命名为.config文件：

```bash
/linux-4.8$ cp /boot/config-$(uname -r) .config
```

对.config文件进行如下配置以使能AF_PACKET套接字功能和user命名空间：

```bash
CONFIG_USER_NS=y
CONFIG_PACKET=y
```

编译并安装内核：

```bash
/linux-4.8$ make menuconfig
/linux-4.8$ make -j8
/linux-4.8$ sudo make modules_install
/linux-4.8$ sudo make install
```

配置/etc/default/grub文件：

![截屏2024-08-29 19.16.10.png](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/1.png)

更新grub启动选项，重启虚拟机：

```bash
/linux-4.8$ sudo update-grub
/linux-4.8$ sudo reboot
```

## 二、AF_PACKET套接字原理

AF_PACKET套接字向用户态提供了直接向网卡驱动发送/接收数据包的接口，该套接字工作在OSI模型的第二层，与驱动层交换原始数据包，所以需要进程在当前用户命名空间中拥有CAP_NET_RAW权限。

![截屏2024-08-30 22.05.01.png](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/2.png)

进程创建AF_PACKET套接字会在内核态创建struct packet_sock对象。进程通过setsockopt系统调用，在内核态创建并配置rx_ring、tx_ring。接收/发送环形队列通过mmap系统调用映射到进程地址空间，可以直接读写mmap内存区域实现原始数据包的收发。

创建AF_PACKET套接字之后，protocol参数指定的链路层协议流量都会镜像一份发送给AF_PACKET套接字，所以可以实现对特定类型流量的监控。

```c
 packet_socket = socket(AF_PACKET, int socket_type, int protocol);
```

![cve-2017-7308.jpg](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/cve-2017-7308.jpg)

## 三、漏洞发现过程

Project Zero团队使用syzkaller对AF_PACKET类型套接字进行fuzz时测出了内核崩溃。

```c
"enable_syscalls": [
  "socket$packet", "socketpair$packet", "accept$packet", "accept4$packet", 
  "bind$packet", "connect$packet", "sendto$packet", "recvfrom$packet", 
  "getsockname$packet", "getpeername$packet", "listen", "setsockopt", 
  "getsockopt", "syz_emit_ethernet"
 ],
```

syzkaller捕捉到了引发内核崩溃的测试用例：

```c
mmap(&(0x7f0000000000/0xc8f000)=nil, (0xc8f000), 0x3, 0x32, 0xffffffffffffffff, 0x0)
r0 = socket$packet(0x11, 0x3, 0x300)
setsockopt$packet_int(r0, 0x107, 0xa, &(0x7f000061f000)=0x2, 0x4)
setsockopt$packet_rx_ring(r0, 0x107, 0x5, &(0x7f0000c8b000)=@req3={0x10000, 0x3, 0x10000, 0x3, 0x4, 0xfffffffffffffffe, 0x5}, 0x1c)
```

## 四、漏洞原理

该漏洞是无符号整数溢出漏洞。整数溢出在CPU的世界里是允许存在的，但是如果在代码逻辑上存在问题例如不合适的变量类型转换，整数溢出就会变成代码漏洞。

```c
/* linux-4.8\net\packet\af_packet.c:packet_set_ring */

if (po->tp_version >= TPACKET_V3 &&
		    (int)(req->tp_block_size - 
						BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)
			goto out;

#define BLK_PLUS_PRIV(sz_of_priv) \
	(BLK_HDR_LEN + ALIGN((sz_of_priv), V3_ALIGNMENT))
```

packet_set_ring函数对配置环形缓冲区的参数进行校验，其中：

| 变量 | 类型 | 用途 | 来源 |
| --- | --- | --- | --- |
| req→tp_block_size | unsigned int | 设置环形缓冲区每个块的长度 | 攻击者通过setsockopt传入 |
| req_u->req3.tp_sizeof_priv | unsigned int | 设置环形缓冲区每个块中私有区域的长度 | 攻击者通过setsockopt传入 |

![cve-2017-7308-第 2 页.jpg](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/3.jpg)

环形缓冲区由多个块组成，每个块都是由块描述符、私有区域、数据包存放区域组成。上述判断的逻辑是 块的长度-(块描述符+私有区域长度)是否大于0，目的是确保能够容纳数据包。

若通过setsockopt传递如下数据：

A = req->tp_block_size = 4096 = 0x1000

B = req_u->req3.tp_sizeof_priv = (1 << 31) + 4096 = 0x80001000

BLK_PLUS_PRIV(B) = (1 << 31) + 4096 + 48 = 0x80001030

A - BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv= 0x1000 - 0x80001030 = 0x7fffffd0

(int)0x7fffffd0 > 0

在无符号整数减法运算时，若被减数小于减数，通过借位使得运算结果为一个很大的数，同时CF标志位设为1，强制类型转化int后可能变成一个大的正整数。

### 数据结构关系

![cve-2017-7308-数据结构关系.jpg](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/4.jpg)

### 污点传播路径

![cve-2017-7308-污点传播路径.jpg](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/5.jpg)

1. init_prb_bdqc函数中p1指针指向的是struct tpacket_kbdq_core对象，其中p1→blk_sizeof_priv是unsigned short类型，截断了req3.tp_sizeof_priv的低2字节，攻击者可以完全控制p1→blk_sizeof_priv的值。
2. p1→blk_sizeof_priv在prb_open_block函数中用于计算数据包的起始写入位置，攻击者可以控制p1→blk_sizeof_priv使数据包写入位置在块的末尾，造成越界写。

## 五、可利用性分析

### 可达性分析

Q：使用哪些系统调用可以到达漏洞位置？

A：

```c
fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
setsockopt(fd, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
setsockopt(fd, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
```

Q：是否需要权限？

A：攻击者需要在当前user namespace中拥有CAP_NET_RAW权限才能调用上述系统调用。

Q：能否绕过权限的限制？

A：使用unshare系统调用创建并进入一个新的user namespace，在新的user namespace中创建一个新的net namespace即可拥有CAP_NET_RAW权限。

```c
unshare(CLONE_NEWUSER);  //创建并进入新的user namespace
unshare(CLONE_NEWNET);   //在新的user namespace中创建新的net namespace
write_file("/proc/self/setgroups", "deny");
write_file("/proc/self/uid_map", "0 1000 1\n", real_uid);//映射uid到父user namespace
write_file("/proc/self/gid_map", "0 1000 1\n", real_gid);//映射gid到父user namespace
```

### 漏洞具备的能力

1. 漏洞对象类型：环形缓冲区的数据块，存放字符类型的堆块，头部是struct tpacket_block_desc和私有数据区域。
2. 漏洞对象的大小：块的大小由用户态参数req→tp_block_size控制。
3. 漏洞对象位置：buddy system分配的连续的物理内存页面。
4. 溢出字节数：取决于数据包长度，攻击者可控。
5. 溢出内容：攻击者通过构造数据包控制溢出内容，攻击者可控。
6. 可以多次触发

## 六、堆风水

victim 对象：struct packet_sock，位于kmalloc-2048缓存中。当kmalloc-2048缓存消耗殆尽，slub分配器向buddy system请求0x8000大小的连续页面产生新的kmalloc-2048缓存。

![ak04.png](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/ak04.png)

思路：

1. 创建512个packet_sock对象，耗尽kmalloc-2048缓存；
2. req→tp_block_size=0x8000，申请1024个长度为0x8000的块，消耗系统零散的0x8000页面；
3. 创建一个新的packet_sock对象，申请2个长度为0x8000的块与新的packet_sock关联，第二个块是将要溢出的漏洞对象；
4. 分配大量packet_sock对象，这些对象将填满步骤3中新的packet_sock对象所在的kmalloc-2048缓存，剩下的通过buddy system申请新的0x8000页面来存放，位置在漏洞对象之后。

## 七、利用流程

要覆盖的内容：

1. packet_sock::xmit函数指针，通过该packet_sock对外发送数据包时，会调用该函数指针；
2. packet_sock::rx_ring::prb_bdqc::retire_blk_timer::function和data，若发生了超时并且当前使用的块还未填满，则调用定时器函数把当前块交付给进程读取，目的是防止进程等待时间太久。调用方式为retire_blk_timer→function(data)。

利用过程：

1. 通过dmesg从开机的内核日志中提取内核代码段地址以绕过KASLR（ubuntu16.04存在这样的问题）；
2. 按照堆风水构造布局；
3. 关闭SMAP&SMEP
    1. 在block后面分配packet_sock对象；
    2. 设置packet_sock的定时器；
    3. 溢出block覆盖packet_sock::rx_ring::prb_bdqc::retire_blk_timer::function和data，使得function指向内核函数native_write_cr4的地址，data内容为0x407f0；
    4. 等待超时执行定时器函数，关闭SMEP和SMAP。
4. 获取root权限：
    1. 在block后面分配packet_sock对象；
    2. 溢出block覆盖packet_sock::xmit函数指针指向用户态布置的commit_creds(prepare_kernel_cred(0))函数调用；
    3. 使用当前packet_sock发送数据包，执行xmit回调函数，触发提权操作。

## 八、漏洞修补

做如下对比还不够，因为BLK_PLUS_PRIV包含加法操作也会造成unsigned int类型溢出。

```c
 if (po->tp_version >= TPACKET_V3 &&
	 req->tp_block_size <= BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv))
                         goto out;
                         
#define BLK_PLUS_PRIV(sz_of_priv) \
         (BLK_HDR_LEN + ALIGN((sz_of_priv), V3_ALIGNMENT))
```

最终方法是把tp_sizeof_priv扩展为unsigned long类型。

![截屏2024-09-02 11.33.47.png](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/6.png)

## 九、C语言整数计算剖析

### 变量类型转换

自动类型转换：

1. 赋值运算中，右值的类型转化成左值的类型并保存在左值中，该过程可能会导致精度降低、数据截断的问题
2. 多种类型数据混合运算中，所有数据将转换成精度最大的的数据类型，然后进行计算，例如char和int进行计算时，全部转化成int类型进行计算；若字节数不同，则转换成长度较长的数据类型若字节数相同，一个有符号一个无符号，则转换成无符号数据类型

![usual_arithmetic_conversion.png](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/usual_arithmetic_conversion.png)

强制类型转换：

主要涉及到运算优先级的问题，要判断强制类型转换作用在哪个表达式，其余的部分遵循自动类型转换规则。

![截屏2024-08-31 10.07.20.png](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/7.png)

### 整数计算过程

1. CPU内部处理的整数数值都是补码，编译器会将十进制整数转换成对应的补码，正整数的补码是原码，负整数的补码是符号位不变其余位取反再加1。
2. 编译器认为源代码中的十六进制数已经是补码形式了，不再进行补码处理。
3. signed和unsigned类型的区别是，汇编层面处理逻辑会有所不同具体表现在”判断-跳转“、符号位扩展等逻辑上，这部分是编译器根据代码上下文逻辑生成的。落实到CPU处理层面不区分正负，按照二进制运算法则计算，根据计算结果更新EFLAGS寄存器的CF、AF、PF、ZF、SF、OF标志位，汇编层面的jmp族指令根据ZF、CF、SF标志位的值组合逻辑进行跳转。
    
    ![b31a2232a0fdb51fa9f75f8402bc8e78.png](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/9.png)
    
    - CF：进位标志CF（Carry Flag），如果运算结果的最高位产生了一个进位或借位，其值为1，否则为0。
    - PF：奇偶标志PF（Parity Flag），运算结果中“1”的个数的奇偶性，偶数个1，PF=1，反之为0。
    - AF：辅助进位标志AF（Auxiliary Carry Flag），这个不太好理解，比如：EAX值为OxNNNNNNNN（红色地方有进位，AF就是1，不管使用的是：EAX、AX、AL）。
    - ZF：零标志ZF（Zero Flag），它记录相关指令执行后，结果是否为0；若结果为0，ZF=1，反之ZF=0
    - SF：符号标志SF（Sign Flag），正负标志位，它记录相关指令执行后，结果是否为负，如果结果为负，SF=1，反之SF=0。（说明一下：符号位是程序员确定的，如果是无符号数，就考虑SF位，如果是无符号数，就不考虑SF位，想让SF=1，就：MOV EAX,0×1然后SUB EAX,0x2）
    - OF：溢出标志OF（Overflow Flag）：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。（MOV AL,0x7F, ADD AL,0×1）CF与OF的区别：
    进位标志CF表示无符号数运算结果是否超出范围；
    溢出标志OF表示有符号数运算结果是否超出范围。
4. 强制类型转换由编译器根据代码上下文逻辑生成对应的汇编代码，涉及到数据类型长度的表现在寄存器长度的变换，涉及到signed和unsigned变换的表现在“判断-跳转”和符号位扩展逻辑上。

![截屏2024-09-01 08.32.52.png](/assets/posts/2024-09-24-cve-2017-7308-AF_PACKET-环形缓冲区整数溢出漏洞/10.png)

[两个无符号数做减法时，CF条件码如何置位](https://docs.pingcode.com/ask/304517.html)

伙伴系统、slab系统、分配掩码：

[Physical Page Allocation](https://www.kernel.org/doc/gorman/html/understand/understand009.html)

## 十、漏洞挖掘点