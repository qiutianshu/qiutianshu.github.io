---
layout: post
title:  "CVE-2022-0185 File System Context 内核整数溢出漏洞"
date:   2023-12-21 17:27:38 +0800
category: linux_kernel
---

CVE-2022-0185 是 Linux 内核文件系统（File System Context）功能中的一个高危漏洞。该漏洞源于 legacy_parse_param 函数中对长度参数的校验不当，存在整数溢出缺陷，进而可导致堆缓冲区溢出。

[CVE-2022-0185 - Winning a $31337 Bounty after Pwning Ubuntu and Escaping Google's KCTF Containers](https://www.willsroot.io/2022/01/cve-2022-0185.html)

## 一、fsconfig系统调用介绍

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled.png)

Linux kernel mail list显示，fsconfig系统调用于2018年加入Linux内核，调用号为431。
fsconfig允许用户空间程序对特定的文件系统实例的配置参数进行设置，通常与fsopen、fsmount和fspath一起使用，处理文件系统的设置、挂载和路径检索等问题。

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%201.png)

fsconfig接受5个参数：

- fd：文件系统上下文的描述符，用于指定与某个文件系统实例进行交互，是fsopen的返回值；
- cmd：命令参数，指定要执行的操作，可选的值有： FSCONFIG_SET_FLAG、FSCONFIG_CLR_FLAG、FSCONFIG_SET_STRING、FSCONFIG_SET_BINARY、FSCONFIG_SET_PATH、FSCONFIG_SET_FD；
- key：字符串，指定要修改的文件系统配置项名称，即配置项的键名称；
- value：指针参数，存储用于更新配置项的值。不同cmd类型对应不同的值；
- aux：此附加参数对某些命令（如FSCONFIG_SET_FLAG和 FSCONFIG_CLR_FLAG）有特定的含义。默认情况下设为0。

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%202.png)

## 二、 防护措施

- SMAP, SMEP, KASLR, KPTI；
- 非root权限用户禁用userfaultfd，从Linux 5.11开始禁止非root权限用户使用；
- CONFIG_SLAB_FREELIST_RANDOM=y   CONFIG_SLAB_FREELIST_HARDENED=y

## 三、漏洞分析&利用思路

### 漏洞分析

漏洞函数的功能：
在位置1处从ctx->data_size中获取已读入的内容的长度。第一次进入漏洞函数时，size=0；
在2处计算本次需要复制的数据的长度，计算方式为key字符串的长度+value字符串的长度再加上1字节的‘\0’；
3的位置是漏洞点，此处本意是如果堆块剩余空间不够容纳，那么报错返回。如果在前面调用的过程中，size已经累加到4095，由于len是无符号整数，那么PAGE_SIZE-2-size就会向下溢出并且强制类型转化成大整数，造成此处的if判断被绕过。
如果第一次调用漏洞函数，ctx->legacy_data指针为空，那么调用kmalloc分配PAGE_SIZE大小的堆块用于存放数据；
在3的位置发生溢出，到4处就是越界写，且内容可以被攻击者控制，只不过在开头和中间会被插入‘,’和‘=’，在末尾会加入‘\0’；
5的位置，在复制数据的同时size也在更新，并且被保存回ctx->data_size，供给下一次调用使用。

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%203.png)

### 反推输入点

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%204.png)

对fs_type->init_fs_context字段为NULL的文件系统类型例如ext4、Plan 9，在finish_clean_context函数中就会调用legacy_init_fs_context()注册legacy_fs_context_ops。在vfs_parse_fs_param中调用到legacy_fs_context_ops.legacy_parse_param

### 分析过滤条件

1. fsopen一个file_system_type.init_fs_context字段为NULL的文件系统，例如fsopen(“ext4”, 0)；
2. cmd = FSCONFIG_SET_STRING
3. key != “source”且key长度不超过256
4. value != NULL 且value长度不超过256
5. aux = 0
6. 攻击者必须具备 CAP_SYS_ADMIN 权限

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%205.png)

需要注意的是，在越界写的过程中，在开头会插入逗号，在key和value之间会插入等号，在value末尾会添加‘\0’。
下一次调用漏洞函数，又会将上一次末尾的‘\0’覆盖成逗号。
在利用中可以让key指向空字符串，使得‘,’和‘=’紧邻，尽量减小对覆盖的数据的影响。
最大溢出长度的计算：strlen(key) + 1 + strlen(value) + 1 =2 + strlen(value) = 258

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%206.png)

### 漏洞信息提炼

综合上述分析可以提炼出如下漏洞信息：

- 安全防护
    - 开启了KASLR、SMEP、SMAP
    - CONFIG_STATIC_USERMODEHELPER=n，modprobe_path变量可以写
    - CONFIG_SLAB_FREELIST_RANDOM=y，slub随机化开启
    - CONFIG_SLAB_FREELIST_HARDENED=y，堆指针加密打开
    - 非特权用户禁用userfaultfd
- 堆分配器：SLUB分配器
- 漏洞能力
    - 溢出对象为kamlloc分配的堆块，flag=GFP_KERNEL（通用堆块）
    - 堆块大小固定为0x1000字节（可以使用msg_msg进行堆喷布局）
    - 最大溢出长度为258字节（msg_msg越界读、msg_msg任意地址读/写）
    - 攻击者可以控制除了开头的‘,’’‘=’和末尾的‘\0’的内容。
    - 漏洞可以反复触发

### 漏洞利用思路

1. 堆溢出msg_msg->m_ts越界读取seq_operations结构体，泄漏内核代码段指针绕过kaslr；
2. 堆溢出msg_msg->next + fuse实现任意地址写，覆盖modprobe_path指向攻击者提供的提权木马；
3. 触发提权木马实现权限提升。

## 四、利用步骤

### fuse初始化

在内核支持FUSE文件系统的情况下，普通权限用户要借助/bin/fusemount工具挂载自定义的fuse文件系统。通过unshare函数创建一个新的命名空间可以绕开以上要求。

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%207.png)

自定义的fuse文件系统需要实现三个函数：
getattr
readdir
read
其余的可以不用管。

fuse_main接受4个参数：
argc：argv数组非NULL元素的个数

argv：命令行参数集合，指向fargs_evil数组。“exploit”是程序名，“evil”是fuse文件系统挂载目录

ops：文件系统操作集合，指向我们自定义的evil_ops

user_data：用户数据，设置为NULL

### 绕过KASLR

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%208.png)

在kmalloc-4k中堆喷，构造出漏洞堆块和msg_msg紧邻的布局。
其中msg_msg消息的大小为0xfd8，这会导致在kmalloc-32中分配额外0x20大小的堆块。
打开多个"/proc/self/stat"文件，会在kamlloc-32中分配多个seq_operations结构，里面包含4个内核函数指针：

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%209.png)

堆溢出覆盖msg_msg->m_ts字段，扩大为0x1060。msgrcv就会泄漏seq_operations结构体。

### msg_msg + fuse任意地址写

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%2010.png)

步骤1：调用msgsnd，size=0xfe0，load_msg会在内核分配一个4K的堆块和32字节的堆块。

步骤2：线程1中内核调用copy_from_user从用户空间拷贝内容到内核堆块，在0x1338000处发生缺页异常，fuse调用evil_read操作卡住。

步骤3：线程2中fsconfig溢出覆盖msg_msg->next字段指向modprobe_path-8，并通知线程1继续运行。

步骤4：线程1继续执行evil_read，将攻击者指定的fake_path写入到modprobe_path-8的位置，实现任意地址写。


### 提权

提权文件是一个bash脚本，用于给/bin/bash添加S位。
调用一个格式未知的文件时，内核以root身份调用modprobe_path指向的文件来加载能够解释未知格式文件的驱动程序。
此时的modprobe_path内容已经被替换成了提权文件的路径，相当于以root身份给/bin/bash添加了S位，bash成为了root shell。
普通权限用户执行`bash -p`命令便会切换到root shell。

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%2011.png)

## 五、msg_msg任意地址读写

1. 使用msgsnd函数可以进行kmalloc-64～kmalloc-4k范围内的堆喷操作；
2. 如果能覆盖msg_msg 头部的m_ts成员，那么就会改变消息长度，造成越界读取；
3. 如果能在load_msg过程中覆盖msg_msg头部的struct msg_msgseg *next成员，那么就可以造成任意地址读写，这通常要利用userfaulted条件竞争，但最新的内核已经无法用户态调用userfaulted。fuse文件系统操作可以替代userfaultfd完成同样的工作。

如果覆盖msg_msg->next为指定的任意地址，覆盖msg_msg->m_ts大于0xfd0，那么msgrcv可以实现任意地址读。
如果msg_msg消息长度超过0xfd0，那么需要分段拷贝。如果这里能做到在拷贝第一段的时候发生缺页中断，让拷贝操作挂起等待异常处理完成，在这时候利用溢出覆盖msg_msg->next指针，等异常处理完毕回来继续拷贝第二段的时候就变成了向我们指定的地址覆盖任意内容了(任意地址写)。

### 任意地址读

1. 堆溢出的目标是覆盖msg_msg->next字段指向我们想要读取的地址address-8的位置，因为seg2头部的8字节是next指针。
需要注意的是，msg_msg->next指向的地址，保存的内容必须是0，否则内核就会继续遍历next指针，很有可能导致非法地址访问。
我们可以让msg_msg->next指向目标地址上方最近的保存0的地址。
2. msg_msg->m_ts覆盖的大小超过0xfd0
3. next和prev指针被覆盖成了非法地址形式，因此msgrcv的flag参数需要带上
IPC_NOWAIT | MSG_COPY | MSG_NOERROR标志位，防止消息被unlink。

![Untitled](/assets/posts/2023-12-21-CVE-2022-0185-File-System-Context-内核整数溢出漏洞/Untitled%2012.png)