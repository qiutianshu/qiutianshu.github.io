---
layout: post
title:  "CVE-2021-43267 tipc驱动任意代码执行"
date:   2023-12-21 13:27:38 +0800
category: linux_kernel
---

CVE-2021-43267 是一个潜伏于 Linux 内核 TIPC（透明进程间通信）协议簇中的高危漏洞。该漏洞源于其对恶意构建的 MSG_CRYPTO 消息类型处理不当，存在堆缓冲区溢出漏洞。由于 TIPC 模块通常以高权限运行，本地攻击者无需特殊权限即可利用此漏洞，实现内核权限提升或导致系统拒绝服务，危害性极大。

## 〇、漏洞信息

- 安全防护：
开启了KASLR、SMEP、SMAP
CONFIG_STATIC_USERMODEHELPER=n
CONFIG_SLAB_FREELIST_RANDOM=y
CONFIG_SLAB_FREELIST_HARDENED=y
- 堆分配器：SLUB分配器
- 漏洞能力
溢出对象为kamlloc分配的堆块（通用堆块）
堆块大小[24,66000]字节（可以使用msg_msg进行堆喷布局）
溢出长度为任意大小（msg_msg+tty_struct越界读、msg_msg任意地址读写）

## 一、漏洞发现过程

2021年11月4日，SentinelLabs的研究人员使用CodeQL搜索Linux内核代码中的kmalloc函数调用[1]，CodeQL语句如下：

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled.png)

上述语句的作用是搜索所有kmalloc调用，如果传递给kmalloc的实参类型的大小为2字节，也就是short或者unsigned short，那么就返回搜索结果。
在返回的60多个结果中如下代码片段引起了研究人员的注意：

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%201.png)

这段代码用于处理接收到的数据包。
在(1)处根据hdr中提取的size信息分配了一个堆块。
在(2)(3)处根据data中的size信息，将数据复制到堆块中。
这里存在两个潜在的问题：
在(3)的位置复制数据没有对长度进行检验。
(1)和(2)处的size来源不同，数据包头部的size字段可能与数据部分的size字段不一致。
猜测这是一个堆溢出漏洞。

## 二、TIPC协议简介

TIPC（Transparent Inter-Process Communication）协议是一种高性能的进程间通信（IPC）协议，主要用于集群环境中的通信。它为实现低延迟、高可靠性的通信提供了基础设施。TIPC起初由Erlang Blomsrut和Jon Maloy为爱立信开发，后成为开源项目，并集成在Linux内核中。
TIPC的优势包括位置透明性、无需配置的自主路由、高性能与低延迟、多种通信模式以及可靠性与容错。它适用于电信、工业自动化、分布式计算、云计算、物联网（IoT）、嵌入式系统和实时操作系统等领域。
Linux内核版本：5.14-15
实验平台：Ubuntu20.04.1

### 1. 运行方式

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%202.png)

TIPC协议横跨传输层、网络层和链路层[2]，向上提供进程间的通信。
TIPC使用以下的传输协议作为载体：

- 以太网协议（链路层）
- InfiniBand（链路层）
- UDP协议（传输层）

TIPC可以配置为在Ethernet或UDP协议之上运行。但是低权限的用户是无法创建Ethernet帧，因此使用UDP更容易实现本地漏洞利用。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%203.png)

在TIPC协议中，节点之间通过创建套接字进行通信。通信双方可以直接使用TIPC独特的地址类型（如服务地址或端口身份）进行通信，而不必关心底层网络的细节。
虽然TIPC是在这些协议之上运行的，但有独立的地址方案，节点可以选择自己的地址。TIPC协议以对用户透明的方式工作。所有的消息构造和分析都是在kernel中进行的。每个TIPC消息都有相同的通用header格式和消息特定的header。

### 2. 地址方案

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%204.png)

- Zone：系统管理员可以创建一个独特标识的Zone来很方便的将很多个node划分为一组
- Cluster：Zone的再划分，Cluster的标识必须为范围[1,4095]的数字
- Node：一个Cluster包含多个node，node的标识也必须为范围[1,4095]的数字，node可以通过TIPC网络进行通信
- Link：node之间的通信通道被称为link，就是图中的箭头，link可以正确有序的在node之间传输数据单元
- Message：TIPC中用于交换数据的基本单元，图中箭头所载的信息

### 3. 命令行交互工具

在Ubuntu中需要用户手动加载tipc驱动：sudo modprobe tipc
配置底层传输介质为UDP并绑定本地ip：sudo tipc bearer enable media udp name <your name> localip <ip>

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%205.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%206.png)

在两台Ubuntu虚拟机上分别作如上配置，可以看到相互都发现了对方的node，并且已经建立了连接。

### 4. 数据包格式

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%207.png)

可以看到数据包头部大小为40字节，消息的大小为44字节。
节点的寻址方面，最底层是以太网层和UDP层，TIPC协议层采用<Zone.Cluster.Node>编址，将32位ip地址划分为:

- Zone[0,7]
- Cluster[8,19]
- Node[20,31]

User字段和Message Type字段决定了当前数据包的类型，决定了数据包走哪一条处理路径。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%208.png)

Linux内核将TIPC数据包头部定义为15个32位大端数组，我们需要关注以下字段：

- User字段，用于识别消息类型，与Mtype字段一起使用
- Hsize字段，消息头部大小
- Message Size字段，消息的总长度，包括消息头部
- Mtype字段，与User字段一起使用

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%209.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2010.png)

## 三、漏洞分析&利用思路

### 1. 漏洞分析

2020年9月引入了一个新的用户消息类型—— MSG_CRYPTO，该消息类型允许节点发送加密的密钥消息头对应的User字段为MSG_CRYPTO。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2011.png)

tipc_aead_key结构包含一个32字节长度的字符数组，8字节的keylen字段表示key[]的长度，以及一个变长数组key[]用于保存密钥。
数据结构保存在TIPC消息的数据字段。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2012.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2013.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2014.png)

msg_data_sz根据TIPC头部计算出TIPC载荷的长度，根据这个长度，后面kmalloc分配堆块。
data指向载荷，skey->keylen从TIPC载荷中读取key的长度。
攻击者可以控制tipc_aead_key->keylen使之大于TIPC头部计算的长度，在memcpy中造成堆溢出。
在memcpy之后才对长度进行检验，此时已经晚了。

### 2. 反推输入点

内核从tipc_udp_recv接收来自用户的数据包，在tipc_rcv中调用tipc_msg_validate对数据包头部的Hsize和Msize进行检验，
在tipc_link_rcv中根据User字段把数据包路由到不同的函数进行处理。
若满足User=MSG_CRYPTO(14)且Message type=KEY_DISTR_MSG(0)，数据包被路由至tipc_crypto_key_rcv

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2015.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2016.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2017.png)

### 3. 分析过滤条件

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2018.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2019.png)

在对数据包进行检验的时候，仅检查了Hsize和Message size。所以攻击者可以在保证Hsize和Message size关系正确的情况下构造任意大小的keylen字段。满足skb->len >= msz意味着tipc数据包的实际长度可以大于Message size。

### 4. 利用思路

MSG_CRYPTO消息的堆块内存分配的size来自tipc_msg->msz - tipc_msg->hsz，MSG_CRYPTO消息的拷贝的size来自tipc_aead_key->keylen。所以通过控制tipc_msg->msz即可控制目标堆块的分配大小，控制tipc_aead_key->keylen即可控制堆块的溢出长度。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2020.png)

由于tipc数据包的实际长度可以大于Message size，可以在数据包超出Message size的部分附加额外的数据用于堆溢出，在memcpy过程中这部分数据可以用来覆盖相邻堆块上的数据结构，实现越界写。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2021.png)

### 5. 漏洞信息提炼

综合上述分析可以提炼出如下漏洞信息：

- 安全防护：
开启了KASLR、SMEP、SMAP
CONFIG_STATIC_USERMODEHELPER=n
CONFIG_SLAB_FREELIST_RANDOM=y
CONFIG_SLAB_FREELIST_HARDENED=y
- 堆分配器：SLUB分配器
- 漏洞能力
溢出对象为kamlloc分配的堆块（通用堆块）
堆块大小[24,66000]字节（可以使用msg_msg进行堆喷布局）
溢出长度为任意大小（msg_msg+tty_struct越界读、msg_msg任意地址读写）

## 四、如何到达漏洞位置

TIPC是网络协议，我们既可以从远程打，也可以从本地进行提权，为了便于演示漏洞利用过程，选择从本地进行提权。

- 首先需要使能本地TIPC节点

根据TIPC官方文档[4]，可以使用发行版操作系统自带的tipc命令进行配置.但是考虑到目标系统的多样性，最好使用内核提供的接口对tipc进行配置。

- 然后需要初始化协议状态机

数据包要能够到达漏洞位置，必须经过一系列握手步骤。如果是正常的网络环境，两台主机都分别使能本地tipc节点，在自动发现协议的作用下会自动握手并建立连接。但在本地环境攻击者需要向内核发送特定的数据包伪造握手过程，使得tipc协议状态机满足收发数据的条件。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2022.png)

### 1. 使能tipc节点

### 2. 伪造握手过程

## 五、漏洞利用步骤

### 1. msg_msg越界读取tty_struct结构绕过KASLR

使用经典的msg_msg+tty_struct方法来泄漏内核代码段地址和堆地址[6]。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2023.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2024.png)

通过堆喷射在tipc_aead_key的周围布置大量的msg_msg消息和tty_struct结构。堆溢出使得msg_msg的m_ts字段被覆盖成攻击者选定的任意大小。再使用msgrcv()对消息进行读取，造成越界读，泄漏相邻tty_struct结构的tty_operations结构指针。

需要注意覆写msg_msg->m_ts的同时也会覆盖msg_msg->m_list，直接调用msgrcv会将匹配的消息从链表中unlink，如果不正确构造msg_msg->m_list就会导致访问崩溃。解决办法是在调用msgrcv时传递MSG_COPY flag，这样内核就只复制msg_msg的内容而避免进行unlink。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2025.png)

当我们执行open("/dev/ptmx",flag)打开一个伪终端设备 ptmx时，内核函数alloc_tty_struct调用kzalloc分配tty_struct结构。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2026.png)

sizeof(struct tty_struct)=0x2e0，分配到的堆块大小为kmalloc-1k。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2027.png)

tty_struct->ops指向的tty_operations结构是一个函数指针集合。
alloc_tty_struct()分配tty_struct的内存空间之后会将tty_struct->ops指向内核全局变量ptm_unix98_ops或pty_unix98_ops。
因此我们可以通过越界读取tty_struct->ops指针来泄露内核全局变量地址。
在调试阶段我们可以开root从/proc/kallsyms中读取两个全局变量的地址，根据16进制后三位可以判断出泄漏的地址属于二者之中的哪一个。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2028.png)

先在堆上喷满msg_msg结构，释放msg_msg0，分配tipc_aead_key堆块占据msg_msg0的位置。从msg_msg2开始释放下标为偶数的堆块。打开大量ptmx分配tty_struct结构占据刚刚释放的堆块。
再利用tipc_aead_key的溢出来修改msg_msg1->m_ts，最后调用msgrcv越界读取tty_struct来泄露内核全局变量的指针。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2029.png)

为了和tty_struct分配到同一个slub里面，申请的msg_msg消息大小为0x3d0，加上0x30的msg_msg消息头总长度为0x400。
触发越界写的tipc数据包如图所示：

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2030.png)

为了使分配给tipc_aead_key的堆块大小为0x400，Message size在0x400的基础上加上头部固定的24字节。
在memcpy过程中，tipc_aead_key头部36字节固定用于存放keylen和alg_name数组，剩下的部分长度为0x400-32-4。
设置keylen=0x400-36+smashlen正好越界写smashlen个字节，写的内容就是smashdata部分。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2031.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2032.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2033.png)

触发漏洞，tipc_aead_key邻近的msg_msg被覆盖。

### 2. 泄漏堆地址

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2034.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2035.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2036.png)

在初始化之时tty_struct.ldisc_sem.read_wait.next被设置为指向read_wait自身。next在tty_struct结构中的偏移为0x38，因此next-0x38即可得到tty_struct的地址，也即是泄漏的堆的地址。

### 3. 喷射fake_operations结构

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2037.png)

向堆上喷射攻击者构造的tty_operations结构，里面填充任意地址写gadget。这里仍然采用喷射大小为0x400的msg_msg堆块的方式，这样可以确保fake_operations分配在kmalloc-1k的slub上面。
泄漏的tty_struct地址 + 偏移量 即可得到fake_operations的地址，该地址后面用于替换正常的tty_struct->ops。偏移量可以通过多次尝试得到。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2038.png)

### 4. 篡改tty_struct->tty_operation指针

篡改tty_struct->tty_operation指针使之指向攻击者构造的fake_operations结构。
fake_operations填充能够实现任意地址写功能的gadget，
当调用ioctl时，内核调用gadget将字符串“/tmp/hax”覆盖内核全局变量modprobe_path。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2039.png)

依次分配msg_msg消息堆块和tty_struct结构，使两个堆块紧邻；
调用msgrcv释放msg_msg堆块；
触发堆溢出，把fake_operations地址写入tty_struct->ops指针。
由于Slub分配器对空闲对象的分配实行后进先出，所以tipc_aead_key能够立即分配到刚刚释放的msg_msg堆块。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2040.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2041.png)

### 5. 任意地址写

第二次触发越界写，相邻tty_struct->ops被覆盖成fake_operations地址。
fake_operations填充gadget地址。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2042.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2043.png)

此时tty_struct->ops->.compact_ioctl指向任意地址写gadget：

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2044.png)

调用ioctl最终将执行任意地址写gadget，此时rdx保存ioctl第三个参数modprobe_path的地址，rsi保存字符串“/tmp/hax”，实现将“/tmp/hax”写入modprobe_path地址。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2045.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2046.png)

### 6. 触发modprobe_path

漏洞利用初始化阶段向/tmp目录下写入一个任意格式的文件并赋予执行权限。
由于该文件不是ELF格式的文件，当试图运行该文件时，内核无法识别文件类型，内核起一个内核线程以root身份调用/sbin/modprobe加载一个能够解释该文件的内核模块。
“/sbin/modprobe”字符串保存在内核全局变量modprobe_path中。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2047.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2048.png)

由于前面modprobe_path已经被覆盖成了“/tmp/hax”，所以此时内核以root的身份执行/tmp/hax。

## 六、提权木马原理

攻击者每次获取root权限都要执行一次exp，这会使系统非常不稳定从而使系统管理员产生警觉。我们可以在exp第一次获取root权限时就在系统里留下永久性root后门。
call usermodprobe_helper执行的/tmp/hax属于内核线程，他的ruid=0，euid=0。所以hax线程释放出的sh文件属于root。hax再设置sh的SUID位，则普通权限的用户运行sh时euid=0，就是一个root shell。
由于SUID程序的euid在fork的时候不能继承，因此永久后门先用setuid(0)将自己的ruid设为0，再execve出root shell。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2049.png)

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2050.png)

在具体实现方面，将各个阶段的载荷层层嵌套，最终硬编码到EXP里面。EXP和hax分别将各自下一阶段的载荷通过open、write释放出来。这要求hax和后门程序的大小不能太大，否则不方便编码到漏洞利用代码里面。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2051.png)

攻击者获取一个低权限shell后执行驻留后门便可以得到一个root shell。为使程序尽可能紧凑采取如下方法：

1. 用nasm汇编语言编写，用ld去符号静态链接；
2. 避免单独的.data段，将静态数据用nop占位并放置在.text段末尾，这样可以避免因单独的.data段而填充的垃圾字节；
3. 用二进制编辑器删除非加载段；
4. 将代码段末尾的nop字节手工修改为字符串；
5. 用二进制编辑器修改程序入口地址、可加载段大小等信息，以及代码中的地址引用。

### 1. ELF文件结构

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2052.png)

### 2. sh的设计

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2053.png)

编译链接这段代码得到的可执行文件大小为4.4KB，至此完成了第1步和第2步。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2054.png)

第3步用二进制编辑器删除elf文件中的非加载段。
通过readelf观察到文件偏移0x1030往后的都是非加载段，都可以删掉。非加载段这部分包括了.shstrtab和section header。
剩下有用部分是elf header、program header和.text段，这三个部分被划入到2个LOAD段作为实际运行时内存镜像。LOAD1段包含了elf header和program header，大小为sizeof(Elf64_Ehdr) + 2 * sizeof(Elf64_Phdr) = 0xb0，其中Elf64_Ehdr标记了程序入口点，每个Elf64_Phdr标记了一个LOAD段的加载信息。LOAD2段是.text段从文件偏移0x1000开始，大小为0x30。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2055.png)

为了便于程序运行的加载，在程序链接时各个可加载段都是按照4KB对齐，所以每个LOAD段有大量填充字节，需要删掉这些填充字节，从0xb0开始到0x1000全部删掉，这样.text段就被提前到了0xb0的位置。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2056.png)

再观察发现2个program header其实可以合并成一个，也就是将elf header、program header、.text段合并成一个LOAD段，这样就可以只用一个program header进一步压缩体积。
删掉Elf64_Phdr2，text段并入LOAD1，要修改Elf64_Phdr1的p_filesz和p_memsz字段。Elf64_Phdr1.p_filesz = 0xb0 - sizeof(Elf64_Phdr2) + sizeof(.text) = 0xB0-0x38+0x30 = 0xA8。由于.text段末尾的2个nop字节要扩展成“/bin/sh”字符串，所以最终Elf64_Phdr1.p_filesz = 0xA8 - 2 + sizeof(BinSh) = 0xAD。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2057.png)

将.text段末尾两个nop指令修改为字符串“/bin/sh”后得到如上格式的文件：

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2058.png)

第四步修改代码段中BinSh字符串的引用地址、Elf64_Ehdr结构。
BinSh的内存地址为0x40006A。修改e_entry为代码段起始地址0x400078。由于section header被删掉，所以相关的e_shoff、e_shnum、 e_shentsize、 e_shstrndx字段全部置为0。e_phnum为program header数量，置为1。
至此原本4.4KB的后门现在只剩下174字节。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2059.png)

### 3. hax程序的设计

hax程序会释放永久后门sh，并且设置sh的权限为0755，设置sh的S位，nasm汇编如下：
编译后按照制作sh的方法同样也将hax裁剪压缩，并且将sh的字节码附加到.text段的末尾。
运行hax后可以看到sh文件被释放，并且设置了S位。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2060.png)

再将hax文件的字节码提取出来贴到exp里面就可以通过exp来释放了。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2061.png)

hax的字节码：

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2062.png)

## 七、堆喷注意事项

### 1. 检查堆分配机制

在进行堆喷射之前，要弄清楚内核用的是什么堆分配器，以及是否开启了堆防护措施。
Linux内核有三种内存分配机制，分别是slob、slab和slub，桌面端和服务端现在多使用slub分配器，这三种机制习惯上都称为slab。

slub机制下堆块分配向高地址增长

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2063.png)

slab机制下堆块分配向低地址增长

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2064.png)

堆分配机制的不同，直接影响堆喷射过程中的堆块布置。
查看本机内核编译配置文件：

```bash
cat /boot/config-$(uname -r)
```

可以看到本机使用的是slub分配器，且开启了freelist random和freelist hardened两种保护措施，现在的Linux发行版普遍开启了这两种堆保护机制。
本例子为调试方便关闭了这两个保护。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2065.png)

在CTF竞赛中通常没有提供编译配置文件，那么我们也可以进到虚拟机里面查看/proc/slabinfo文件。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2066.png)

看到limit和batchcount字段都是0，说明当前使用的是slub分配器。因为在slub分配中这两个字段没有对应的实现。
如果limit和batchcount不为0，说明当前使用的是slab分配器，这两个字段在slab中实现。

### 2. SLUB freelist random

开启freelist random保护，可以看到堆块的分配并没有按顺序向高地址增长，每次分配到的地址都是随机的。
但是堆块的释放和分配还是按照“后进先出”（LIFO）的顺序不变，这一点很重要。

![Untitled](/assets/posts/2023-12-21-CVE-2021-43267-tipc驱动任意代码执行/Untitled%2067.png)

## 八、知识总结

Q：本例漏洞分析思路是什么？
A：1.从漏洞位置出发，反向查找找到用户的输入点；2.在漏洞点之前寻找过滤点，判断是否对漏洞利用条件进行了限制或者是过滤。在本例子中就是找到tipc_msg_validate函数并查看是否对Hsize、Msize和keylen进行关联或者限制，很显然漏过了对keylen的检验；3.构造路径满足状态机的需要，使能够到达漏洞点。

Q：本例开发exploit的思路是什么？
A：1.分析系统存在哪些保护，不然就会出现忙活大半天，发现路被封死了的情况;2.仔细找出漏洞的属性，比如对于堆溢出漏洞，我们要搞清楚堆块分配在哪个缓存上、溢出的堆块大小是否可控、能够溢出多少字节；3.在前面两步分析的基础上，结合我们自己的经验选择合适的漏洞利用方法。

Q：为什么要弄清楚堆块分配机制？
A：内核可能采用slub分配器或者slab分配器，这两者的分配机制是不同的。结合源代码和试验结果看，在关闭freelist random的条件下，slub按照低地址向高地址分配对象，slab按照高地址向低地址分配对象。对于空闲对象的管理，两者使用的都是后进先出(LIFO)分配方式。所以对于不同的分配机制，需要调整堆喷的策略。

Q：如何确定tipc建立连接的过程？
A：使用wireshark对正常的握手过程进行抓包，分析出两个节点建立连接的过程。对一个陌生的协议使用wireshark分析是必要的。

## 九、参考文章

[1] [CVE-2021-43267: Remote Linux Kernel Heap Overflow TIPC Module Allows Arbitrary Code Execution](https://www.sentinelone.com/labs/tipc-remote-linux-kernel-heap-overflow-allows-arbitrary-code-execution/)

[2] [Linux Netlink基本使用](https://blog.csdn.net/silent123go/article/details/78812981)

[3] [[corCTF 2021]Wall Of Perdition: Utilizing msg_msg Objects For Arbitrary Read And Arbitrary   Write In The Linux Kernel](https://syst3mfailure.io/wall-of-perdition/)
