---
layout: post
title:  "CVE-2019-18683 V4L2框架条件竞争漏洞分析"
date:   2025-01-29 13:27:38 +0800
category: linux_kernel
---

CVE-2019-18683是Linux内核video4Linux2（V4L2）框架中一个高危的条件竞争漏洞。该漏洞源于videobuf2核心组件在内存映射（mmap）操作与缓冲区队列管理之间缺乏有效的同步机制，导致产生UAF漏洞。

## 一、环境搭建

主机环境：Ubuntu 18.04 

内核版本：linux 5.4.0-rc2

对.config文件进行如下配置，确保和漏洞相关的所有组件编译进内核：

```c
CONFIG_VIDEO_DEV=y
CONFIG_VIDEO_V4L2=y
CONFIG_VIDEO_VIVID=y
```

编译安装内核：

```bash
/linux-5.4-rc2$ make menuconfig
/linux-5.4-rc2$ make -j8
/linux-5.4-rc2$ sudo make modules_install
/linux-5.4-rc2$ sudo make install
```

安装完成后重启系统，在/dev目录下出现video0和video1两个设备：

![截屏2025-01-17 10.00.34.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/1.png)

## 二、V4L2框架介绍

V4L2是video for linux version 2的简写，是Linux内核里面用于视频采集的框架。

该框架设计的目的是，为市面上型号繁杂的摄像头提供统一的接入方式，在内核层面抽象出调用框架，以内核API的形式提供给驱动开发者使用。用户态层面通过read/write、ioctl命令、mmap内存映射等系统调用，操作V4L2框架，实现摄像头的开启/关闭、取流/停止、摄像头参数修改、摄像头信息读取等功能。

框架结构如图所示，hardware层是针对不同的SoC芯片的驱动程序，主要包括硬件编码解码、图像画质的硬件处理、控制命令接口等功能。

external device层是连接的摄像头外设，通过USB、I2C、SPI、GPIO接口与SoC进行控制连接，通过MIPI图像传输接口与SoC进行图像传输连接。

![截屏2025-01-17 10.38.24.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/2.png)

v4l2-core目录是整个框架的核心，实现了内核API，实现了系统调用。

![截屏2025-01-17 11.06.54.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/3.png)

platform目录是不同SoC芯片的图像驱动，实现了hardware层功能。

![截屏2025-01-17 11.07.47.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/4.png)

CVE-2019-18683漏洞位于platform/vivid目录，是V4L2框架实现的自测驱动，该漏洞是通过syzkaller进行fuzz的时候发现的。

vivid驱动用于模拟外接视频源，使用vivid就可以不用外接摄像头来测试框架功能了。

## 三、漏洞原理

vivid模拟外接视频源的核心函数是vivid_thread_vid_cap。

打开取流后，该函数运行在内核线程上，源源不断向用户态申请的缓冲区复制随机生成的“视频帧”。在for无限循环中，生成并复制帧的操作是在dev→mutex信号量的保护之下的。

![截屏2025-01-17 14.10.41.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/5.png)

停止取流的操作中，主线程调用vivid_stop_generating_vid_cap杀掉vivid_thread_vid_cap内核线程，停止取流。

主线程进入到vivid_stop_generating_vid_cap函数之前，也是被dev→mutex信号量保护的，所以在vivid_stop_generating_vid_cap调用mutex_unlock释放信号量之前，vivid_thread_vid_cap内核线程实际上是一直在for循环中等待获取信号量的。

![截屏2025-01-17 14.11.23.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/6.png)

那么为何vivid_stop_generating_vid_cap要先解锁，才杀掉内核线程呢？

我认为，作者是想让vivid_thread_vid_cap内核线程最后一次执行完视频的生成，把那轮for循环执行结束再杀掉内核线程。

但是，如果vivid_stop_generating_vid_cap解锁之后，信号量没有被vivid_thread_vid_cap抢到，而是被vb2_fop_read抢走，那么vb2_fop_read会将那些因停止取流而标记为“待释放”的vb2_buffer重新加入活动链表。close的时候“待释放”的vb2_buffer会被kfree掉，但是由于它们还同时存在于活动链表中，另一个线程有可能继续操作活动链表，造成UAF。

该漏洞的竞争情况极为复杂，角度很刁钻，即使是漏洞发现者，也没有讲清楚里面的细节，只知道该漏洞的效果是造成kmalloc-1k对象的UAF。

## 四、条件竞争漏洞的测试方法

要分析条件竞争漏洞的触发原理，弄清楚多个线程之间的竞争窗口是一件不容易的事情。

一个常见的情况是，通过syzkaller打出了UAF，分析造成UAF的原因。

可以在锁操作语句的后面插入printk函数，打印系统的jiffies节拍、线程号等信息，直观的显示出哪个线程在哪个时间进入到了临界区，由此分析线程之间的竞争关系。

在这个漏洞中，syzkaller给出的poc主要逻辑是，创建2个线程分别绑定不同的cpu，每个线程都运行如下的for循环，若干循环之后触发UAF。

![截屏2025-01-17 15.33.51.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/7.png)

重点要关注线程A、线程B之间的read和close系统调用如何竞争。

对read系统调用的信号量操作插桩如下：

![截屏2025-01-17 15.49.23.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/8.png)

![截屏2025-01-17 15.58.10.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/10.png)

![截屏2025-01-17 16.02.09.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/11.png)

![截屏2025-01-17 15.52.26.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/9.png)

对close系统调用的信号量操作插桩如下：

![截屏2025-01-17 16.06.36.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/12.png)

![截屏2025-01-17 21.11.08.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/13.png)

dmesg日志分析：

第二列的数字表示jiffies节拍，jiffies是时钟中断计数器，cpu每到一次时钟中断，jiffies递增1，同时完成1次进程切换。

所以在打印日志中，jiffies的数值表示了两个线程运行的先后。

![截屏2025-01-17 19.09.24.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/14.png)

上图是一次成功的竞争过程中输出的日志，条件竞争的步骤是：
第一步，206线程首先进入vb2_fop_read获取信号量，在vb2_ops_wait_prepare函数中释放信号量；

第二步，207线程进入vb2_fop_read获取信号量，完整执行了read系统调用后，进入到close系统调用，并且在漏洞点vivid_stop_generating_vid_cap函数中释放了信号量。

第三步，206线程重新获取信号量，在vb2_core_qbuf函数中调用vid_cap_buf_queue函数，把vb2_buffer对象加入到vid_cap_active链表中。206线程执行完整个read系统调用释放信号量；

![截屏2025-01-17 21.31.56.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/15.png)

第四步，207线程在vivid_stop_generating_vid_cap函数中重新获取信号量，后面进入到vb2_core_reqbufs函数，将vb2_buffer对象释放。此时的vb2_buffer对象虽然已经kfree掉了，但是vid_cap_active链表仍然保留着对它的引用；

![截屏2025-01-17 20.54.04.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/16.png)

第六步，206线程执行close系统调用；

第七步，207线程开始了新的一轮open-read-close循环，重新进入到vb2_fop_read函数，在vid_cap_buf_queue函数中发生释放后重引用；

![截屏2025-01-17 21.40.41.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/17.png)

原因是新的一轮vb2_fop_read申请了一个新的vb2_buffer对象，并且要把新的vb2_buffer对象加入到vid_cap_active链表中。

由于vid_cap_active链表中已经链接了一个已被释放的vb2_buffer对象，所以进行list_add_tail操作导致了新的vb2_buffer对象地址写入到已被释放的对象中，触发了UAF。

![截屏2025-01-17 21.42.28.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/18.png)

## 五、漏洞利用

### 信息泄漏

在正式触发UAF之前，会首先触发WARN_ON语句，泄漏内核栈地址指针rsp和指向内核代码段地址的rcx寄存器。

![截屏2025-01-19 15.22.42.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/19.png)

WARN_ON语句位于__vb2_queue_cancel函数，位于调用close的过程中。

![截屏2025-01-19 15.19.16.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/20.png)

### 控制流劫持

UAF的对象是vb2_buffer，目标是劫持vb2_buffer→vb2_queue→mem_ops→vaddr(void *buf_priv)

其中函数指针vaddr的参数正是vb2_buffer.planes[n].mem_priv指针的值。

![v4l2_objects.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/v4l2_objects.png)

构造内核对象可以放在内核栈上面，内核栈的基地址由WARN_ON语句泄漏的rsp寄存器计算得到。

目标明确为：

1. 在内核栈构造vb2_queue对象，使得vb2_queue.mem_ops指向第2步构造的vb2_mem_ops；
2. 在内核栈构造vb2_mem_ops对象，其中vb2_mem_ops.vaddr指向rop gadget，用于劫持rip到内核栈；
3. 在内核栈构造rop chain，实现提权；
4. 堆喷射fake vb2_buffer对象，覆盖已经被UAF对象，其中vb2_buffer.planes[0].mem_priv指向rop chain。

在内核栈构造内容基于的原理是，adjtimex()这类系统调用会把用户态内容copy_from_user到内核栈上面，再结合userfaultfd技术即可实现在内核栈构造任意内容。

![v4l2_payload.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/v4l2_payload.png)

调用read即可触发控制流劫持，函数调用链条是：

vb2_fop_read —> vb2_read —> __vb2_perform_fileio —> __vb2_init_fileio —> vb2_plane_vaddr

—> fake vaddr

控制流劫持的效果是rip指针被劫持到内核栈rop chain区域，执行用于提权的rop chain。

rop chain的内容是执行内核函数run_cmd(”/bin/sh  /home/a13x/pwn”)，该函数由内核态发起，执行用户态命令，具有root权限。

![截屏2025-01-19 16.42.42.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/21.png)

## 六、漏洞修补

漏洞修补思路是用信号量完整的保护vivid_stop_generating_vid_cap函数杀掉vivid_thread_vid_cap内核线程的整个过程。

vivid_stop_generating_vid_cap函数去掉了中间加锁和解锁的步骤，使得整个过程被dev→mutex全程保护。

vivid_thread_vid_cap函数for循环中尝试去获取dev→mutex信号量，如果获取失败，那么线程睡眠1秒，线程醒来后continue循环，再次尝试获取dev→mutex，如此往复直到获取信号量。若检测到线程被杀掉，kthread_should_stop()返回ture，循环结束。

![截屏2025-01-18 19.03.02.png](/assets/posts/2025-01-29-CVE-2019-18683-V4L2框架条件竞争漏洞分析/22.png)