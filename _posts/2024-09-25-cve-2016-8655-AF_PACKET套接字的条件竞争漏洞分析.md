---
layout: post
title:  "cve-2016-8655 AF_PACKET套接字的条件竞争漏洞分析"
date:   2024-09-25 13:27:38 +0800
category: linux_kernel
---
该漏洞源于 Linux 内核网络子系统处理 AF_PACKET 套接字时存在的一个条件竞争漏洞。本文讲解如何在特定的时序下触发 packet_set_ring() 与 packet_setsockopt() 函数之间的竞争窗口，从而导致内核堆内存的损坏，实现本地权限提升。

## 一、环境搭建

虚拟机环境：Ubuntu 16.04LTS @ Linux 4.8.0

GRUB选项：关闭SMAP、关闭SMEP、关闭KASLR

![截屏2024-09-24 09.00.11.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/1.png)

内核编译选项：这些选项默认是打开的，否则需要开启并重新编译内核。

```c
CONFIG_USER_NS=y
CONFIG_PACKET=y
CONFIG_X86_VSYSCALL_EMULATION=y
```

## 二、漏洞原理

该漏洞是AF_PACKET套接字的条件竞争漏洞，竞争成功后关闭套接字又触发了释放后重引用，漏洞位于net/packet/af_packet.c。

使用setsockopt创建TPACKET_V3版本的接收缓冲区，会先初始化一个定时器对象，该定时器对象嵌套在套接字对象里面。攻击者可在V3版本缓冲区创建完成之前使用其他线程调用setsockopt修改套接字版本为TPACKET_V1，此时关闭套接字会释放套接字对象，但嵌套的定时器不会被删除释放，造成了定时器函数指针的释放后重引用。

### 1. 触发路径

两个线程执行的都是setsockopt系统调用。

![exp.c-第 2 页.jpg](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/2.jpg)

只有当packet套接字版本号为TPACKET_V3，并且是创建接收缓冲区的操作时，packet_set_ring()函数才会进入到init_prb_bdqc()函数使能定时器对象。

![截屏2024-09-24 15.37.50.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/3.png)

在竞争窗口之前内核没有对套接字对象进行加锁，只对版本号进行检查。

竞争窗口之后，即init_prb_bdqc()函数之后才对套接字上锁。

在竞争线程修改版本号为TPACKET_V1的操作过程中，也没有对套接字上锁。

![截屏2024-09-24 10.36.07.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/4.png)

关闭packet套接字操作调用到packet_release()函数，在packet_set_ring()函数中，若套接字版本小于TPACKET_V2，那么保留定时器。由于条件竞争将版本号修改成了TPACKET_V1，定时器对象保留。

packet_release()函数最后调用sock_put()函数释放整个套接字对象，连带着嵌套的定时器对象还给系统。此时定时器还注册在系统中，超时后调用超时函数，造成释放后重引用。

![exp.c-第 6 页.jpg](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/5.jpg)

### 2. 补丁对比

Linux4.10版本中，对修改版本号的操作添加了保护锁。

![截屏2024-09-24 10.47.42.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/6.png)

packet_set_ring()函数全程加锁进行了保护。

![截屏2024-09-24 14.33.34.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/7.png)

### 3. 关联的数据结构

关联的数据结构都是嵌套关系

![exp.c-数据结构.jpg](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/8.jpg)

定时器函数指针的偏移为0x398，参数的偏移为0x3a0

![exp.c-偏移.jpg](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/9.jpg)

## 三、可利用性分析

1. 关联的系统调用

```c
fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
setsockopt(fd, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
setsockopt(fd, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
```

1. 权限要求

攻击者需要在当前user namespace中拥有CAP_NET_RAW权限才能调用上述系统调用。

使用unshare系统调用创建并进入一个新的user namespace，在新的user namespace中创建一个新的net namespace即可拥有CAP_NET_RAW权限。

```c
unshare(CLONE_NEWUSER);  //创建并进入新的user namespace
unshare(CLONE_NEWNET);   //在新的user namespace中创建新的net namespace
write_file("/proc/self/setgroups", "deny");
write_file("/proc/self/uid_map", "0 1000 1\n", real_uid);//映射uid到父user namespace
write_file("/proc/self/gid_map", "0 1000 1\n", real_gid);//映射gid到父user namespace
```

1.  可重复进入
2. 漏洞具备的能力

攻击者能够覆盖0x580大小的堆块，能够控制函数指针和参数。

## 四、漏洞利用关键技术

### 1. 内核定时器

用于完成定时任务，通常使用init_timer(timer)初始化struct timer_list对象；

void add_timer_on(struct timer_list *timer, int cpu)将定时器对象绑定某个cpu；

int del_timer(struct timer_list *timer)删除定时器；

int mod_timer(struct timer_list *timer, unsigned long expires)重新设置超时。

![截屏2024-09-24 11.06.02.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/10.png)

攻击者通过堆喷射覆盖已释放的套接字对象中的定时器对象，篡改function和data成员。定时器超时后内核以function(data)的方式调用超时函数，实现控制流劫持。

### 2. vsyscall页面

vsyscall是一种加快系统调用速度的机制，某些系统调用将在用户空间下执行，这意味着将不发生上下文切换，以减小系统开销。

Linux内核在用户空间映射一个包含一些变量及一些系统调用的实现的内存页，范围如下：

![截屏2024-09-24 13.58.23.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/11.png)

它的实现原理是将内核代码段固定的页面__vsyscall_page映射到用户空间0xffffffffff600000～0xffffffffff601000。

![截屏2024-09-24 14.07.23.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/12.png)

攻击者劫持控制流之后调用内核函数set_memory_rw将vsyscall页面属性修改成允许读写，攻击者可在用户态直接修改vsyscall页面内容，将payload保存在vsyscall页面。

### 3. add_key()堆喷射

效果：喷射大小不超过0x8000大小的堆块，堆块头部0x12大小的部分为元数据，偏移0x12往后的内容攻击者可控。

![截屏2024-09-24 20.10.46.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/13.png)

用户态函数接口为：

```c
#include <keyutils.h>

// type通常设置为“user”
// description为长度不超过4096的任意字符串
// payload为攻击载荷
// plen设置为payload的长度
// keyring设置为-2
key_serial_t add_key(const char *type, const char *description,
                     const void *payload, size_t plen,
                     key_serial_t keyring);
```

进入到内核，payload头部会被加上struct user_key_payload类型的数据头部。

![截屏2024-09-24 20.08.20.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/14.png)

攻击者可控的数据从偏移0x12开始。

![exp.c-第 7 页.jpg](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/15.jpg)

攻击者调用add_key()大量喷射长度为0x580的堆块，占用已被释放的packet套接字对象，覆盖定时器对象的function和data字段。

### 4. /proc/sys文件系统

/proc/sys目录提供了系统运行状态下热配置内核的方法。管理员读写该目录下的文件可以实现对内核配置的读取和写入，而且会立即生效。

register_sysctl_table()函数用于在/proc/sys目录下导出内核配置选项，接收一个struct ctl_table对象指针为参数。

![截屏2024-09-24 20.27.54.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/16.png)

struct ctl_table配置了导出文件的属性。其中data指向需要被修改的内核变量，maxlen写入的最大长度，mode设置文件权限，通常设置为0666以便user权限的攻击者能够读写，proc_handler设置成proc_dostring函数的地址，用于将字符串写入data指向的变量。

```c
struct ctl_table 
{
	const char *procname;		//   /proc/sys/目录下的文件名称
	void *data;             /*  内核中要修改的地址 */ 
	int maxlen;             /*  写入内容的最大长度 */
	umode_t mode;           /*  文件访问权限，设置成0666 */
	struct ctl_table *child;	/* 设置成NULL */
	proc_handler *proc_handler;	/* 设置成proc_dostring函数地址 */
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};
```

攻击者劫持控制流之后首先调用内核函数set_memory_rw(0xffffffffff600000)修改vsyscall页面为可读可写。

从用户态往vsyscall页面写入struct ctl_table内容，再次触发漏洞劫持控制流执行内核函数register_sysctl_table(0xffffffffff600000)，生成user权限可读可写的/proc/sys/hack文件，导出对内核全局变量modprobe_path的配置接口。

Linux本身有一个/proc/sys/kernel/modprobe文件用于配置modprobe_path，但是需要root权限。

### 5. modprobe_path内核全局变量

内核全局变量modprobe_path保存了驱动加载工具的全限定路径，默认是/sbin/modprobe。

作用是当内核调用request_module()函数发起从用户态加载内核模块的请求时，从modprobe_path指定的路径调用modprobe程序。相当于直接从内核态发起文件执行，产生的进程euid=0，uid=0，完全是root权限，由此实现权限提升。

![截屏2024-09-24 19.32.52.png](/assets/posts/2024-09-25-cve-2016-8655-AF_PACKET套接字的条件竞争漏洞分析/17.png)

## 五、漏洞利用过程

1. 第一次触发漏洞
    1. 设置两个线程，线程1配置TPACKET_V3的接收缓冲区，线程2修改版本号为TPACKET_V1，线程入口处设置屏障卡住；
    2. 解除屏障，2个线程开始竞争；
    3. 竞争成功，调用add_key()系统调用喷射堆块占位，修改定时器函数set_memory_rw，data为vsyscall页面地址；
    4. 定时器超时，触发set_memory_rw函数，vsyscall页面被修改为可读可写；
2. 第二次触发漏洞
    1. vsyscall页面写入struct ctl_table对象；
    2. 条件竞争；
    3. 竞争成功，调用add_key()堆喷射堆块占位，修改定时器函数为register_sysctl_table，data为vsyscall页面地址；
    4. 定时器超时，触发register_sysctl_table函数，生成权限为0666的/proc/sys/hack文件；
3. 起root shell
    1. 将exp路径写入/proc/sys/hack文件，修改modprobe_path指向exp；
    2. 向socket系统调用传入一个内核无法解析的协议类型，内核调用request_module()，以root身份调用exp；
    3. exp自带提权操作，设置exp文件归属于root用户root组，赋予exp文件S位权限；

## 六、漏洞挖掘点

1. 修改公共资源之前应该上锁。公共资源指的是可以在多进程/线程之间共享的资源，包括但不限于内核全局对象、分配在内核堆上面的对象。
2. 上一个发现的内核漏洞也是蓝牙模块里面条件竞争引起的套接字定时器释放后重引用。对上面第一条缩小范围，我们可以研究网络接口里面关于定时器销毁的部分，关注一下是否存在套接字释放了而定时器还未销毁的情况。