---
layout: post
title:  "蓝牙sco条件竞争漏洞挖掘与利用"
date:   2023-02-11 13:27:38 +0800
category: linux_kernel
---


8 个月之前 Linux 主线中已经修补了这个漏洞，在上一个版本的 Ubuntu 20.04 这个漏洞还未修补，而且这些设备不一定会更新到最新版本的内核，如果是国产操作系统的话，内核的更新尤为滞后，所以我们认为这个漏洞有搞头。
linux 内核漏洞修补不一定有 cve 号，可能开发人员看到测到就修了，那么没事看看 diff 也是一种捡漏洞的方法，毕竟除了 ctf 题目，目标不可能是最新版linux。

# 时间线

- 2023年 1 月 17 日使用 syzkaller 对蓝牙驱动进行 fuzz；
- 2023 年 1 月 22 日触发了 UAF ；
- 2023年 4 月 17 日完成漏洞利用。

从syzkaller的崩溃日志可以看出，漏洞位于 bluetoot.ko 文件 sco_sock_timeout 函数的 struct sock 对象。

```c
[ 1198.222242] BUG: KASAN: use-after-free in sco_sock_timeout+0x246/0x270
[ 1198.222865] Read of size 1 at addr ffff88812580b012 by task kworker/3:2/277

[ 1198.223677] CPU: 3 PID: 277 Comm: kworker/3:2 Not tainted 5.15.0 #18
[ 1198.224280] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
[ 1198.225068] Workqueue: events sco_sock_timeout
[ 1198.225498] Call Trace:
[ 1198.225744]  dump_stack_lvl+0x8b/0xb3
[ 1198.226112]  print_address_description.constprop.0+0x1f/0x140
[ 1198.226674]  ? sco_sock_timeout+0x246/0x270
[ 1198.227078]  kasan_report.cold+0x7f/0x11b
[ 1198.227479]  ? sco_sock_timeout+0x246/0x270
[ 1198.227892]  sco_sock_timeout+0x246/0x270
[ 1198.228292]  process_one_work+0xa40/0x1670
[ 1198.228698]  ? pwq_dec_nr_in_flight+0x2a0/0x2a0
[ 1198.229143]  ? rwlock_bug.part.0+0x90/0x90
[ 1198.229560]  worker_thread+0x62a/0x13e0
[ 1198.229940]  ? __kthread_parkme+0x126/0x1f0
[ 1198.230358]  ? process_one_work+0x1670/0x1670
[ 1198.230788]  kthread+0x3c3/0x4a0
[ 1198.231104]  ? _raw_spin_unlock_irq+0x1f/0x30
[ 1198.231524]  ? set_kthread_struct+0x130/0x130
[ 1198.231953]  ret_from_fork+0x22/0x30

[ 1198.232484] Allocated by task 13663:
[ 1198.232826]  kasan_save_stack+0x1b/0x40
[ 1198.233192]  __kasan_kmalloc+0x7c/0x90
[ 1198.233555]  sk_prot_alloc+0x11d/0x290
[ 1198.233922]  sk_alloc+0x30/0x360
[ 1198.234240]  sco_sock_alloc.constprop.0+0x31/0x220
[ 1198.234700]  sco_sock_create+0xd5/0x170
[ 1198.235065]  bt_sock_create+0x159/0x2b0
[ 1198.235435]  __sock_create+0x355/0x760
[ 1198.235799]  __sys_socket+0xef/0x200
[ 1198.236143]  __x64_sys_socket+0x6e/0xb0
[ 1198.236520]  do_syscall_64+0x3b/0x90
[ 1198.236865]  entry_SYSCALL_64_after_hwframe+0x44/0xae

[ 1198.237504] Freed by task 13663:
[ 1198.237815]  kasan_save_stack+0x1b/0x40
[ 1198.238191]  kasan_set_track+0x1c/0x30
[ 1198.238554]  kasan_set_free_info+0x20/0x30
[ 1198.238956]  __kasan_slab_free+0xec/0x120
[ 1198.239340]  kfree+0xca/0x480
[ 1198.239636]  __sk_destruct+0x5f5/0x740
[ 1198.239997]  sk_destruct+0xbd/0xe0
[ 1198.240333]  __sk_free+0xed/0x3d0
[ 1198.240651]  sk_free+0x78/0xa0
[ 1198.240941]  sco_sock_kill+0x16d/0x1a0
[ 1198.241294]  sco_sock_release+0x1ed/0x360
[ 1198.241667]  __sock_release+0xd2/0x290
[ 1198.242020]  sock_close+0x18/0x20
[ 1198.242336]  __fput+0x283/0x9e0
[ 1198.242643]  task_work_run+0xe2/0x1a0
[ 1198.242997]  get_signal+0x1aab/0x20a0
[ 1198.243354]  arch_do_signal_or_restart+0x2b0/0x16e0
[ 1198.243819]  exit_to_user_mode_prepare+0x141/0x1d0
[ 1198.244282]  syscall_exit_to_user_mode+0x19/0x50
[ 1198.244720]  do_syscall_64+0x48/0x90
[ 1198.245064]  entry_SYSCALL_64_after_hwframe+0x44/0xae

[ 1198.245694] The buggy address belongs to the object at ffff88812580b000
                which belongs to the cache kmalloc-2k of size 2048
[ 1198.246831] The buggy address is located 18 bytes inside of
                2048-byte region [ffff88812580b000, ffff88812580b800)
[ 1198.247908] The buggy address belongs to the page:
[ 1198.248366] page:00000000fd6372df refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x125808
[ 1198.249235] head:00000000fd6372df order:3 compound_mapcount:0 compound_pincount:0
[ 1198.249923] flags: 0x200000000010200(slab|head|node=0|zone=2)
[ 1198.250474] raw: 0200000000010200 dead000000000100 dead000000000122 ffff888100042f00
[ 1198.251179] raw: 0000000000000000 0000000000080008 00000001ffffffff 0000000000000000
[ 1198.251893] page dumped because: kasan: bad access detected

[ 1198.252571] Memory state around the buggy address:
[ 1198.253024]  ffff88812580af00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[ 1198.253681]  ffff88812580af80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
[ 1198.254341] >ffff88812580b000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[ 1198.254997]                          ^
[ 1198.255359]  ffff88812580b080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[ 1198.256027]  ffff88812580b100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
[ 1198.256690] ==================================================================
[ 1198.257349] Disabling lock debugging due to kernel taint
[ 1198.257882] Bluetooth: sock 000000006ae68011 state 9
[ 1198.257894] ------------[ cut here ]------------
[ 1198.258343] refcount_t: addition on 0; use-after-free.
[ 1198.258878] WARNING: CPU: 3 PID: 277 at lib/refcount.c:25 refcount_warn_saturate+0x178/0x1f0
[ 1198.259687] Modules linked in:
[ 1198.259985] CPU: 3 PID: 277 Comm: kworker/3:2 Tainted: G    B             5.15.0 #18
[ 1198.260732] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
[ 1198.261515] Workqueue: events sco_sock_timeout
[ 1198.261938] RIP: 0010:refcount_warn_saturate+0x178/0x1f0
[ 1198.262449] Code: 04 31 ff 89 de e8 38 14 f0 fe 84 db 0f 85 2e ff ff ff e8 8b 0c f0 fe 48 c7 c7 a0 99 a6 85 c6 05 27 38 ff 04 01 e8 c2 71 ae 02 <0f> 0b e9 0f ff ff ff e8 6c 0c f0 fe 0f b6 1d 11 38 ff 04 31 ff 89
[ 1198.264188] RSP: 0018:ffff888123e1fcd8 EFLAGS: 00010286
[ 1198.264673] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000
[ 1198.265355] RDX: ffff88811eef3200 RSI: ffffffff814bf4b8 RDI: ffffed10247c3f8d
[ 1198.266007] RBP: ffff88812580b080 R08: 0000000000000001 R09: 0000000000000000
[ 1198.266678] R10: ffffffff8170403f R11: 0000000000000000 R12: ffff8881213b3e08
[ 1198.267370] R13: ffff88812580b080 R14: ffff8883aeaf0300 R15: ffff888118f19000
[ 1198.268033] FS:  0000000000000000(0000) GS:ffff8883aeac0000(0000) knlGS:0000000000000000
[ 1198.268812] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 1198.269375] CR2: 00007ffe087b2000 CR3: 0000000100f92000 CR4: 00000000000006e0
[ 1198.270030] Call Trace:
[ 1198.270292]  sco_sock_timeout+0x208/0x270
[ 1198.270675]  process_one_work+0xa40/0x1670
[ 1198.271065]  ? pwq_dec_nr_in_flight+0x2a0/0x2a0
[ 1198.271523]  ? rwlock_bug.part.0+0x90/0x90
[ 1198.271921]  worker_thread+0x62a/0x13e0
[ 1198.272328]  ? __kthread_parkme+0x126/0x1f0
[ 1198.272734]  ? process_one_work+0x1670/0x1670
[ 1198.273178]  kthread+0x3c3/0x4a0
[ 1198.273493]  ? _raw_spin_unlock_irq+0x1f/0x30
[ 1198.273915]  ? set_kthread_struct+0x130/0x130
[ 1198.274361]  ret_from_fork+0x22/0x30
[ 1198.274712] irq event stamp: 32262
[ 1198.275037] hardirqs last  enabled at (32261): [<ffffffff8538d5ef>] _raw_spin_unlock_irq+0x1f/0x30
[ 1198.275883] hardirqs last disabled at (32262): [<ffffffff8538d44b>] _raw_spin_lock_irqsave+0x4b/0x50
[ 1198.276760] softirqs last  enabled at (32256): [<ffffffff841cd494>] update_defense_level+0xa94/0x1110
[ 1198.277637] softirqs last disabled at (32254): [<ffffffff841ccaa9>] update_defense_level+0xa9/0x1110
[ 1198.278505] ---[ end trace 58deb9f77f47f936 ]---
[ 1198.278942] ------------[ cut here ]------------
[ 1198.279387] refcount_t: underflow; use-after-free.
[ 1198.279898] WARNING: CPU: 3 PID: 277 at lib/refcount.c:28 refcount_warn_saturate+0x103/0x1f0
[ 1198.280712] Modules linked in:
[ 1198.281001] CPU: 3 PID: 277 Comm: kworker/3:2 Tainted: G    B   W         5.15.0 #18
[ 1198.281738] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
[ 1198.282519] Workqueue: events sco_sock_timeout
[ 1198.282941] RIP: 0010:refcount_warn_saturate+0x103/0x1f0
[ 1198.283456] Code: 1d bb 38 ff 04 31 ff 89 de e8 a9 14 f0 fe 84 db 75 a3 e8 00 0d f0 fe 48 c7 c7 00 9a a6 85 c6 05 9b 38 ff 04 01 e8 37 72 ae 02 <0f> 0b eb 87 e8 e4 0c f0 fe 0f b6 1d 84 38 ff 04 31 ff 89 de e8 74
[ 1198.285172] RSP: 0018:ffff888123e1fcd8 EFLAGS: 00010286
[ 1198.285655] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000
[ 1198.286327] RDX: ffff88811eef3200 RSI: ffffffff814bf4b8 RDI: ffffed10247c3f8d
[ 1198.286984] RBP: ffff88812580b080 R08: 0000000000000001 R09: 0000000000000000
[ 1198.287666] R10: ffffffff8170403f R11: 0000000000000000 R12: ffff8881213b3e08
[ 1198.288346] R13: ffff88812580b080 R14: ffff8883aeaf0300 R15: ffff888118f19000
[ 1198.289006] FS:  0000000000000000(0000) GS:ffff8883aeac0000(0000) knlGS:0000000000000000
[ 1198.289777] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[ 1198.290339] CR2: 00007ffe087b2000 CR3: 0000000100f92000 CR4: 00000000000006e0
[ 1198.291007] Call Trace:
[ 1198.291262]  sco_sock_timeout+0x21f/0x270
[ 1198.291648]  process_one_work+0xa40/0x1670
[ 1198.292050]  ? pwq_dec_nr_in_flight+0x2a0/0x2a0
[ 1198.292509]  ? rwlock_bug.part.0+0x90/0x90
[ 1198.292902]  worker_thread+0x62a/0x13e0
[ 1198.293305]  ? __kthread_parkme+0x126/0x1f0
[ 1198.293706]  ? process_one_work+0x1670/0x1670
[ 1198.294140]  kthread+0x3c3/0x4a0
[ 1198.294456]  ? _raw_spin_unlock_irq+0x1f/0x30
[ 1198.294866]  ? set_kthread_struct+0x130/0x130
[ 1198.295300]  ret_from_fork+0x22/0x30
```

实际上在 fuzz 的第二天便测出了这个崩溃，但 syzkaller 一直无法回归出到底是哪个样本导致的崩溃，于是需要对测试用例进行手工排查。

经过排查发现触发 UAF 的原因是两个线程几乎同时 connect 进去，盲猜是加锁操作不当导致的条件竞争漏洞。

```c
13:36:50 executing program 1:
r0 = syz_init_net_socket$bt_sco(0x1f, 0x5, 0x2) (async)
connect$bt_sco(0xffffffffffffffff, &(0x7f0000000040)={0x1f, @none}, 0x8)
connect$bt_sco(r0, &(0x7f0000000000)={0x1f, @fixed={'\xaa\xaa\xaa\xaa\xaa', 0x11}}, 0x8)
```

# 提交历史

拿到崩溃信息的第一时间，我就联系 [**王宇轩**](https://xuanxuanblingbling.github.io/) 一起加入分析。

查找 Linux 内核仓库的提交记录发现，这个漏洞早在 2022 年 5 月 13 日就已经被官方修补了，早了我们 8 个月。

![1.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/1.png)

官方的修补方法是把 connect 函数的套接字锁提前：

![15.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/15.png)

经过多个 Ubuntu 版本的对比发现，这个漏洞在最新的 Ubuntu 22.04 中已经被修补，内核版本是 5.15.0-50

![31.jpg](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/31.jpg)

![32.jpg](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/32.jpg)

在上一个版本的 Ubuntu 20.04 这个漏洞还未修补，内核版本是 5.15.0-46

![35.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/35.png)

考虑到还有大量的设备在运行 Ubuntu 20.04，而且这些设备不一定会更新到最新版本的内核，如果是国产操作系统的话，内核的更新尤为滞后，所以我们认为这个漏洞有搞头，可以继续深入分析。

# 漏洞分析

内核版本：5.15.0-46，使用 Ubuntu 20.04 默认的 .config 文件编译。

正常情况下，当 connect 成功之后，sock::sk_state 会标记为 BT_CONNECTED，这样就可以防止其他线程再次试图 connect。

但是把 lock_sock 放在了状态检查之后，就会导致在 sock::sk_state 更改之前，两个线程同时通过状态检查，在后续造成不确定的状态。

![3.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/3.png)

如果有两个 connect1 和 connect2 线程同时对一个蓝牙套接字进行 connect 操作，并且两个线程都绕过了状态检查，那么这两个线程就都保持了对内核套接字 sock 的引用。

若对套接字进行 close 操作，那么内核套接字 sock 就会被释放掉。

![4.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/4.png)

注意到 connect1 和 connect2 线程会先后在 sco_sock_connect 函数中进入临界区

![5.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/5.png)

每进一次临界区都会调用 sco_conn_add 函数注册延迟任务 timeout_work，而 timeout_work 对象的根结点就是内核套接字 sock，也就是延迟任务是与内核套接字 sock 绑定的。

![6.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/6.png)

第二个进入临界区的 connect2 线程会注册新的延迟任务，覆盖掉前一个 connect1 线程注册的延迟任务，那么 connect1 线程的延迟任务就会成为孤儿线程，游荡在内核中，无法被取消，但在未来的某个时间点会运行……

这就会造成很大的麻烦，在 close 掉蓝牙套接字的时候，内核套接字 sock 会被释放掉，connect2 线程注册的延迟任务也会被注销。connect1 线程注册的延迟任务此时已经变成了孤儿线程，但还保持着对内核套接字 sock 的引用，在延迟 40 秒后触发了 UAF。这一点与我们测试 poc 是一致的，poc 也是在大约 40 秒后触发了 UAF。

![7.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/7.png)

实际上在进入 sco_sock_connect 临界区里面之后，sco_conn_add 函数中注册了延迟任务只是 sco 协议层面的，根据底层蓝牙硬件的不同，例如底层用的是 usb 蓝牙适配器，bt_usb 驱动层会注册 usb 驱动层面的延迟任务。usb 驱动层面的延迟任务最终也会引用到内核套接字 soc 造成 UAF。

![8.jpg](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/8.jpg)

实测发现有时候确实会报两次 UAF 的 kernel warning，而且从 usb 驱动层造成的 UAF 比 sco 层造成的 UAF 要快，毕竟后者要等待 40 秒才能触发。

# 漏洞利用

利用条件是关闭 KASLR，虽然有两次 UAF 的机会可以用，按道理可以利用第一次 UAF 打一个内核指针泄漏，但是经常是第一次 UAF 之后蓝牙协议栈就失效了，所以这里关闭 KASLR，等后面发现信息泄漏的漏洞再回来看。

注意到在漏洞触发函数中，有对内核套接字 sock 函数指针成员的调用，因此利用思路就是在 close 之后通过堆喷射占位内核套接字对象，劫持函数指针 sk_state_change 达到控制流劫持的目的。

![2.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/2.png)

在堆喷射开始之前准备了 1024 个堆喷射线程，一旦内核套接字对象 sock 被释放，立即开始对喷占位。

![9.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/9.png)

堆喷射用的是 fuse + setxattr 方法，目标是把 sk_state_change 位置覆盖为内核函数 run_cmd 的地址，该函数可以从内核空间以 root 的身份标识执行用户态程序。

![10.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/10.png)

最终成功提权：

![截屏2023-04-17 22.31.37.png](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/%E6%88%AA%E5%B1%8F2023-04-17_22.31.37.png)

# 横向挖掘

在一年后的  2024 年 11 月份，我又在蓝牙 sco 中发现了一个类似漏洞，详见 [**蓝牙 sco 条件竞争漏洞挖掘与分析**](https://qiutianshu.github.io/linux_kernel/2025/01/18/%E8%93%9D%E7%89%99sco%E9%A9%B1%E5%8A%A8%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98.html)

所以linux内核漏洞修补不一定有cve号，可能开发人员看到测到就修了，那么没事看看 diff 也是一种捡漏洞的方法，毕竟除了ctf题目，目标不可能是最新版linux。

# 附件

[exploit.zip](/assets/posts/2023-02-11-蓝牙sco条件竞争漏洞挖掘与利用/exploit.zip)