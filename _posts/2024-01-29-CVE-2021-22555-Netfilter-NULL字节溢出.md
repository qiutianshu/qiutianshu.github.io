---
layout: post
title:  "CVE-2021-22555 Netfilter NULL字节溢出"
date:   2024-01-29 13:27:38 +0800
category: linux_kernel
---
CVE-2021-22555 是一个潜伏长达15年、影响极其深远的Linux内核漏洞。该漏洞源于 Linux 内核 Netfilter 子系统在处理 32 位与 64 位系统架构转换时，一个关键的堆内存操作发生整数溢出，进而触发堆越界写。攻击者可利用此漏洞实现本地权限提升。

## 一、环境搭建

内核版本：Linux-5.11.14

编译选项：

```c
CONFIG_USER_NS=y
CONFIG_NET_NS=y
CONFIG_COMPAT=y
CONFIG_IP_NF_IPTABLES=y   		// /net/ipv4/netfilter/ip_tables.c
CONFIG_IP_NF_FILTER=y
CONFIG_IP_NF_MANGLE=y
CONFIG_IP_NF_NAT=y
CONFIG_IP_NF_RAW=y
CONFIG_IP_NF_SECURITY=y
CONFIG_IP_NF_**=y
    
CONFIG_NETFILTER_NETLINK=y
CONFIG_NETFILTER_XTABLES=y		// /net/netfilter/x_tables.c
CONFIG_NETFILTER_XT_MATCH_U32=y
CONFIG_NETFILTER_**=y

CONFIG_E1000=y
CONFIG_E1000E=y
```

## 二、Netfilter机制

Natfilter是集成到linux内核协议栈中的一套防火墙系统，用户可通过运行在用户空间的工具iptables对Netfilter进行配置。

根据防火墙的功能，netfilter存储了四张表：

- filter表对报文进行过滤
- mangle表对报文进行修改
- connect track表对会话连接进行跟踪
- NAT表对报文进行地址转换

每张表包含了多个拦截点，表示对报文进行处理的位置.Linux网络协议栈对ipv4报文的拦截点有五个：

- PREROUTING报文刚进入主机路由之前
- INPUT发送给本机的报文经过路由之后
- FORWARD需要本机进行转发报文
- OUTPUT本机生成的报文
- POSTROUTING本机生成的报文在路由之后

![26517122_1400772510sX44.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/26517122_1400772510sX44.jpg)

每个拦截点内包含若干规则，规则是由“匹配规则match”和“执行动作target”组成的键值对。如果报文和规则匹配，则执行对应的target处理报文。

![CVE-2021-22555-第 3 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/1.jpg)

表和拦截点的关系：

| **表/拦截点** | **PREROUTING** | **INPUT** | **FORWARD** | **OUTPUT** | **POSTROUTING** |
| --- | --- | --- | --- | --- | --- |
| **raw** |             ✓ |  |  |            ✓ |  |
| **filter** |  |            ✓ |            ✓ |            ✓ |  |
| **mangle** |            ✓ |            ✓ |            ✓ |            ✓ |                ✓ |
| **nat** |            ✓ |  |  |            ✓ |  |

每个拦截点内部包含若干“match-target“对：

![截屏2024-01-24 13.25.06.png](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/2.png)

主机接收到数据包后依次处理PREROUTING、INPUT、FORWARD、OUTPUT、POSTING拦截点内的“match-target”键值对。由于同时存在多张表，每个表内都配置了相关的拦截点，处理拦截点按照raw、filter、mangle、nat表的顺序依次处理。

应用层与Netfilter的通信：

用户调用socket系统调用创建一个tcp套接字，socket系统调用内部调用inet_create和tcp_v4_init_sock初始化了底层IP层的操作函数setsockopt和getsockopt。

![未命名绘图-第 1 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/3.jpg)

用户空间使用setsockopt对netfilter进行配置，使用getsockopt获取netfilter的配置信息。系统启动时加载内核模块完成了ipv4 netfilter的注册。使用setsockopt配置ipv4 netfilter时需要用户有CAP_NET_ADMIN权限，使用nf_sockopt_find函数找到已经注册的ipv4 netfilter，再调用ipv4 netfilter配置函数do_ipt_set_ctl对具体的”表-拦截点-规则“进行配置。

![setsockopt-getsockopt.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/4.jpg)

## 三、漏洞分析

漏洞发生在netfilter对用户空间传递到内核的防火墙规则进行拷贝时，调用xt_compat_target_from_user函数发生越界写0。漏洞触发需要CAP_NET_ADMIN权限，普通用户不具备，但是可以通过unshare新的user namespace和network namespace获取该权限。

函数调用链为：

do_ipt_set_ctl -> compat_do_replace -> translate_compat_table -> compat_copy_entry_from_user → xt_compat_target_from_user

![截屏2024-01-24 16.24.56.png](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/5.png)

调用memset将xt_entry_target→data指向的缓冲区进行8字节对齐，不足8字节的空间清零。若t→data + target→targetsize + pad超出堆块边界那么会导致越界写0。

![截屏2024-01-24 16.29.11.png](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/6.png)

现在需要知道的是t→data指向的缓冲区大小是多少、target→targetsize是多少，以此判断是否会越界。

数据拷贝流程：

![未命名绘图-netfilter.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/7.jpg)

当调用setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, &data, sizeof(data))时：

1. compat_do_replace()将data.ipt_replace从拷贝到内核，再调用translate_compat_table()拷贝剩下的部分
2. translate_compat_table()对传进来的规则进行检查，调用newinfo=xt_alloc_table_info(size)分配堆块存储data剩余的entry、match、pad和target，参数size等于四个部分加起来的大小。问题在于size完全由攻击者控制，且不包含target→data[]数组的长度。
3. 调用compat_copy_entry_from_user()将entry、match、pad、target拷贝到newinfo→entries数组，entries数组在newinfo中的偏移为0x40

![截屏2024-01-24 21.32.55.png](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/8.png)

1. sizeof(struct ipt_entry) = 0x70，拷贝完entry，destptr = newinfo + 0xb0
2. sizeof(struct xt_entry_match) = 0x20，这一步会拷贝match、pad和额外的4字节用于对齐，结束后destptr = newinfo + 0xd4 + sizeof(pad)
3. sizeof(struct xt_entry_target) = 0x20，在xt_compat_target_from_user函数中会拷贝target到newinfo，拷贝完成后destptr = newinfo + 0xf4 + sizeof(pad)
4. target→targetsize是struct xt_entry_target结构体中data数组的长度，并未算到分配newinfo的大小之中。

![截屏2024-01-24 16.24.56.png](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/5.png)

若pad数组取合适的大小，将entry正好复制到newinfo堆块的边界，那么memset就会向相邻的堆块溢出若干0字节。

![未命名绘图-第 4 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/9.jpg)

溢出的长度由用户传入的data.pad数组长度、target结构体大小共同决定。data.pad的长度决定了开始溢出的位置，target→targetsize决定了溢出的长度

target结构体由data.target.u.user.name字段和data.target.u.user.reversion字段共同决定：

![截屏2024-01-24 23.32.29.png](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/10.png)

struct xt_entry_target是一个用户态和内核态共用的结构体，在用户态设置u.user.name和reversion字段，进入到内核后经过如下调用链找到由其他防火墙模块注册的target对象：

do_ipt_set_ctl -> compat_do_replace -> translate_compat_table -> check_compat_entry_size_and_hooks → xt_request_find_target → xt_find_target

![截屏2024-01-24 23.37.18.png](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/11.png)

回到check_compat_entry_size_and_hooks函数中，再将查找到的target对象地址赋值给struct xt_entry_target.u.kernel.target。

![截屏2024-01-25 00.07.20.png](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/12.png)

当[data.target.u.user.name](http://data.target.u.user.name/)="NFQUEUE"，data.target.u.user.revision = 1时，对应的target→targetsize = 4， pad=4，即可以溢出对象8个NULL字节。

攻击者调整[data.target.u.user.name](http://data.target.u.user.name/)和reversion字段可以控制xt_request_find_target()返回的target对象，间接控制了target→targetsize和对齐的字节数。

合理安排data.pad数组的长度，可以控制覆盖相邻堆块的长度。

覆盖太多的NULL字节会得到非法地址，例如将指针0xffffdeaddeadde00覆盖成0xdeadde00或者0xffffdead00000000。比较好的选择是覆盖2个字节为NULL，得到0xffffdeaddead0000，确保覆盖之后的指针还是合法地址。

漏洞能力总结如下：

1. 漏洞对象大小：大于0x40，分配标志GFP_KERNEL_ACCOUNT
2. 溢出长度：攻击者可控，最大不超过0x4C（当data.target.u.user.name="NFQUEUE"，reversion=1时）
3. 溢出内容：NULL字节，攻击者不可控

Linux 5.14版本之前，kmalloc分配标志为GFP_KERNEL_ACCOUNT的堆块分配在kmalloc-xxx通用缓存中

## 四、Capabilities机制名和命名空间机制

As we noted in an earlier article, one of the motivations for implementing user namespaces is to give non-root applications access to functionality that was formerly limited to the root user. In traditional UNIX systems, various pieces of functionality have been limited to the root user in order to prevent unprivileged users from manipulating the runtime environment of privileged programs, which could affect the operation of those programs in unexpected or undesirable ways.
A user namespace allows a process (that is unprivileged outside the namespace) to have root privileges while at the same time limiting the scope of that privilege to the namespace, with the result that the process cannot manipulate the runtime environment of privileged programs in the wider system. In order to use these root privileges meaningfully, we need to combine user namespaces with other types of namespaces—that topic will form the subject of the next article in this series.
Creating namespaces other than user namespaces requires the CAP_SYS_ADMIN capability. On the other hand, creating a user namespace requires (since Linux 3.8) no capabilities, and the first process in the namespace gains a full set of capabilities (in the new user namespace). This means that that process can now create any other type of namespace using a second call to clone().

When a user namespace is created, the first process in the namespace is granted a full set of capabilities in the namespace. This allows that process to perform any initializations that are necessary in the namespace before other processes are created in the namespace.

There is one other important point worth noting that can't be gleaned from the output above. Although the new process has a full set of capabilities in the new user namespace, it has no capabilities in the parent namespace. This is true regardless of the credentials and capabilities of the process that calls clone(). In particular, even if root employs clone(CLONE_NEWUSER), the resulting child process will have no capabilities in the parent namespace.

```c
temp = open("/proc/self/setgroups", O_WRONLY);
write(temp, "deny", strlen("deny"));
close(temp);
```

****

For example, suppose that we create a new user namespace using clone(CLONE_NEWUSER). The resulting child process will have a full set of capabilities in the new user namespace, which means that it will, for example, be able to create other types of namespaces and be able to change its user and group IDs to other IDs that are mapped in the namespace. (In the previous article in this series, we saw that only a privileged process in the *parent* user namespace can create mappings to IDs other than the effective user and group ID of the process that created the namespace, so there is no security loophole here.)

On the other hand, the child process would not be able to mount a filesystem. The child process is still in the initial mount namespace, and in order to mount a filesystem in that namespace, it would need to have capabilities in the user namespace associated with that mount namespace (i.e., it would need capabilities in the initial user namespace), which it does not have. Analogous statements apply for the global resources isolated by IPC, network, PID, and UTS namespaces.

if ((ns->parent == cred->user_ns) && uid_eq(ns->owner, cred->euid))
return 0;

实际上 `root` 用户拥有最高特权早就成了过去式，Linux 内核在 2.2 版本就引入了一种新的权限检查机制 - capabilities。

为了适应更复杂的权限需求，从 2.2 版本起 Linux 内核能够进一步将超级用户的权限分解为细颗粒度的单元，这些单元称为 capabilities。例如，capability `CAP_CHOWN` 允许用户对文件的 UID 和 GID 进行任意修改，即执行 `chown` 命令。几乎所有与超级用户相关的特权都被分解成了单独的 capability。

capabilities 的引入有以下好处：

- 从超级用户的权限中移除部分 capability 以削弱其权限，提高系统的安全性。
- 可以根据需求非常精准地向普通用户授予部分特殊权限。

## 五、漏洞利用

目标：将有限的越界写转化为UAF，提升对内存的控制能力

思路1：把某个victim object的引用计数器覆盖为0，导致victim obj异步释放掉，构造UAF

思路2：覆盖victim object内部的对象指针使之指向其他内核路径上正在使用的对象，释放victim obj导致正在使用的对象被释放，构造UAF

![未命名绘图-第 5 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/13.jpg)

利用过程：

1. 调用msgget()创建4096个消息队列
2. 填充4096个主消息，消息大小为0x1000，以得到一个整齐的空间布局，使`msg_msg`结构体尽可能相邻
3. 为每个消息队列添加次消息，消息大小为0x400，消息标识与主消息对应

![未命名绘图-第 6 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/14.jpg)

1. 释放第1024、2048、3072个主消息，获得三个0x1000内存空洞，调用setsockopt(IPT_SO_SET_REPLACE)分配struct xt_table_info结构体占住空洞，并将相邻主消息的next指针低2字节覆盖为\x00\x00。这种情况下覆盖next指针重新指向另一个次消息的概率为1-(1024/65536)，失败的唯一情况是覆盖之前next指针的低2字节也是\x00\x00，覆盖前后next指向不变

![未命名绘图-第 7 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/15.jpg)

1. 通过被覆盖的主消息释放正在使用的次消息

![未命名绘图-第 7 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/16.jpg)

1. 调用socketpair()堆喷skb消息内容占据被释放的次消息，构造fake_msg扩大m_ts字段，造成对msg0-2的UAF

![未命名绘图-第 7 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/17.jpg)

1. 读取msg_queue0上的次消息，由于m_ts字段被skb消息扩大，所以越界读取msg1-2→next字段。msg1-2→next指向主消息msg1-1的next字段，所以泄漏了msg1-1的地址。

![未命名绘图-第 7 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/18.jpg)

1. 读取skb消息释放skb消息堆块，再次调用socketpair()堆喷skb消息堆块，再次占位次消息，构造fake_msg修改msg→next字段为msg1-1的地址。
2. 读取msg_queue0上的次消息，由于next字段指向msg1-1，所以泄漏了msg1-1→next指针，该指针指向msg1-2，所以msg1-2的地址泄漏
3. msg1-2地址减去0x400得到次消息msg0-2的地址，也即是发生UAF堆块的地址
4. 重新释放skb消息，再调用socketpair()占位msg0-2，修复msg0-2的next和prev指针指向msg0-2本身。再次从msg_queue0读取msg0-2，将msg0-2释放，此时的msg0-2堆块仍然被sk_buf引用

![未命名绘图-第 7 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/19.jpg)

1. 调用pipe()系统调用堆喷struct pipe_buffer结构体，内核会分配0x400大小的堆块用于保存16个struct pipe_buffer结构体，重新占回msg0-2，再次构造了UAF

![截屏2024-01-25 21.41.52.png](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/20.png)

![未命名绘图-第 7 页.jpg](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/21.jpg)

1. 由于pipe_buffer仍然被sk_buf引用，再次读取sk_buf可以泄漏pipe_buffer对象的ops指针，该指针指向内核数据段对象anon_pipe_buf_ops，泄漏内核地址绕过KASLR
2. 读取sk_buf释放msg0-2，再次调用socketpair()占位msg0-2，在msg0-2中构造ROP并且将pipe_buffer.ops指向ROP链。关闭pipe触发ROP链，实现控制流劫持和栈劫持。
3. ROP链构造：
    1. 劫持rsp到msg0-2所在的堆块
    2. 保存rbp寄存器用于退出时恢复栈
    3. 构造commit_creds(prepare_kernel_cred(NULL))获取root权限
    4. 构造switch_task_namespaces(find_task_by_vpid(1), init_nsproxy)将进程的命名空间替换成init_nsproxy以获取root下的所有子权限
    5. 恢复rbp的值最后ret恢复正常的内核路径

## 六、容器逃逸

返回到用户空间此时的进程已经是root进程并且具有CAP_SYS_ADMIN权限。在kubernetes容器环境下，可以将当前进程的mnt、pid和net命名空间替换为1号进程的命名空间，实现容器逃逸，读取到宿主机的信息。

![截屏2024-01-25 22.00.23.png](/assets/posts/2024-01-29-CVE-2021-22555-Netfilter-NULL字节溢出/22.png)

## 七、知识总结

## 八、参考资料

[1][【kernel exploit】CVE-2021-22555 2字节堆溢出写0漏洞提权分析](https://bsauce.github.io/2021/09/23/CVE-2021-22555/)

[2] [CVE-2021-22555: Turning \x00\x00 into 10000$](https://google.github.io/security-research/pocs/linux/cve-2021-22555/writeup.html)

[3] [A Deep Dive into Iptables and Netfilter Architecture](https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture)

[4] [The Route to Root: Container Escape Using Kernel Exploitation](https://www.cyberark.com/resources/threat-research-blog/the-route-to-root-container-escape-using-kernel-exploitation)
