---
layout: post
title:  "Linux 内核漏洞挖掘与利用入门"
date:   2024-01-03 13:27:38 +0800
category: linux_kernel
---
这篇文章总结了 Linux 内核安全所需的入门知识，虽然不一定很全但是够用。涵盖了从环境搭建，到流行的漏洞挖掘工具使用，再到方法论总结三部分内容。


## 内核基础知识

### 内核态的由来

早期的计算机硬件和操作系统不支持用户态和内核态的划分，用户手动输入的代码可以操作整部计算机的资源，包括其他用户正在运行的程序，很显然里面存在巨大的安全隐患。DOS是这个时代具有代表性的操作系统。

![Untitled](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/Untitled.png)

DOS是一个单任务、单用户的操作系统，它运行在实模式（Real Mode）下，直接访问硬件资源，没有进行内核态和用户态的明确划分，所有的程序都在同一特权级别下运行，并且可以直接访问系统资源。

![Untitled](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/Untitled%201.png)

将系统划分为内核态和用户态源自于Unix操作系统，Unix系统的设计者认为将系统划分为内核态和用户态有利于提高系统的安全性和稳定性。这一功能需要CPU的支持，CPU只有陷入到内核态中才能操作硬件，以及CPU要具备内存权限的划分功能，将一些特定区域的内存标记为在内核态下可操作。

用户态是指用户程序执行的环境，而内核态是操作系统内核执行的环境。内核态具有更高的权限和访问系统资源的能力，而用户态只能通过系统调用等接口请求内核态提供的服务。

![Untitled](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/Untitled%202.png)

作为最知名的类Unix系统，Linux操作系统也继成了用户态和内核态的划分，在此基础上Linux系统发展出了更高级的权限管理、命名空间等安全机制。

![Untitled](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/Untitled%203.png)

### 用户态程序和内核的交互方式

应用程序通过系统调用与内核进行交互。

具体有两种方法：方法一是应用程序调用库函数，库函数封装了系统调用，再由库函数调用系统调用。方法二是应用程序使用汇编语言直接调用系统调用。

![Untitled](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/Untitled%204.png)

![截屏2024-03-21 20.56.41.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/1.png)

                                                                                 方法1

![截屏2024-03-21 20.58.48.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/2.png)

                                                                                 方法2

### 五大核心子系统及其功能

内存管理子系统：内存管理是内核中最重要的部分，负责分配系统的内存资源，向内核的其他部分提供分配和释放内存的接口，满足系统使用内存的需求。

进程调度子系统：进程调度子系统负责管理和调度系统中的进程，以实现多任务处理和资源分配。它的主要任务是根据一定的调度算法，决定哪些进程可以在CPU上执行，以及执行的顺序和时间片分配。

网络子系统：网络子系统负责管理和控制计算机系统的网络通信功能。它的主要任务是提供网络协议栈、网络设备驱动程序以及用户空间接口，以实现计算机系统与外部网络的通信和数据传输。

虚拟文件子系统：在Linux世界里”万物皆文件“，由虚拟文件子系统提供统一的文件系统接口，使得用户和应用程序能够以统一的方式来访问各种不同类型的文件系统，包括本地文件系统、网络文件系统以及特殊文件系统等。虚拟文件系统将底层的文件系统抽象为通用的文件操作接口，从而隐藏了不同文件系统的差异，提供了一种统一的文件访问机制。

进程间通信子系统：负责实现不同进程之间的数据传输和信息交换。它允许多个进程在同一系统上协同工作，并且共享数据、消息和其他资源，从而实现了进程之间的协作和通信。常见的进程间通信机制包括管道（Pipe）、信号（Signal）、消息队列（Message Queue）、共享内存（Shared Memory）、信号量（Semaphore）、套接字（Socket）等。

I/O子系统：负责管理计算机系统与外部设备之间的数据传输和通信。它的主要任务是控制和协调输入设备和输出设备的访问，以实现数据的输入和输出操作，并且提供了一种统一的接口，使得应用程序能够方便地与各种不同类型的设备进行通信和交互。它包括了各种设备驱动程序和中断处理程序。

![截屏2024-03-21 21.24.44.jpg](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/3.jpg)

### 内核的运行时扩展结构和内核API

在Linux内核中，运行时扩展结构是指一种动态加载到内核中的模块，可以在内核运行时添加新的功能或修改现有功能。这种扩展结构被称为Loadable Kernel Module（LKM），或者简称为内核模块。

内核模块是一种可以在内核运行时加载和卸载的可执行代码，它可以扩展内核的功能，添加新的设备驱动程序、文件系统、网络协议栈等功能，或者修改现有的内核行为。内核模块通常以共享对象（.ko文件）的形式存在，可以通过特定的工具加载到内核中，并且可以在不重新启动系统的情况下动态加载和卸载。

linux系统中ko文件通常存放在 **`/lib/modules/$(uname -r)/kernel/`**。在这个目录下，按照模块所属的功能或者类型进行分类，通常有drivers（驱动程序）、fs（文件系统）、net（网络协议）、sound（声卡驱动）等子目录，每个子目录中包含相应类型的内核模块文件。

提供了五大核心子系统的Linux内核文件位置位于/boot/vmlinuz-`uname -r`

 研究Linux内核安全包括了vmlinuz内核 + ko内核模块

![未命名绘图.jpg](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/4.jpg)

内核模块通过调用内核子系统提供的内核API使用内核的基础设施，完成相应的功能。

常用有内存管理API，例如负责内存分配和释放的kmalloc、kfree、vmallov、vfree，中断处理API，例如enable_irq、disable_irq

## 内核调试环境的搭建

### 内核源码的获取（清华源、阿里源、源码在线网站）

清华源：[https://mirrors.tuna.tsinghua.edu.cn/kernel/](https://mirrors.tuna.tsinghua.edu.cn/kernel/)

阿里源：[https://mirrors.aliyun.com/linux-kernel/](https://mirrors.aliyun.com/linux-kernel/?spm=a2c6h.13651104.d-4003.7.36cb7014yeJLsz)

源码在线：[https://elixir.bootlin.com/linux/latest/source](https://elixir.bootlin.com/linux/latest/source)

![未命名绘图-第 2 页.jpg](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/5.jpg)

### 常用工具的选择

源码分析工具：sourceinsight、vim

反汇编分析工具：IDA7.5、objdump

### 源代码编译环境搭建

主机系统：ubuntu 20.04 Desktop

![截屏2024-03-22 11.30.24.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/6.png)

依赖安装：

```bash
#安装编译工具
$ sudo apt install build-essential ncurses-dev xz-utils libssl-dev bc libelf-dev flex bison openssl
#安装qemu虚拟机
$ sudo apt install qemu-system
```

### 内核调试环境搭建

- 方案一最接近真实环境：vmware + gdb双机调试环境搭建

上位机系统为macOS 或者 windows操作系统

被调试环境环境为vmware中运行的发行版Linux系统，例如ubuntu

![未命名绘图-第 3 页.jpg](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/7.jpg)

打开vmx虚拟机配置文件，设置debugStub.listen.guest64=”1”，若没有这句话则自行添加

![截屏2024-03-22 11.51.10.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/8.png)

完成设置后打开ubuntu虚拟机，在上位机打开gdb，输入gdb命令连接ubuntu虚拟机

```bash
trget remote localhost:8864
```

可以看到ubuntu虚拟机断下，此时可以在gdb命令行调试ubuntu内核

![截屏2024-03-22 13.06.51.jpg](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/9.jpg)

- 方案二只验证漏洞原理：qemu + gdb调试环境

方案二相比方案一的系统开销更小，原因在于只加载必要的Linux运行时组件用于验证漏洞原理，此时相当于一个最小Linux系统。

制作根文件系统：

根文件系统包含了内核运行所必须的用户态程序，例如sh命令行工具。在发行版操作系统中，在开机过程中内核先加载位于/boot目录下的initrd-`uname -r`根文件系统，系统起来后再加载驱动程序和其他用户配置，将完整的桌面和服务呈现出来。

1. 下载busybox-1.35.0源码
2. 解压后进入源码目录执行make menuconfig，进入settings选项，钩上勾上Build static binary (no shared libs)。这一步的作用是所有文件静态链接，防止出现找不到库的情况

![截屏2024-03-22 15.37.07.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/10.png)

1. 保存退出，执行make install编译busybox。此时源码目录下多出了_install目录，在_install目录下构建Linux内核运行所必须的如下目录和文件：

```bash
# /proc文件系统
$ mkdir proc
# /sys文件系统
$ mkdir sys
# /dev设备节点文件系统
$ mkdir dev
# 系统启动配置脚本
$ touch init
$ chmod +x init
```

1. 在init文件中写入如下内容

```bash
#!/bin/sh

mkdir /tmp /dev
mount -t proc none /proc
mount -t sysfs none /sys
mount -t tmpfs none /tmp
mount -t devtmpfs none /dev
/bin/mdev -s
setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user
```

再将_install目录下的内容打包成根文件系统，在_install目录下得到rootfs.img文件：

```bash
$ find . | cpio -o --format=newc > ./rootfs.img

打包成gz压缩包
$ find . | cpio -H newc -ov | gzip -9 > ../initramfs.cpio.gz
```

qemu启动脚本：

将rootfs.img和编译好的Linux内核文件放在同一目录下，编写并执行如下qemu启动脚本：

```bash
#! /bin/sh

qemu-system-x86_64 \
-m 128M \
-cpu kvm64,+smep,+smap \
-kernel ./bzImage \
-initrd  ./rootfs.img \
-append "console=ttyS0 quiet kalsr" \
-smp cores=2,threads=1 \
-nographic \
-s
```

另起一个gdb终端，输入targte remote [localhost:1234](http://localhost:1234) 连接到qemu，即可对内核进行调试。

![截屏2024-03-22 16.30.57.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/11.png)

## 内核源码编译

### 源代码结构

Linux内核源码按照所实现的功能存放：

![截屏2024-03-22 17.29.46.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/12.png)

arch目录存放和体系结构相关的代码，例如电源管理、虚拟化、内存管理单元、启动时硬件的初始化等。其他目录虽然也有部分功能重合，但从调用关系的角度看，最终一定是调用到arch目录下实现最底层操作。

Documentation目录是一个组织结构良好的Linux内核文档，是初学者重要的参考资料。

drivers目录存放设备的驱动代码，是研究内核安全的重要研究内容。设备驱动程序很容易为内核引入新的攻击面，而且由于代码贡献者的水平不一，代码质量参差不齐，容易引发安全漏洞。

mm目录存放了内存子系统相关的代码，slab分配器源码保存在该目录下。开发Linux内核漏洞利用需要对slab分配器的原理和工作特性有较为深入的理解。

net目录存放了Linux网络功能的实现，也存放了许多网络协议栈的代码。网络协议栈也是内核安全的重要内容，此处发现的漏洞多为远程代码执行或者远程拒绝服务，危害较大值得关注。

### 编译命令

进入到Linux内核源码目录下

1. 首先配置内核编译选项，选择哪些功能模块编译进入内核、哪些编译成ko文件、哪些不编译

```bash
$ make menuconfig
```

需要编译进内核的选项前面按‘y’键，需要编译成内核模块按‘m’键，不需要编译按‘n’键，保存退出。

![截屏2024-03-22 23.39.09.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/13.png)

1. 编译内核。$(nproc)会自动计算出当前cpu可用的线程数量，提高编译过程中cpu的利用率，加快编译速度。

```bash
$ make -j$(nproc)
```

编译完成后可以在当前目录下找到vmlinux文件，该文件是Linux内核的elf格式可执行文件。该文件可以给研究者提供gdb调试信息和rop gadget。由于vmlinux文件中可加载段之间的相对地址偏移和内存中的相对偏移是相通的，攻击者可以利用这一特点结合信息泄露，绕过地址随机化保护。

![截屏2024-03-22 23.45.05.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/14.png)

如果主机是x86架构，编译完成后arch/x86/boot目录下得到bzImage文件，该文件是系统启动所需的文件，作为参数传递给qemu，它是vmlinux去符号后压缩形成的。

![截屏2024-03-23 00.01.03.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/15.png)

其他的就是散布在各个目录下的内核模块文件，后缀名为.ko。在运行时可以用insmod命令动态插入ko文件，这个过程就是驱动的加载。此时如果在命令行执行

```bash
$ make modules_install
```

那么会将所有编译出来的ko文件复制到当前系统的驱动目录下，这个过程就是驱动的安装。

## 内核模块编写与调试

内核模块的编写主要由两部分组成，实现功能的代码和控制编译过程的makefile文件。

### 内核模块代码模版

主要由模块加载时的init回调函数和模块卸载时的exit函数组成。

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("abin");
MODULE_DESCRIPTION("A simple example Linux module.");
MODULE_VERSION("0.01");

static int __init lkm_example_init(void) {
	printk(KERN_INFO "Hello, World!\n");
	/* TODO */
	return 0;
}
static void __exit lkm_example_exit(void) {
	printk(KERN_INFO "Goodbye, World!\n");
	/* TODO */
}

module_init(lkm_example_init);
module_exit(lkm_example_exit);
```

在命令行调用insmod xxx.ko命令加载模块时，内核会调用init函数进行模块的初始化。开发者将模块需要实现的一些功能通过init函数注册到Linux内核的对应功能框架上面，由功能框架向用户态提供统一的调用接口，应用程序通过调用接口间接使用内核模块提供的功能。

![linux内核安全入门.jpg](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/16.jpg)

在命令行调用rmmod xxx命令卸载模块时，内核会调用exit函数完成模块的清理工作，包括将模块从功能框架卸载、释放全局资源等工作。

### makefile文件模板

makefile文件的作用是，在编译时帮助找到Linux内核源代码目录，并以Linux源代码为依赖，在当前目录下编译出ko文件。

在内核模块代码目录下添加一个名为“Makefile”的文件，内容如下：

```makefile
obj-m += lkm_example.o
all:
	make -C /path/to/linux/source/code M=$(PWD) modules
clean:
	make -C /path/to/linux/source/code M=$(PWD) clean
```

obj-m表示要编译出ko文件，而非直接编译到vmlinux文件中。lkm_example需要和源代码文件名保持一致。

-C命令表示Linux源代码的根目录位置，M参数表示需要编译ko文件的源代码位置

all选项表示编译出ko文件，clean选项表示删除编译出来的ko文件

在当前目录下执行make命令即可编译出ko文件。

### 内核模块的加载和卸载

执行insmod和rmmod命令分别进行插入和卸载模块的操作，dmesg命令查看内核日志可以看到printk输出。

![截屏2024-03-23 09.59.22.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/17.png)

### 内核模块调试

方法1：gdb调试

方法2：代码中插入printk打印函数，在命令行使用dmesg查看打印结果

## Linux内核的攻击面——研究范围

**系统调用接口**：系统调用是用户空间程序与内核交互的主要方式。如果系统调用的实现存在漏洞，攻击者可能会利用这些漏洞执行恶意代码或提升权限。例如ptrace系统调用的信息泄露漏洞CVE-2013-2929、splice系统调用的任意文件写漏洞CVE-2022-0847。

**设备驱动程序：**Linux支持广泛的硬件设备，这些设备通过驱动程序与内核交互。驱动程序中的漏洞可能被用来绕过安全机制、执行代码或访问敏感信息。此类漏洞例如video4linux视频设备驱动条件竞争漏洞CVE-2019-18683、tty字符设备驱动条件竞争漏洞CVE-2017-2636。

**内核模块：**内核模块允许在运行时向内核添加新的功能。如果攻击者能够加载恶意模块，他们可能获得内核级别的控制权。例如在容器环境中由于容器本身配置不正确，攻击者有权限在容器中加载自定义内核模块，导致容器逃逸获取host的root shell。

**内存管理：**内核负责管理系统内存，包括用户空间程序和内核自身的内存。内存管理的缺陷可能导致信息泄露、权限提升或拒绝服务攻击。最著名的有CVE-2016-5195“脏牛”漏洞。

**文件系统：**内核通过文件系统提供对存储设备的访问。文件系统的漏洞可能被利用来绕过访问控制、修改系统文件或执行恶意代码。例如文件系统整数溢出漏洞CVE-2022-0185。

**网络协议栈：**Linux内核包含了实现各种网络协议的代码，用于数据的发送和接收。网络栈中的漏洞可能被用于远程代码执行、服务拒绝或数据泄露。例如TIPC协议堆溢出漏洞CVE-2021-43267、AF_PACKET 环形缓冲区溢出漏洞CVE-2017-7308。

## Linux内核漏洞攻击效果

远程代码执行 → 获得远程root shell

本地权限提升 → 获取本地root shell

任意文件修改 → 添加或修改root权限账户 → 获取本地root shell

信息泄露 → 泄露内核地址或者用户数据、密码、系统密钥，为进一步攻击提供便利

拒绝服务 → 系统不可用或者稳定性降低

![linux内核安全入门-第 2 页.jpg](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/18.jpg)

需要花费大量精力去挖掘漏洞，其次需要研究绕过安全机制的方法和获取系统最高权限的途径。最终目的是为攻击者建立对目标的持久化访问。

## Linux内核漏洞挖掘技术

### Linux内核的特点

1. 代码量极大，功能复杂。linux-6.8.0-rc1包含了10万多个文件

![截屏2024-03-23 12.20.56.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/19.png)

1. 模块化程度高，通盘审计不现实，通常要针对特定的模块或者子系统进行审计

### 代码审计是基本功

1. 需要了解操作系统基本原理，包括进程管理、内存管理、文件系统、设备驱动和网络通信等方面，这有助于理解内核代码的功能和设计理念。
2. 漏洞模型有部分与用户态漏洞相似，例如堆溢出、栈溢出、整数溢出、释放后重引用、信息泄露等。另一部分是内核运行环境所特有的漏洞，例如Double fetch，该漏洞是一种特定的竞态条件漏洞，当内核需要从用户空间程序读取数据时，内核可能首先检查数据以确定它是安全的，但在实际使用数据之前，攻击者修改了用户空间的数据。如果内核没有再次验证数据的合法性，就可能导致安全漏洞。再例如Dirty Cow漏洞，该漏洞在处理内存的“写时复制”的过程中产生了条件竞争，导致攻击者可以写入只读映射区域。
3. 根据设计文档审计代码，但内核不一定会完全按照文档的规范来实现全部的功能。
4. 在没有设计文档的情况下，可以结合开源的用户态程序，理解输入参数的意义和内核部分的设计原理。
5. 投入和产出不一定成正比。

### 自动化辅助挖掘（发现的漏洞占比多）

- 静态代码分析
1. 可以帮助识别常见的编码错误，如缓冲区溢出、空指针引用、未初始化的变量使用等。
2. 可以根据已知漏洞类型编写定制的查询语句批量化发现类似的漏洞。
3. 存在一定的误报率，需要人工审查。
4. 无法覆盖到一些运行时产生的路径，例如内核经常会在运行时加载所需的模块并且执行模块中的回调函数。在研究人员未理解上下文的情况下，静态分析可能无法覆盖到这些调用路径。

- 模糊测试

模糊测试（Fuzzing）是一种自动化的软件测试技术，通过自动生成大量的随机数据作为输入，来测试软件的稳定性和安全性。

1. 仿真运行内核，对内核接口进行大量随机测试，可以快速发现可能导致崩溃、死锁或不当行为的漏洞。
2. 不依赖于特定的漏洞模型，因此实际应用中可以发现条件竞争、释放后重引用这类使用静态分析或人工代码审计难以发现的漏洞。
3. 挖洞效果很大程度上依赖于代码覆盖率，提升代码覆盖率有利于提高发现漏洞的概率，需要“人在回路中”不断调整测试用例的生成模板以提高代码覆盖率。
4. 存在一定的误报率，需要人工审查确定可用性。

## 内核漏洞挖掘工具

### 静态分析工具CodeQL

CodeQL是由GitHub开发的代码分析引擎，用于自动化安全检查。

1. **CodeQL原理**

CodeQL 将目标代码转换成一个查询数据库。这一过程解析代码中的各种元素，把类、函数、变量等，并将它们及其相互之间的关系以数据库的形式存储。这样做的目的是将代码结构化成一种形式，使其可以通过CodeQL 查询语言进行有效查询。

数据库构建的过程：

由编译型语言构成的目标代码，例如C语言，CodeQL会将整个项目编译一遍，在编译过程中提取目标代码信息，包括抽象语法树的句法数据、关于名称绑定和类型信息的语义数据和源代码文件。每种编译类型的语言都有对应的提取器，目前支持C/C++、C#、Go、Swift、Java和Kotlin。

![linux内核安全入门-第 3 页.jpg](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/20.jpg)

对于脚本类型的语言，CodeQL直接运行源代码，从中提取依赖并构建数据库，目前支持JavaScript、Python和Ruby。

数据库查询语句：

CodeQL仿照SQL实现了一套面向对象的查询语言，基本结构如下：

```sql
/**
 *
 * Query metadata
 *
 */

import /* ... CodeQL libraries or modules ... */

/* ... Optional, define CodeQL classes and predicates ... */

from /* ... variable declarations ... */
where /* ... logical formula ... */
select /* ... expressions ... */
```

from语句定义查询范围，where语句定义筛选条件，select语言显示筛选出来的元素。

CodeQL查询原理：

CodeQL查询的本质是集合运算。

以匹配test函数中index > 2这个判断条件为例

```c
int get_user_input();
void edit();
void add();
void del();
void test(){

    int index = get_user_input();  
     
    if(index > 2)         // | test.cpp:9:8:9:16 | ... > ... |
        return;
    if(index == 0)
        add();
    if(index == 1)
        edit();
    if(index == 2)
        del();
}   
```

对应的CodeQL查询如下

```sql
import cpp

from IfStmt ifStmt, Expr cond
where
    ifStmt.getCondition() = cond and
    cond instanceof GTExpr
select cond
```

from语句定义了查询范围是if判断语句和表达式，分别用变量ifStmt和cond表示；

where语句定义了如下的集合运算过程，if条件判断部分和>关系表达式都是cond的子集，这两个子集做交集运算最后得到了“index > 2”这个表达式

![linux内核安全入门-第 5 页.jpg](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/21.jpg)

select把集合运算的最终结果显示出来，如下结果表示要找的表达式在代码的第9行，第8列开始

```sql
| test.cpp:9:8:9:16 | ... > ... |
```

1. **CodeQL文件架构**

CodeQL项目主要由2部分组成：

- CodeQL bundle：包含了codeql命令、针对每种编程语言的提取器、每种语言集成了一些常用的查询规则。下载地址为[https://github.com/github/codeql-action/releases](https://github.com/github/codeql-action/releases)
- CodeQL 查询库：包含更加完善的查询规则，用户可以在现有规则的基础上修改和添加自定义的查询规则。下载地址为[https://github.com/github/codeql](https://github.com/github/codeql)

CodeQL bundle和查询库一般都放在同级目录下，将codeql可执行文件路径添加到环境变量PATH中这样就可以在bash命令行直接运行codeql命令了。

![截屏2024-04-12 10.30.51.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/22.png)

搭建工作区：

CodeQL一般运行在vscode开发环境中，配合codeql插件一起使用。

将codeql-repo作为工作目录，用vscode打开。

![截屏2024-04-12 10.57.14.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/23.png)

以C语言查询库为例

![截屏2024-04-12 11.02.26.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/24.png)

在src目录下按照安全问题的分类建立各级子目录，以Likely Bugs目录为例

![截屏2024-04-12 11.22.54.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/25.png)

后缀名为.ql的文件就是CodeQL查询文件

![截屏2024-04-12 11.31.50.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/26.png)

1. **CodeQL分析Linux内核源码的步骤**

点击vscode左侧插件选项卡，搜索并安装codeql插件。

![截屏2024-04-12 23.40.43.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/27.png)

- 步骤一：构建数据库

```c
$ codeql database create cpp-database --language=c-cpp --command='make -j64' --source-root=/path/to/linux/source
```

cpp-database：替换为生成的数据库的名称

--language=c-cpp：表示使用C语言提取器提取编译信息

--command='make -j64'：编译内核命令

/path/to/linux/source：替换为Linux源码目录

上述命令根据Linux内核源码的路径找到Linux源码，在源码目录下执行编译命令，使用C语言提取器提取代码信息，保存到数据库中。

- 步骤二：编写查询语句

在src目录下选择一个安全问题分类目录，在现有的CodeQL脚本上修改，或者新建目录新建一个CodeQL脚本。

脚本的编写详见CodeQL语法：[https://codeql.github.com/docs/codeql-language-guides/](https://codeql.github.com/docs/codeql-language-guides/)

- 步骤三：编写测试用例

编写测试用例的目的是检查CodeQL查询语句是否能输出预期的结果。在达到预期的情况下，再对数据库进行查询。

cpp/ql/test/query-tests目录用于保存测试用例，在query-tests目录下新建一个目录用于保存.qlref文件和.cpp文件。

![截屏2024-04-12 14.38.09.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/28.png)

.qlref的作用是为vscode插件提供被测CodeQL脚本的位置，文件名部分与CodeQL脚本的文件名保持一致，内容是CodeQL脚本在src目录下的相对路径。

.cpp文件是测试用例，用于检测CodeQL脚本能否提取出目标代码和排除假阳性结果。

![截屏2024-04-12 14.40.21.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/29.png)

.qlref和.cpp文件准备好之后，点击vscode左侧的“代码测试”选项卡，找到.qlref文件并点击右侧的开始测试按钮。测试完毕后会在同级目录下生成结果文件，检查是否返回了所有目标点的位置。若测试通过就可以直接到数据库匹配了。

![截屏2024-04-12 21.19.15.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/30.png)

- 步骤四：运行CodeQL脚本

首先加载步骤一生成的数据库。点击vscode左侧的CodeQL插件选项卡，展开DATABASE选项卡，点击加载数据库，选择步骤一生成的数据库。

![截屏2024-04-12 23.28.53.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/31.png)

展开QUERIES选项卡，找到CodeQL脚本，点击运行箭头开始搜索数据库。

![截屏2024-04-12 23.48.30.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/32.png)

- 步骤五：分析查询结果

人工审查排除假阳性结果。

1. CodeQL实战挖掘内核漏洞的例子：CVE-2021-43267 tipc驱动堆溢出漏洞

2021年11月4日，SentinelLabs的研究人员使用CodeQL搜索Linux内核代码中的kmalloc函数调用，CodeQL语句如下：

![Untitled](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/Untitled%205.png)

上述语句的作用是搜索所有kmalloc调用，如果传递给kmalloc的实参类型的大小为2字节，也就是short或者unsigned short，那么就返回搜索结果。
搜索结果中如下代码片段引起了研究人员的注意：

![Untitled](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/Untitled%206.png)

在(1)处根据hdr中提取的size信息分配了一个堆块。
在(2)(3)处根据data中的size信息，将数据复制到堆块中。
这里存在两个潜在的问题：
在(3)的位置复制数据没有对长度进行检验。
(1)和(2)处的size来源不同，数据包头部的size字段可能与载荷部分的size字段不一致。

经证实此处存在堆溢出漏洞。

1. CodeQL的用途
- 漏洞变体分析

过程：从已有的漏洞中提取出漏洞原语 → 编写用于匹配漏洞原语的CodeQL查询语句 → 到数据库中搜索可疑位置 → 根据搜索结果修改查询条件以排除假阳性结果 → 人工审查排除假阳性结果 → 发现同类型的新的漏洞或不存在类似的漏洞

例子：CVE-2022-0185

![Untitled](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/Untitled%207.png)

代码3的位置是漏洞点，PAGE_SIZE为堆块大小为4096，如果在前面调用的过程中，size已经累加到4095，由于len是无符号整数，那么PAGE_SIZE-2-size就会向下溢出并且强制类型转化成大整数，造成此处的if判断被绕过。
代码4的位置，memcpy函数目的地址ctx→legacy_data是大小为4096的堆块，拷贝的字节数param→size和拷贝的内容param→string都是攻击者控制的，若代码3的位置被整数溢出绕过，那么memcpy就会发生越界写。

提取漏洞原语：

```c
if分支语句
		条件判断部分
				大于关系运算或小于关系运算
							关系运算符操作数都是无符号整数类型
										小的操作数是一个减法运算表达式
													减法运算的左操作数是一个常量表达式右操作数是一个变量访问表达式
```

根据漏洞原语编写CodeQL查询语句：

```sql
/**
 * @kind problem
*/

import cpp

from IfStmt ifStmt, Expr cond
where
    ifStmt.getCondition() = cond and      //提取if语句的条件判断部分
    cond instanceof GTExpr and            //条件判断部分是一个 >关系运算符
    // >关系运算符的左侧是一个无符号整数
    ifStmt.getCondition().(GTExpr).getGreaterOperand().getUnderlyingType().(IntegralType).isUnsigned() and
    // >关系运算符的右侧是一个减法表达式，且被减数是一个变量访问表达式
    exists(SubExpr sub, VariableAccess va | 
        ifStmt.getCondition().(GTExpr).getLesserOperand() = sub and
        sub.getRightOperand() = va)
select ifStmt, "may be underflow "
```

分析查询结果：

在Linux内核源码中找到81处这样的代码，CVE-2022-0185的漏洞位置也包含在其中，点击查询结果即可导航到源码的位置。上述CodeQL查询可以进一步优化。

![截屏2024-04-13 08.31.12.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/33.png)

- 漏洞利用开发阶段查找有用的数据结构

我们想寻找一个包含函数指针的结构体用于控制流劫持，可以编写如下查询代码：

```sql
import cpp

// 定义一个CodeQL类，这个类继承自普通的类，其中包含函数指针的结构体
class StructWithFunctionPointer extends Struct {
// 类的构造函数，符合条件的结构体组成StructWithFunctionPointer集合
  StructWithFunctionPointer() {
    exists(Field f, FunctionPointerType fp |
// 如果存在结构体成员的类型是函数指针类型
      f.getType() = fp and
// 并且结构体成员定义在Struct内部
      f.getDeclaringType() = this
// 满足这样条件的结构体就是函数指针结构体
    )
  }
}

from StructWithFunctionPointer s, Field f 
where 
    f.getDeclaringType() = s and
    f.getType() instanceof FunctionPointerType
select s, f
```

找到了5681个包含函数指针的结构体，其中不乏一些在漏洞利用中常用到的结构体。

![截屏2024-04-13 08.37.05.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/34.png)

- CodeQL自动化审计

CodeQL配合Github Actions可以实现对Github项目的自动化审计。

GitHub Actions是GitHub提供的一项功能，可以让开发者在其代码仓库中设置自动化的工作流程。通过GitHub Actions，用户可以编写自定义的任务和操作，例如自动运行测试、构建应用程序、部署到服务器等。这些任务可以触发于各种事件，例如代码提交、拉取请求合并等。

二者结合可以在代码提交的时候进行安全检查，及时发现安全漏洞。

配置Github Actions的方法是在仓库根目录下创建.github/workflows/xxxx.yml文件。Github提供了生成CodeQL自动化审计模板的方法，以下基于此介绍。

步骤一：配置Github Actions

进入“配置”选项卡

![截屏2024-04-13 13.38.49.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/35.png)

选择CodeQL高级配置，接下来页面会跳转到codeql.yml模板编辑页面

![截屏2024-04-13 13.40.05.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/36.png)

此处定义了发生代码push和pull request的时候触发CodeQL对整个项目的扫描

![截屏2024-04-13 13.46.43.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/37.png)

runs-on定义了项目的编译环境，这里选择ubuntu-latest

![截屏2024-04-13 13.52.57.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/38.png)

整个项目由C语言编写，在c-cpp一项中把编译方式修改为manual。因为一些代码通常是使用configure和make命令来编译，而不是系统默认的gcc编译命令，所以这里要把编译方式改为手动，否则CodeQL会使用系统默认编译命令，导致数据库构建失败。

![截屏2024-04-13 13.50.06.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/39.png)

把run后面的内容替换为项目的编译命令，这样Github云端就能生成项目的数据库了。

![截屏2024-04-13 13.54.00.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/40.png)

步骤二：

保存codeql.yml文件，Github云端开始对整个项目使用CodeQL进行扫描。扫描完成后进入“安全”选项卡。

![截屏2024-04-13 13.32.22.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/41.png)

可以看到CodeQL已经识别出了插入到代码中的double free漏洞，并且给出了引入该漏洞的代码提交信息。

![截屏2024-04-13 13.34.50.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/42.png)

- CodeQL与ChatGPT

可以与ChatGPT通过问答的方式提取漏洞原语，自己编写CodeQL查询语句或让ChatGPT自动生成。

### 模糊测试工具syzkaller

Syzkaller是由谷歌的安全工程师Dmitry Vyukov领导开发的一个开源的、可扩展的内核模糊测试工具，主要用于发现操作系统内核中的安全漏洞。

syzkaller由go语言编写，实现了一套用于描述系统调用的语言syz-lang。用户使用syz-lang编写系统调用描述符用于描述系统调用接收的参数和返回值，syzkaller根据系统调用描述符生成测试用例对内核进行fuzz。

fuzz过程通过自动生成系统调用序列来对内核进行压力测试，以此来触发内核崩溃、死锁或者其他错误行为，进而揭露可能的漏洞。syzkaller 支持多种操作系统平台，包括但不限于 Linux、Windows、FreeBSD、NetBSD 和 Fuchsia。

1. syzkaller工作原理

syzkaller主要由syz-manager、syz-fuzzer、syz-executor三部分组成。被测试的内核运行在虚拟机中，使用ssh与host通信。

![linux内核安全入门-第 4 页.jpg](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/43.jpg)

syz-manager运行在host中，主要负责启动、监控、重启虚拟机，在运行的虚拟机中启动syz-fuzzer进程。在fuzz过程中syz-manager通过监控虚拟机的内核日志来发现内核异常，并将内核异常的现场和触发异常的输入保存到数据库中。

syz-fuzzer和syz-executor都运行在虚拟机中，syz-manager使用scp命令将这两个文件拷贝到虚拟机中。syz-fuzzer的作用是生成测试用例，在fuzz过程中对测试用例进行变异，将测试用例输入给syz-executor执行，同时收集代码覆盖率信息，将触发了新的程序路径的测试用例通过RPC发送到syz-manager保存。

syz-executor接收来自syz-fuzzer的测试用例，将执行的结果返回给syz-fuzzer。

1. syzkaller目录结构

对syzkaller进行编译生成的可执行文件保存在bin目录中。sys目录用于保存系统调用描述符。

![截屏2024-04-13 15.21.03.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/44.png)

sys目录下按照操作系统类型分类存放系统调用描述符。

![截屏2024-04-13 15.45.47.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/45.png)

以Linux系统为例，.txt文件保存的是系统调用描述符，每个文件都对应一个同名的.const文件，用于保存从内核源码中提取出来的常数。用户在此目录下添加或修改.txt文件来自定义fuzz行为。

![截屏2024-04-13 15.48.09.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/46.png)

1. syzkaller实战挖掘漏洞的例子

案例一：CVE-2022-0185 文件系统的整数溢出漏洞

2022年1月6日willsroot团队使用syzkaller模糊测试工具发现了该漏洞：

![Untitled](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/Untitled%208.png)

syzkaller根据触发崩溃的测试用例生成了PoC代码：

![Untitled](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/Untitled%209.png)

经验证，该崩溃是fsconfig系统调用存在整数溢出引起的，可被用来提权。

案例二：2022年1月发现的蓝牙驱动UAF漏洞

该漏洞影响linux5.12.0-linux5.15.0版本的内核，位于net/bluetooth/sco.c文件中的sco_sock_timeout函数。

![截屏2024-03-24 21.40.19.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/47.png)

该漏洞的成因是如果对同一个蓝牙socket进行两次connect操作，第二次connect操作会将第一次connect生成的sock对象释放掉，但对应的定时器却没有取消。超时之后调用sco_sock_timeout函数，该函数到已被释放的sock对象中修改变量、调用函数指针，造成了UAF。

![截屏2024-03-24 22.09.37.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/48.png)

该UAF漏洞中存在对函数指针的调用，因此是一个品相比较好的漏洞。经过和王宇轩的一番研究写出了漏洞利用程序。

![截屏2023-04-17 22.31.37.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/49.png)

1. 如何开始测试一个新的接口

syzkaller实现了一套用于描述Linux系统调用接口的语言syz-lang。使用syz-lang描述系统调用的名称、接收的参数和返回值，统称为系统调用描述符。

系统调用描述符需要研究人员根据Linux系统调用的实现进行编写。

syzkaller根据系统调用描述符，按照依赖关系生成系统调用序列和对应的参数作为测试用例。

syzkaller提供了不同操作系统各个子系统的模板，保存在项目sys文件夹中，按照操作系统分类。

可以使用默认的模板直接进行fuzz，但会产生很多误报和漏报。

![截屏2024-03-24 22.21.13.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/50.png)

- 研究接口，找到与之对应的系统调用

到网上找到关于接口的信息、特殊常量

到源码目录下查询Document目录

到源码目录下查找 tools/testing目录

到源码中查看注释

使用git blame命令或者git log命令查找最开始添加接口时的提交注释

阅读内核源代码、阅读用户态库、阅读应用代码

- 阅读syzkaller文档和现成的例子写出系统调用描述符

sys/linux/<subsystem>.txt文件描述了特定子系统的接口

sys/linux/sys.txt文件描述了更加底层范围更广的接口，是<subsystem.txt>的依赖

- 运行新增/修改系统调用描述符
- 查看代码覆盖率信息

“人在回路中”测试，通过检查代码覆盖信息发现fuzz过程卡在哪个环节，最大限度提高代码覆盖率。

- 系统调优，提高fuzz的效率

根据系统的负载调整虚拟机的数量、虚拟机的内存和CPU配置、每个虚拟机内fuzz进程的数量，最大限度利用系统的计算资源。

1. 示例：对Linux内核netfilter防火墙进行fuzz

fuzz对象是Linux-6.8.0-rc1

步骤一：编写系统调用描述符

syzkaller自带了netfilter系统调用描述符，Linux-6.8.0-rc1版本的netfilter子系统发生了变动，因此要根据变动对原有的文件进行修改。

系统调用描述符文件大致由3部分内容组成

include头文件：这些都是linux内核中的头文件，保存了常数的定义，编译生成syzkaller可执行文件的过程中，会到这些头文件中提取常数并在同级目录下生成同名的.const文件。

系统调用函数：根据man手册编写，定义了系统调用名称、参数和返回值。

结构体：系统调用参数部分需要用到的结构体。

需要注意的是，这些定义的名称尽可能与Linux内核源码保持一致。

![截屏2024-04-13 16.35.54.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/51.png)

步骤二：编写运行配置

配置文件一般和可执行文件一起放在bin目录下，是一个json格式的文件。

target字段设置系统调用的架构。例如在amd64架构下，Linux内核同时实现了64位和32位的系统调用，当我们要在64位的内核环境中测试32位的系统调用，就需要指定这个字段。在qemu的磁盘镜像中包含了构建目标系统elf文件的工具链，测试用例在虚拟机中现场编译，target字段控制编译的目标架构。

syzkaller会开启一个http服务，用于查看整个fuzz的过程。http字段指定服务的监听地址和端口。

image字段指向qemu运行的磁盘镜像，该镜像由syzkaller自带的脚本生成，需要用户手动运行该脚本，最终会生成一个debian磁盘镜像，其中包含了ssh服务和编译工具链。

enable_syscalls字段是一个列表，包含了需要fuzz的系统调用，这里包含了和netfilter相关的所有系统调用。

![截屏2024-04-13 17.07.48.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/52.png)

步骤三：开始fuzz

![截屏2024-04-13 17.34.17.png](/assets/posts/2024-12-23-Linux内核漏洞挖掘与利用入门/53.png)

## 常见的防御手段

### kaslr

系统把Linux内核的代码段加载到0xffffffff81000000 + n * 0x1000的位置，使攻击者难以预测内核中数据和代码的内存地址。

### freelist random、freelist harderning

freelist random（空闲列表随机化）和freelist harderning（空闲列表加固）是两种用于增强slub分配器安全的技术，前者旨在防止攻击者对堆地址空间进行堆喷射，后者用于保护空闲堆块的链表指针不被攻击者篡改。

### SMEP、SMAP

SMEP用于防止在内核态执行用户空间（即非特权模式）的代码，用于防御ret2user攻击。

SMAP用于防止在内核态访问用户空间的数据。

### 结构体布局随机化

通过改变编译时内核结构体的字段排序来增加随机性。这意味着即使攻击者能够找到一个漏洞来读写内核内存，他们也无法确定任何特定数据的确切位置，因为这些位置在每次内核编译时都会改变。

## 工具与方法论

- 工具选择很重要

因为代码量很大，选择合适的工具，先使用、再理解、最后改进

- 摆脱随机挖洞，把经验以工具的形式沉淀，针对特定的子系统进行挖掘
- 关注安全公告