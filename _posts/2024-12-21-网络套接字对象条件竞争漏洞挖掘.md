---
layout: post
title:  "网络套接字对象条件竞争漏洞挖掘"
date:   2024-12-21 13:27:38 +0800
category: linux_kernel
---


## 一、问题背景

## 二、技术路线

采用CodeQL静态分析和Syzkaller模糊测试相结合的方法。

[CodeQL zero to hero part 1: The fundamentals of static analysis for vulnerability research](https://github.blog/developer-skills/github/codeql-zero-to-hero-part-1-the-fundamentals-of-static-analysis-for-vulnerability-research/#appendix-1-abstract-syntax-tree-for-the-example-python-program)

[CodeQL zero to hero part 2: Getting started with CodeQL](https://github.blog/developer-skills/github/codeql-zero-to-hero-part-2-getting-started-with-codeql/)

[CodeQL zero to hero part 3: Security research with CodeQL](https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-3-security-research-with-codeql/)

[Advanced dataflow scenarios for C/C++ — CodeQL](https://codeql.github.com/docs/codeql-language-guides/advanced-dataflow-scenarios-cpp/)

这两篇文章写了isBarrier怎么用。

[CodeQl 从0到0.1](https://f5.pm/go-105949.html)

[New dataflow API for writing custom CodeQL queries · GitHub Changelog](https://github.blog/changelog/2023-08-14-new-dataflow-api-for-writing-custom-codeql-queries/)

## 三、分析对象

Linux内核源码net目录下的所有网络协议的

socket、close、bind、connect、ioctl、compat_ioctl、sendmsg、recvmsg、mmap、setsockopt、getsockopt系统调用。

因为这些系统调用都以struct socket *sock作为参数，sock是套接字对象，它在同一个进程的多个线程之间是共享的，多线程环境下可以有多个内核路径读写它。

## 四、漏洞原语

在读写sock的过程中有非常复杂的状态机变化，这一过程通常需要锁来保护，否则某一条内核路径上可能会出现状态机的非预期变化，在该路径的后续过程中引发实质性的内核漏洞，例如UAF、越界读写、double free等。

### 1. 样本分析

**样本1：**cve-2021-26708 vsock条件竞争漏洞，版本Linux 5.10.12，位于net/vmw_vsock/af_vsock.c文件 [**vsock_stream_setsockopt**](https://elixir.bootlin.com/linux/v5.10.12/C/ident/vsock_stream_setsockopt)函数

![截屏2024-10-12 08.59.49.png](/assets/posts/2024-12-21-网络套接字对象条件竞争漏洞挖掘/1.png)

vsock是多线程之间的共享对象，在加锁之前vsk→transport被赋值给局部变量transport。

但是vsk→transport在加锁之前有可能改变。例如原对象被释放vsk→transport指向性对象。

结果就是后续对transport变量的访问造成了UAF。

**样本2：**cve-2016-8655 packet sock条件竞争漏洞，版本Linux 4.8，漏洞位于net/packet/af_packet.c文件packet_setsockopt函数

```c
struct sock *sk = sock->sk;
struct packet_sock *po = pkt_sk(sk);
	...
switch (optname) {
	...
	case PACKET_VERSION:
	{
		int val;
		if (copy_from_user(&val, optval, sizeof(val)))
			return -EFAULT;
		switch (val) {
			case TPACKET_V1:
			case TPACKET_V2:
			case TPACKET_V3:
				po->tp_version = val;
				return 0;
			...
		}
		...
	}
	...
}
```

po是多线程之间的共享对象，修改po→version之前未加锁，

导致为TPACKET_V3版本套接字分配环形缓冲区的过程中，版本号可以被篡改为TPACKET_V1，

close操作中按照TPACKET_V1的逻辑释放环形缓冲区，遗漏了关联的定时器没有销毁，

定时器超时后造成了UAF。

**样本3：**cve-2021-32606 can总线isotp协议条件竞争漏洞，版本Linux 5.12.0，漏洞位于net/can/isotp.c文件iostp_setsockopt函数

```c
static int isotp_bind(struct socket *sock, struct sockaddr *uaddr, int len)
{
	...
	/* do not register frame reception for functional addressing */
	if (so->opt.flags & CAN_ISOTP_SF_BROADCAST)           [1]
		do_rx_reg = 0;
	...
	if (do_rx_reg)
		can_rx_register(net, dev, addr->can_addr.tp.rx_id,
				SINGLE_MASK(addr->can_addr.tp.rx_id),
				isotp_rcv, sk, "isotp", sk);
	...
	so->bound = 1;
	...
	
static int isotp_setsockopt(struct socket *sock, int level, int optname,
			    sockptr_t optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	struct isotp_sock *so = isotp_sk(sk);
	int ret = 0;

	if (level != SOL_CAN_ISOTP)
		return -EINVAL;

	if (so->bound)							                         [1]
		return -EISCONN;

	switch (optname) {
	case CAN_ISOTP_OPTS:
		if (optlen != sizeof(struct can_isotp_options))
			return -EINVAL;

		if (copy_from_sockptr(&so->opt, optval, optlen))	 [2]
			return -EFAULT;
		break;
	...
	
	
static int isotp_release(struct socket *sock)
{
	...

	/* remove current filters & unregister */
	if (so->bound && (!(so->opt.flags & CAN_ISOTP_SF_BROADCAST))) {		[1]
		if (so->ifindex) {
			struct net_device *dev;

			dev = dev_get_by_index(net, so->ifindex);
			if (dev) {
				can_rx_unregister(net, dev, so->rxid,		[2]
						  SINGLE_MASK(so->rxid),
						  isotp_rcv, sk);
				dev_put(dev);
			}
		}
	}
	...
```

so是多线程之间的共享对象，setsockopt在修改so→opt [2]之前未上锁，

bind在读取so→opt [1]之前未上锁，导致注册回调函数对象过程中so→opt被篡改，

close根据被篡改过的so→opt没有注销回调函数对象[2]导致UAF。

**样本4：**cve-2021-3609 can总线bcm协议条件竞争漏洞，版本Linux 5.4，漏洞位于net/can/bcm.c文件bcm_release函数

```c

static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
                        int ifindex, struct sock *sk)
{
	...

        /* check the given can_id */
        op = bcm_find_op(&bo->rx_ops, msg_head, ifindex);
        if (op) {
                /* update existing BCM operation */

		/* update struct members of op */

                /* Only an update -> do not call can_rx_register() */
                do_rx_register = 0;

        } else {
                /* insert new BCM operation for the given can_id */
                op = kzalloc(OPSIZ, GFP_KERNEL);

		/* initialization of op */

		do_rx_register = 1;						 [1]

	}

	...

        /* now we can register for can_ids, if we added a new bcm_op */
        if (do_rx_register) {
                if (ifindex) {
                        struct net_device *dev;

                        dev = dev_get_by_index(sock_net(sk), ifindex);
                        if (dev) {
                                err = can_rx_register(sock_net(sk), dev,	[2]
                                                      op->can_id,
                                                      REGMASK(op->can_id),
                                                      bcm_rx_handler, op,
                                                      "bcm", sk);

                                op->rx_reg_dev = dev;
                                dev_put(dev);
                        }
	...
}

static void bcm_rx_handler(struct sk_buff *skb, void *data)
{
	struct bcm_op *op = (struct bcm_op *)data;
	const struct canfd_frame *rxframe = (struct canfd_frame *)skb->data;
	unsigned int i;

	if (op->can_id != rxframe->can_id)
		return;

	/* make sure to handle the correct frame type (CAN / CAN FD) */
	if (skb->len != op->cfsiz)
		return;

	/* disable timeout */
	hrtimer_cancel(&op->timer);
	
	...
}

static int bcm_release(struct socket *sock)
{
	...

        /* remove bcm_ops, timer, rx_unregister(), etc. */

        unregister_netdevice_notifier(&bo->notifier);

        lock_sock(sk);								        [1]

        list_for_each_entry_safe(op, next, &bo->tx_ops, list)
                bcm_remove_op(op);

        list_for_each_entry_safe(op, next, &bo->rx_ops, list) {
         
	...

                bcm_remove_op(op);						[2]
        }

	...

        sock_orphan(sk);
        sock->sk = NULL;

        release_sock(sk);
        sock_put(sk);							           [3]

	return 0;
}
```

op是多线程共享对象，bcm_release全程加锁保护op的释放操作，在接收回调函数bcm_rx_handler中，全程没有对op加锁保护，如果bcm_rx_handler正在执行，同时释放bcm套接字，就会导致bcm_release释放掉了正在使用中的op，造成UAF，而op又是在bcm_rx_setup中注册到全局链表的。bcm_rx_handler调用前加了rcu锁，close加的却是sock的锁，对同一个资源op进行操作，加的却不是同一把锁，导致锁保护失效。

### 2. 原语提炼

前三个例子可以总结为对全局对象sock读/写之前没有加锁。sock作为参数传递给socket、close、bind、connect、ioctl、compat_ioctl、sendmsg、recvmsg、mmap、setsockopt、getsockopt系统调用。lock_sock(sk)是加锁操作，release_sock(sk)是释放锁操作。以传递给上述函数的sock对象为source，对sock的读/写操作为sink，若source和sink之间不存在lock_sock函数，那么判定为缺失锁保护。

## 五、具体方法

先测试能否找到例1、例2、例3的漏洞

进展：顺着这个思路，我翻遍了 net 目录下的内容，终于在蓝牙 sco 协议中发现了一个因使用锁不当造成的条件竞争漏洞。[**蓝牙sco条件竞争漏洞挖掘与分析**](https://qiutianshu.github.io/linux_kernel/2025/01/18/%E8%93%9D%E7%89%99sco%E9%A9%B1%E5%8A%A8%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98.html)