---
layout: post
title:  "利用 meltdown 漏洞绕过 Linux 内核地址随机化"
date:   2020-06-01 13:27:38 +0800
category: intel_processor
---
我对利用“熔毁”漏洞绕过 Linux 内核地址随机化的研究最早发布在看雪课程[《**Intel CPU漏洞研究**》](https://www.kanxue.com/book-section_list-76.htm)，这篇文章是我整理出的第三节内容的文字版。

# meltdown 漏洞简介

Meltdown破坏了位于⽤户和操作系统之间的基本隔离，此攻击允许程序访问内存，因此其他程序以
及操作系统的敏感信息会被窃取。这个漏洞“熔化”了由硬件来实现的安全边界。允许低权限⽤户级别的应⽤程序“越界”访问系统级的内存，从⽽造成数据泄露。
“熔毁”漏洞的根本原因是CPU流⽔线执⾏指令过程中异常信号的发出和乱序执⾏之间存在竞争 。当⽤
户程序访问内核地址空间时，CPU的乱序执⾏使得本来应该被地址异常阻⽌的⾮法访问指令在流⽔线中得到执⾏，虽然这个结果最后会被丢弃，但是乱序执⾏导致了CPU微架构状态的改变。攻击者可以通过探测微架构状态的改变获知内核地址处的信息。

# 流⽔线对异常的处理

- **内部异常的产⽣**

异常的产⽣：halt指令 2、⾮法指令、试图访问⼀个⾮法地址

- **流⽔线对内部异常的处理**

如果⼀条指令在流⽔线中的某⼀个阶段产⽣了⼀个异常，异常状态和指令信息会沿流⽔线传播，⼀直到达流⽔线的写回阶段，这个时候流⽔线逻辑就会发现异常停⽌指令的执⾏并清空流⽔线

![e13a26f1813ef35f6e10c136f02879cd.png](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/e13a26f1813ef35f6e10c136f02879cd.png)

⽤户空间通过mov指令访问内核空间地址时，在流⽔线的访存阶段会检测到这⼀⾮法访问。具体的过程是1）执⾏单元从内核地址处获得数据 2）访存的同时执⾏单元访问⻚表进⾏权限检查 3）检测到从⽤户空间访问内核的⾏为并发出异常 4）在写回阶段停⽌指令的执⾏并清空流⽔线。
问题就出在第⼆步执⾏权限检查要通过访问⻚表项来实现，这⾥⼜要进⾏⼀次访存，所以就会有⼀个时间窗⼝使得异常指令之后的指令得到执⾏并且利⽤第⼀步中获得的内核地址处的内容！

![56d723b78d94aa61eff8db0ef6dbe828.jpg](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/56d723b78d94aa61eff8db0ef6dbe828.jpg)

# Linux地址空间映射

![b692bf092b66118611a37fa2e9a37eae.jpg](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/b692bf092b66118611a37fa2e9a37eae.jpg)

![fb1ef6879d9a6dd7ecf1c2c1eb212348.jpg](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/fb1ef6879d9a6dd7ecf1c2c1eb212348.jpg)

# Flush+Reload攻击

![30f89362b75b7e0b38952c66083028ff.png](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/30f89362b75b7e0b38952c66083028ff.png)

![fb12ce806c14344dc39407bad0107f04.png](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/fb12ce806c14344dc39407bad0107f04.png)

# “熔毁”与“幽灵”的异同

- **相同点**

都利⽤了处理器乱序执⾏的特点，使得在正常执⾏流中不可能得到执⾏的代码被加载到流⽔线中并得到执⾏，虽然执⾏结果得不到提交但影响了CPU的微架构状态。攻击者利⽤微架构状态的改变作为隐蔽信道实现数据的传输。
• **不同点**

1. “幽灵”漏洞利⽤的前导是分⽀指令，利⽤的是分⽀预测执⾏；“熔毁”漏洞利⽤的前导是内部异常指令，利⽤的是乱序执⾏。
2. “幽灵”漏洞突破的进程之间的隔离，攻击者可以窥探⽬标进程内的数据；“熔毁”突破了操作系统内核态和⽤户态之间的内存访问隔离，攻击者可以获得内核地址空间的内容。

# 利用meltdown绕过KASLR

![bc9108006fe49d2973bb4c98f41329e4.jpg](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/bc9108006fe49d2973bb4c98f41329e4.jpg)

![9f3b494870badcb6a0a89ee5f55a915f.jpg](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/9f3b494870badcb6a0a89ee5f55a915f.jpg)

# 攻击程序的设计

通过爆破得到linux_proc_banner字符串的运行时地址，减去链接地址得到随机化偏移，再将随机化偏移加上内核代码段的链接地址得到内核代码段运行时地址。

![e02dc695d98f59ee73e119f86bed9ccc.jpg](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/e02dc695d98f59ee73e119f86bed9ccc.jpg)

计算内核代码段基地，配合实施程序流劫持攻击。

逐地址爆破得到linux_proc_banner的运行时地址，减去字符串在在vmlinux文件中的偏移得到运行时基地址。

内核代码段基地址 = addr(linux_proc_banner) - offset

[演示视频](https://www.bilibili.com/video/BV1G8a4z8EZx/?vd_source=e55c3842a48b813bb7e691d3241e4a19)

# 附件

[“熔毁”漏洞原理.pdf](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/熔毁漏洞原理.pdf)

[内核地址随机化在Linux5.0内核x86_64下的实现.pdf](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/内核地址随机化在Linux5.0内核x86_64下的实现.pdf)

[实验代码.zip](/assets/posts/2020-06-02-利用-meltdown-漏洞绕过-Linux-内核地址随机化/实验代码.zip)